<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on La Vie en Code - 编码人生</title>
    <link>https://elizurhz.cn/categories/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on La Vie en Code - 编码人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 22 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://elizurhz.cn/categories/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>React 中一些容易被忽视的 API</title>
      <link>https://elizurhz.cn/frontend/react-apis/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/react-apis/</guid>
      <description>useMemo &amp;amp; useCallback Hooks 都只存在于 Functional Component 之中，而 Functional Component 在 re-render 时会把整个函数执行一遍，而不是像 Class Component 一样只执行生命周期钩子而不会单独执行类方法。并且由于和 React 渲染相关的函数/计算都要写在 Functional Component 的函数体中，所以这些函数不免会再执行一遍。当我们遇到比较耗性能的计算时，运算函数的重复执行会占用大量的资源。这时候就需要 useMemo 了。
useMemo 会保存一个带记忆功能的值。它会在 render 的时候，根据设定的依赖来执行。
从 @types/react 的包中可以找到 useMemo 的函数签名：
function useMemo&amp;lt;T&amp;gt;(factory: () =&amp;gt; T, deps: DependencyList | undefined): T;  它的第一个参数是一个函数，也就是在 hook 被执行的时候，会执行这个函数。但需要注意的是这个函数必须要有一个返回值，因为我们的目的就是要得到一个值啊。然后第二个参数是依赖，是一个数组，它的意思是只有数组里的变量发生变化时才会执行这个 hook，这一点和之前我写过的 useEffect 是一样的。
然后，useCallback(fn, deps) 实际上就相当于 useMemo(() =&amp;gt; fn, deps)：
function useCallback&amp;lt;T extends (...args: any[]) =&amp;gt; any&amp;gt;(callback: T, deps: DependencyList): T;  useRef useRef 其实可以把它视为 React 中 ref 的 hooks 版本。它也有“记忆”的功能，但是和 useMemo 不一样的是，它会创建一个包含 .</description>
    </item>
    
    <item>
      <title>用 React 16.3 的 Context API 实现类似 ant design 的 Material Design 版 Radio Group 组件</title>
      <link>https://elizurhz.cn/frontend/how-to-use-context-in-react/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/how-to-use-context-in-react/</guid>
      <description>Radio 组件是什么样的 以官方文档的例子：
import React from &amp;quot;react&amp;quot;; import { Radio } from &amp;quot;antd&amp;quot;; class App extends React.Component { state = { value: 1 }; onChange = e =&amp;gt; { console.log(&amp;quot;radio checked&amp;quot;, e.target.value); this.setState({ value: e.target.value }); }; render() { return ( &amp;lt;Radio.Group onChange={this.onChange} value={this.state.value}&amp;gt; &amp;lt;Radio value={1}&amp;gt;A&amp;lt;/Radio&amp;gt; &amp;lt;Radio value={2}&amp;gt;B&amp;lt;/Radio&amp;gt; &amp;lt;Radio value={3}&amp;gt;C&amp;lt;/Radio&amp;gt; &amp;lt;Radio value={4}&amp;gt;D&amp;lt;/Radio&amp;gt; &amp;lt;/Radio.Group&amp;gt; ); } } ReactDOM.render(&amp;lt;App /&amp;gt;, mountNode);  除了这种方式，还有使用 options 这个 prop 传递配置文件进行渲染的：
import React from &amp;quot;react&amp;quot;; import { Radio } from &amp;quot;antd&amp;quot;; const plainOptions = [&amp;quot;Apple&amp;quot;, &amp;quot;Pear&amp;quot;, &amp;quot;Orange&amp;quot;]; const options = [ { label: &amp;quot;Apple&amp;quot;, value: &amp;quot;Apple&amp;quot; }, { label: &amp;quot;Pear&amp;quot;, value: &amp;quot;Pear&amp;quot; }, { label: &amp;quot;Orange&amp;quot;, value: &amp;quot;Orange&amp;quot; } ]; const optionsWithDisabled = [ { label: &amp;quot;Apple&amp;quot;, value: &amp;quot;Apple&amp;quot; }, { label: &amp;quot;Pear&amp;quot;, value: &amp;quot;Pear&amp;quot; }, { label: &amp;quot;Orange&amp;quot;, value: &amp;quot;Orange&amp;quot;, disabled: false } ]; class App extends React.</description>
    </item>
    
    <item>
      <title>React Hooks 能给我们带来什么</title>
      <link>https://elizurhz.cn/frontend/how-hooks-helps/</link>
      <pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/how-hooks-helps/</guid>
      <description>TL;DR 很多 React 的新技术，我们大多数人也只是听说而已，实际上投入生产的机会非常少。首先很多旧项目不会去升级 React 的版本，很多团队因为不精通技术而且只需要专注于做业务，所以也没有这样的成本来升级 React 的版本。而我刚好遇到了好的机会，让我有足够的技术自由度，我也趁着一个重构的机会，顺便把负责组件全部用 hooks 重构了。这次重构是在 2019 年 6 月下旬开始的，并且也要感谢 react-redux 在 6 月上旬的时候发布了 v7.1.0，Hooks API 正式投入生产了，让我能够大展身手。
这篇文章不会涉及到 React 中所有 Hooks 的细节，而是就开发而言谈谈常用的一些 Hooks，特别是最近推出的、让 redux app 能够使用 functional component 替代 connect 的 Hooks。
Before &amp;amp; After Hooks 使用 Hooks 对代码的修改不少，但是完成重构后代码看着会非常简洁，因为少了非常多的代码，我们维护一个组件只需要看一个 function 即可。
Before /** container.ts */ import { connect } from &#39;react-redux&#39; import { injectIntl } from &#39;react-intl&#39; import ComponentA from &#39;./componentA&#39; import * as actions from &#39;your/path/to/actions&#39; import { bindActionCreators, Dispatch } from &#39;redux&#39; function mapStateToProps(state: any): any { return { variableA: state.</description>
    </item>
    
    <item>
      <title>Next.js 实战：从 CSR 迁移到 SSR</title>
      <link>https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/</guid>
      <description>CSR: 客户端渲染，Client Side Rendering SSR: 服务端渲染，Server Side Rendering   TL;DR 目前正在做一个项目，由于采用了敏捷开发，所以我们的自主权比较大，领导也让我们尝试使用 SSR，所以我们自然而然在原有的 create-react-app 创建的应用的基础上选择了 Next.js。
下面大致说明一下 SSR 项目与 CSR 项目到底有什么不同。
关于浏览器与 DOM SSR 项目还是一个运行在浏览器的项目，所以是可以支持浏览器 API 的，但是它是由一个 Node.js 服务器来写入 html，而不是像 CSR 一样加载静态的 js 来渲染。这样会导致问题就是，如果在渲染时立即调用了浏览器/DOM 相关的 API，此时可能浏览器环境还未加载完成，那么就会出现 document is not defined 的错误。
关于 document is not defined，比较常遇到的情况有：
 页面调用了 document、window 相关的 API 使用了 ReactDOM.createPortal。由于 ReactDOM.createPortal 必须有一个挂载的 DOM 节点，所以在浏览器环境完成前是无法使用的，解决方法就是在 componentDidMount 之后再加载：用变量进行条件渲染，参考官方例子。 某些组件如果使用 DOM API，且在被引用时未使用 next/dynamic 进行异步加载，也可能会导致这种问题  Packages 大部分 CSR App 中关键的 packages 都可以直接在 Next.</description>
    </item>
    
    <item>
      <title>TypeScript &#43; 单元测试：从零开始的经验之谈</title>
      <link>https://elizurhz.cn/frontend/typescript-and-unit-testing-in-action/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/typescript-and-unit-testing-in-action/</guid>
      <description>TL;DR 公司和部门内部之前有在推广 TypeScript，但是由于种种原因很难投入使用，但这次我参与了一个从零开始的项目，没有技术栈限制，领导也说希望用 TypeScript 试一试。作为开发团队中唯一认真学过 TypeScript 的人（在部门进行过内部分享，写过内部博客），我们的经验其实都是很缺乏的。
另外，在这个项目中，除了 TypeScript 之外，单元测试也是我们团队首次尝试的。
同时，我的性格和开发风格也比较偏向“探索者”，所以领导也布置给我一些预研、新尝试，所以自然而然便成了一个 leader 的角色。
项目构架 我们使用 create-react-app 搭建项目，没有 eject。
而对于文件的组织，我们采用了按模块划分的方式，即各个模块集成自己的 store, reducers, actions, 展示组件, 容器组件等，并设置一个入口文件将它们都暴露给外部，外部需要引用的时候直接引用这个文件即可。
主目录结构大致如下：
├── docs // 文档 ├── e2e // E2E 测试 ├── src │ ├── App.tsx // 主页面 │ ├── index.tsx // 主入口 │ ├── common.d.ts // 全局通用类型 │ ├── components // 通用组件 │ ├── i18n // 国际化 │ ├── @types // 如果某个依赖包没有 TypeScript 支持，则在这里编写 d.ts 文件 │ ├── modules // 业务模块 │ │ ├── moduleA │ │ ├── moduleB │ │ .</description>
    </item>
    
    <item>
      <title>Canvas 手写板的实现与优化</title>
      <link>https://elizurhz.cn/frontend/canvas-writing-pad/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/canvas-writing-pad/</guid>
      <description>最近在公司接了几个项目，都和 Canvas 手绘手写有关的，有历史遗留项目，还有要从头写的新需求。之前对 Canvas 的认知比较少，只写过一个带动画的圆环百分比小组件（GitHub - ElizurHz/vue-percentage: 圆环百分比小组件），是定好数据后再把它画到 Canvas 上，而手写板是第一次接触。
本文所涉及的代码是基于 szimek/signature_pad 这个开源组件进行改造的，所以下面会对源码进行一些解析，也会讲解一些我自己对其进行改造的经验。
Canvas 相关基础知识 本文列举一些本文涉及到的必备知识和常用的 API，API 具体内容不过多赘述，详情可以在 Canvas - Web API 接口参考 | MDN 查看。
基本用法 &amp;lt;canvas&amp;gt; 是 HTML5 中的一个标签，我们可以以如下方式书写：
&amp;lt;canvas id=&amp;quot;test&amp;quot; width=&amp;quot;150&amp;quot; height=&amp;quot;150&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;  其中 width 和 height 是 canvas 的必需属性，否则无法看到绘制的内容。在初始化时我们也可以通过 document.getElementById 的方式获取 DOM 节点，并设置其 width 和 height 属性。【注意：在已经绘制过的 canvas 上重设这两个属性会导致已绘制内容被清空】
如需在 canvas 上绘制，我们需要获取它的“渲染上下文 (The rendering context)”
const test = document.getElementById(&#39;test&#39;) const ctx = test.getContext(&#39;2d&#39;)  绘制 在 Canvas 中我们定位使用的是坐标系，(0, 0) 代表的是最左上的点，可视区域最右下的点为 (width, height)。</description>
    </item>
    
    <item>
      <title>React &#43; TypeScript 从云玩家到入门</title>
      <link>https://elizurhz.cn/frontend/typescript-for-jser/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/typescript-for-jser/</guid>
      <description>React + TypeScript 从云玩家到入门 TypeScript 对我们开发最大的帮助就是类型检查，所以玩转 TypeScript 其实就是在玩转类型。而 TypeScript 本身和 Java, C# 等面向对象的语言有非常多类似的地方，有相应经验的读者能够较快地入门。本文旨在于帮助无面向对象开发经验的 JavaScript 使用者能最快速地上手并使用 TypeScript 编写 React 应用。由于篇幅和定位所限，本文将不会涉及到较为复杂的组件设计模式。
TypeScript 基础 这部分主要介绍入门 TypeScript 必须掌握的，以及 React 开发中经常会用到的一些语法规范。
基础类型  number: 数字 string: 字符串 boolean: 布尔值 Array: 数组。在使用数组类型的时候必须标记数组中的数据类型，如 number[] 或者 Array&amp;lt;string&amp;gt; Tuple: 元组。let x: [string, number]; any: 任意类型 void: 空，一般用于函数的返回值 never: 永远不会出现的类型，一般用于函数的返回值，例如抛出错误或者永远不结束的死循环。  可选类型 标记为可选类型的属性并非是必须的。
interface IObj { str?: string; num: number; } // tslint 不报错 let obj1: IObj = { num: 123 }; // tslint 报错 let obj2: IObj = { str: &amp;quot;asdf&amp;quot; };  Readonly 一般在 Interface 和 Class 中会使用。设置为 readonly 的变量、属性，一旦定义后就无法直接修改。如果在代码中有修改的操作，则 tslint 会报错。</description>
    </item>
    
    <item>
      <title>mpvue 小程序开发踩坑记</title>
      <link>https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/</guid>
      <description>mpvue 小程序开发踩坑记 之前公司决定开发一款小程序。
我接触微信小程序也就一两个月的时间，没使用过小程序官方的开发语言，而是直接使用 mpvue 上手了，自己开发了一个因为内容的原因无法上架的 DEMO。正好也被推上了前端部门的 leader，所以也就接下了这个任务。
使用 mpvue 的因为本以为由 Vue 转小程序用 mpvue 会方便，不过没想到坑挺多的，一般的 Web 开发者如果以 Vue 的思维入手会遇到很多麻烦，因为小程序的运行环境和浏览器完全不同。
另外京东凹凸实验室的 Taro 也是一个非常好的框架，不过我没有去深入研究它。考虑到公司技术栈转 Vue 的要求，我们团队选择了 mpvue，然而我个人认为 mpvue 还是个不太成熟的框架，文档不完善，在开发编译时也容易出 bug，另外就是分包加载的支持比较慢，好在最近出了新版本的 mpvue-loader。但是新版本的 mpvue-loader 完全更改了 app.json/main.json 文件的写法，文档中也没有明确提到，只能通过新的 quickstart 来了解新的写法。
我对小程序和 mpvue 的理解 mpvue  mpvue 是美团开发的，允许开发者使用 Vue 语法来编写小程序的框架。 小程序和 Web 应用的不同之处是它依靠微信 App 内的 JavaScript 引擎和 WXML/WXSS 引擎进行渲染，所以与 Web 端相比，小程序里不存在 DOM，无法使用原生 DOM 的操作，也不存在浏览器的各种 API。 在使用 mpvue 时，实际上可以看作是用 Vue 构建多页 Web App。 在 Webpack 打包时，Vue Web App 是最终打包成 index.</description>
    </item>
    
    <item>
      <title>在 React 中使用防抖动</title>
      <link>https://elizurhz.cn/frontend/react-debounce/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/react-debounce/</guid>
      <description>在 React 中使用防抖动 什么是防抖动 防抖动其实就是保证在事件发生后的固定时间内，如果再触发该事件，则重新计算延时，直到这段延时内没有再次触发事件，则执行用户自定的函数。
更进一步说，防抖动分为立即执行和非立即执行，立即执行的运作方式有所不同，它是会先执行用户自定的函数，若在一段延时内未再触发该事件，则触发该事件才能再次执行函数；在该延时内触发的事件不执行函数，且重新计算延时。
基础版 关于防抖动的详情和具体实现，网上很多文章应该都介绍过了，这里不赘述，推荐一篇看过的应该是最好的文章：函数防抖和节流 - 掘金 。不过这种代码实现比较“传统”，使用的是 ES5 和闭包。
function debounce(func, wait) { var timeout; return function () { var context = this; var args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(function(){ func.apply(context, args) }, wait); } }  如果是按照上面的 ES5 + 闭包的形式编写 debounce 函数，那么使用方法如下：
function print(value) { console.log(value) } debounce(print, 100)(&#39;123&#39;)  这也是 lodash 和 underscore 中 debounce 的实现与使用方式。
进阶版 当然，我们也可以使用 Promise 来实现防抖动，参考：理解函数防抖 Debounce - 掘金 。</description>
    </item>
    
  </channel>
</rss>