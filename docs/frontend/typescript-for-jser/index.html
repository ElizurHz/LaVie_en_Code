<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="ElizurHz">
  
  
  
  <link rel="prev" href="https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/" />
  <link rel="next" href="https://elizurhz.cn/frontend/canvas-writing-pad/" />
  <link rel="canonical" href="https://elizurhz.cn/frontend/typescript-for-jser/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           React &#43; TypeScript 从云玩家到入门 | La Vie en Code - 编码人生
       
  </title>
  <meta name="title" content="React &#43; TypeScript 从云玩家到入门 | La Vie en Code - 编码人生">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://elizurhz.cn/"
    },
    "articleSection" : "frontend",
    "name" : "React &#43; TypeScript 从云玩家到入门",
    "headline" : "React &#43; TypeScript 从云玩家到入门",
    "description" : "React + TypeScript 从云玩家到入门 TypeScript 对我们开发最大的帮助就是类型检查，所以玩转 TypeScript 其实就是在玩转类型。而 TypeScript 本身和 Java, C# 等面向对象的语言有非常多类似的地方，有相应经验的读者能够较快地入门。本文旨在于帮助无面向对象开发经验的 JavaScript 使用者能最快速地上手并使用 TypeScript 编写 React 应用。由于篇幅和定位所限，本文将不会涉及到较为复杂的组件设计模式。
TypeScript 基础 这部分主要介绍入门 TypeScript 必须掌握的，以及 React 开发中经常会用到的一些语法规范。
基础类型  number: 数字 string: 字符串 boolean: 布尔值 Array: 数组。在使用数组类型的时候必须标记数组中的数据类型，如 number[] 或者 Array&lt;string&gt; Tuple: 元组。let x: [string, number]; any: 任意类型 void: 空，一般用于函数的返回值 never: 永远不会出现的类型，一般用于函数的返回值，例如抛出错误或者永远不结束的死循环。  可选类型 标记为可选类型的属性并非是必须的。
interface IObj { str?: string; num: number; } // tslint 不报错 let obj1: IObj = { num: 123 }; // tslint 报错 let obj2: IObj = { str: &quot;asdf&quot; };  Readonly 一般在 Interface 和 Class 中会使用。设置为 readonly 的变量、属性，一旦定义后就无法直接修改。如果在代码中有修改的操作，则 tslint 会报错。",
    "inLanguage" : "zh-CN",
    "author" : "ElizurHz",
    "creator" : "ElizurHz",
    "publisher": "ElizurHz",
    "accountablePerson" : "ElizurHz",
    "copyrightHolder" : "ElizurHz",
    "copyrightYear" : "2019",
    "datePublished": "2019-03-24 00:00:00 &#43;0000 UTC",
    "dateModified" : "2019-03-24 00:00:00 &#43;0000 UTC",
    "url" : "https://elizurhz.cn/frontend/typescript-for-jser/",
    "wordCount" : "1157",
    "keywords" : [ "typescript", "La Vie en Code - 编码人生"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://elizurhz.cn/">La Vie en Code - 编码人生</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/frontend/" title="">前端</a>
                
                <a class="menu-item" href="/backend/" title="">后端</a>
                
                <a class="menu-item" href="/translation/" title="">翻译</a>
                
                <a class="menu-item" href="/ops/" title="">运维/部署</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://elizurhz.cn/">La Vie en Code - 编码人生</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/frontend/" title="">前端</a>
                
                <a class="menu-item" href="/backend/" title="">后端</a>
                
                <a class="menu-item" href="/translation/" title="">翻译</a>
                
                <a class="menu-item" href="/ops/" title="">运维/部署</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">React &#43; TypeScript 从云玩家到入门</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://elizurhz.cn/" rel="author">ElizurHz</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-03-24 itemprop="datePublished">March 24, 2019</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://elizurhz.cn/categories/%E5%89%8D%E7%AB%AF/"> 前端 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          

<h1 id="react-typescript-从云玩家到入门">React + TypeScript 从云玩家到入门</h1>

<p>TypeScript 对我们开发最大的帮助就是类型检查，所以玩转 TypeScript 其实就是在玩转类型。而 TypeScript 本身和 Java, C# 等面向对象的语言有非常多类似的地方，有相应经验的读者能够较快地入门。本文旨在于帮助无面向对象开发经验的 JavaScript 使用者能最快速地上手并使用 TypeScript 编写 React 应用。由于篇幅和定位所限，本文将不会涉及到较为复杂的组件设计模式。</p>

<h2 id="typescript-基础">TypeScript 基础</h2>

<p>这部分主要介绍入门 TypeScript 必须掌握的，以及 React 开发中经常会用到的一些语法规范。</p>

<h3 id="基础类型">基础类型</h3>

<ul>
<li>number: 数字</li>
<li>string: 字符串</li>
<li>boolean: 布尔值</li>
<li>Array: 数组。在使用数组类型的时候必须标记数组中的数据类型，如 <code>number[]</code> 或者 <code>Array&lt;string&gt;</code></li>
<li>Tuple: 元组。<code>let x: [string, number];</code></li>
<li>any: 任意类型</li>
<li>void: 空，一般用于函数的返回值</li>
<li>never: 永远不会出现的类型，一般用于函数的返回值，例如抛出错误或者永远不结束的死循环。</li>
</ul>

<h3 id="可选类型">可选类型</h3>

<p>标记为可选类型的属性并非是必须的。</p>

<pre><code class="language-typescript">interface IObj {
  str?: string;
  num: number;
}

// tslint 不报错
let obj1: IObj = {
  num: 123
};

// tslint 报错
let obj2: IObj = {
  str: &quot;asdf&quot;
};
</code></pre>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/typescript-for-jser/optional-error.png" alt="optional-error" class="lazyload"><figcaption class="image-caption">optional-error</figcaption></figure></p>

<h3 id="readonly">Readonly</h3>

<p>一般在 Interface 和 Class 中会使用。设置为 <code>readonly</code> 的变量、属性，一旦定义后就无法直接修改。如果在代码中有修改的操作，则 tslint 会报错。</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/typescript-for-jser/readonly-error.png" alt="readonly-error" class="lazyload"><figcaption class="image-caption">readonly-error</figcaption></figure></p>

<h3 id="函数">函数</h3>

<pre><code class="language-typescript">function add(x: number, y: number): number {
  return x + y;
}

let myAdd: (x: number, y: number) =&gt; number = function(
  x: number,
  y: number
): number {
  return x + y;
};
</code></pre>

<p>函数的类型限制主要在参数和返回值的位置需要定义。如果在等号左侧已经定义了类型，那么右侧可以不需要写类型，如：</p>

<pre><code class="language-typescript">let myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) {
  return x + y;
};
</code></pre>

<p>这个在 TypeScript 中被称作 “contextual typing”。</p>

<h2 id="interface">interface</h2>

<blockquote>
<p>One of TypeScript’s core principles is that type-checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural subtyping”.</p>
</blockquote>

<p>Interface 一般用于描述一个较为复杂的限制，例如在一个对象中限制某些属性的类型。有时被称为“鸭子类型”。</p>

<blockquote>
<p>&ldquo;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&rdquo;
在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</p>
</blockquote>

<pre><code class="language-typescript">interface ITest {
  a: number;
  b: string;
}

const test: ITest = {
  a: 1,
  b: &quot;123&quot;
};
</code></pre>

<ul>
<li><p>Interface 和 class 的区别:</p>

<ul>
<li>Interface 和 class 在 TypeScript 中都可以去描述一个限制，与 PHP、Java 中的 interface、class 一样，TypeScript 中的 interface 只做声明不做实现。</li>
<li>如果把上面的 interface 声明换成 class，tslint 不会报错，代码可以正常执行，但是二者编译出来的 JavaScript 不同。</li>
</ul></li>
</ul>

<pre><code class="language-typescript">// 使用 interface 编译后的代码
var test = {
  a: 1,
  b: &quot;123&quot;
};

// 使用 class 编译后的代码
var ITest = /** @class */ (function() {
  function ITest() {}
  return ITest;
})();
var test = {
  a: 1,
  b: &quot;123&quot;
};
</code></pre>

<ul>
<li>class 可以使用 implements 关键字来实现 interface。</li>
</ul>

<h3 id="类型别名">类型别名</h3>

<p>TypeScript 中允许使用 type 关键字来声明类型别名。</p>

<pre><code class="language-typescript">type State = {
  a: string;
  b: Array&lt;number&gt;;
};
</code></pre>

<p>类型别名和 interface 通常具有同样的功能，但是类型别名不能被 <code>extends</code> 或者 <code>implements</code>，也不能 <code>extends</code> 或者 <code>implements</code> 其他类型。并且类型别名在编译器中显示的是 Object 字面量类型，而 interface 显示是 interface。</p>

<blockquote>
<p>Because <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">an ideal property of software is being open to extension</a>, you should always use an interface over a type alias if possible.
【软件中的对象应该对于扩展是开放的，但是对于修改是封闭的】</p>
</blockquote>

<h3 id="泛型">泛型</h3>

<pre><code class="language-typescript">function identity(arg: any): any {
  return arg;
}
</code></pre>

<p>当我们在写这样一个函数的时候，参数和返回值都可以是任意类型，但实际上这样我们就丢失了参数和返回值的类型信息（实际上输入和输出应该是相同的类型）。
这时我们可以用一个类型变量 T：</p>

<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg;
}
</code></pre>

<p>这样保证了参数和返回值的类型都是 T。
我们可以通过如下的方式使用这个泛型函数：</p>

<pre><code class="language-typescript">let output = identity&lt;string&gt;(&quot;myString&quot;); // type of output will be 'string'
</code></pre>

<h3 id="映射类型">映射类型</h3>

<p>映射类型包括 Partial 和 Readonly，它们可以在原有 interface 的基础上分别映射出所有属性都是可选类型，和所有属性都是只读的新的 type。这两种映射类型实现如下：</p>

<pre><code class="language-typescript">type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P] };
type Partial&lt;T&gt; = { [P in keyof T]?: T[P] };
</code></pre>

<h2 id="在-react-中使用-typescript">在 React 中使用 TypeScript</h2>

<h3 id="创建一个-react-typescript-的项目">创建一个 React + TypeScript 的项目</h3>

<ol>
<li>create-react-app
通过 create-react-app 来搭建，我们只需要在命令中加入额外参数即可：
<code>create-react-app my-app --scripts-version=react-scripts-ts</code>
搭建出来的项目结构与 JavaScript 版本基本相同，区别在于根目录有<code>tsconfig.json</code>、<code>tslint.json</code> 等 TypeScript 相关的文件。<code>tsconfig.json</code> 用于告诉 <code>ts-loader</code> 如何编译 .ts 文件，而 <code>tslint.json</code> 则是 tslint (TypeScript 语法检查器) 的配置。</li>
<li>手动安装
手动安装需要通过 npm 或者 yarn 安装 <code>typescript</code> 和 <code>ts-loader</code> 等 TypeScript 相关的 package，同时需要手动配置 <code>tsconfig.json</code>。</li>
</ol>

<h3 id="definitelytyped-d-ts">DefinitelyTyped - *.d.ts</h3>

<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">GitHub - DefinitelyTyped/DefinitelyTyped: The repository for high quality TypeScript type definitions.</a></p>

<p>TypeScript 的模块发布的时候都是打包成 JavaScript 来发布的，但是这样会丢失定义好的数据类型。 .d.ts 可以约定 type, class, interface, function, 变量以及常量等的行为，相当于是一个 package 或者 library 的“说明书”。</p>

<p>在 React 中，我们常常会需要安装一些如 <code>@types/react-router-dom</code> 这种以 <code>@types</code> 作为开头的 package。在 JS 中我们直接 <code>npm install react-router-dom</code> 即可，但是在 TypeScript 中，如果没有 DefinitelyTyped，将会报如下的错误：
<figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/typescript-for-jser/types-error.png" alt="@types-error" class="lazyload"><figcaption class="image-caption">@types-error</figcaption></figure></p>

<p>当然并不是所有的 package 都需要一个对应的 <code>@types</code> ，不少 package 自身已经有 .d.ts 文件了，例如 antd，所以我们不需要额外的 <code>@types</code> 。</p>

<h3 id="无状态组件">无状态组件</h3>

<p>在 JavaScript 中，我们可以按如下的方式写一个 Stateless Functional Component ：</p>

<pre><code class="language-javascript">import React from &quot;react&quot;;
const Button = ({ onClick, children }) =&gt; (
  &lt;button onClick={handleClick}&gt;{children}&lt;/button&gt;
);
</code></pre>

<p>但是在 TypeScript 中，我们需要加入类型，所以具体怎么加呢？我们可以通过 <code>@types/react</code> 中的 <code>index.d.ts</code>来进行分析：</p>

<blockquote>
<p>注：以下代码都去除了大段的注释，若需要查看官方的注释请至 <code>npm install</code> 后下载的 <code>./node_modules/@types/react</code> 中查看。</p>
</blockquote>

<pre><code class="language-typescript">type SFC&lt;P = {}&gt; = StatelessComponent&lt;P&gt;;
interface StatelessComponent&lt;P = {}&gt; {
  (props: P &amp; { children?: ReactNode }, context?: any): ReactElement&lt;
    any
  &gt; | null;
  propTypes?: ValidationMap&lt;P&gt;;
  contextTypes?: ValidationMap&lt;any&gt;;
  defaultProps?: Partial&lt;P&gt;;
  displayName?: string;
}
</code></pre>

<p>从这段代码中可以看出，props 是 P 和 一个对象的联合类型，P 指的是我们通常传入的 props，而对象中的 children 就是 React 中的 children，是可选类型，type 是 ReactNode，是 React 中的类型。另外在 React 的 <code>index.d.ts</code>中，对于事件有专门的类型定义 <code>MouseEvent</code>（同时也有其他 Event 的类型定义）：</p>

<pre><code class="language-typescript">interface MouseEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T&gt; {
  altKey: boolean;
  button: number;
  buttons: number;
  clientX: number;
  clientY: number;
  ctrlKey: boolean;
  getModifierState(key: string): boolean;
  metaKey: boolean;
  nativeEvent: NativeMouseEvent;
  pageX: number;
  pageY: number;
  relatedTarget: EventTarget;
  screenX: number;
  screenY: number;
  shiftKey: boolean;
}
</code></pre>

<p>所以针对上面的 JavaScript 代码，我们可以按如下的方式写出相应的 TypeScript 代码：</p>

<pre><code class="language-typescript">import React, { MouseEvent, ReactNode } from &quot;react&quot;;
interface IProps {
  onClick(e: MouseEvent&lt;HTMLElement&gt;): void;
  children?: ReactNode;
}
const Button = ({ onClick: handleClick, children }: IProps) =&gt; (
  &lt;button onClick={handleClick}&gt;{children}&lt;/button&gt;
);
</code></pre>

<p>其中 <code>HTMLElement</code> 被定义在<code>@types/react</code> 中的<code>global.d.ts</code></p>

<pre><code class="language-typescript">interface Element {}
interface HTMLElement extends Element {}
</code></pre>

<h3 id="有状态组件">有状态组件</h3>

<p>无状态组件其实是一个函数，只需要按照函数的写法来实现即可。而对于有状态组件，这边有一个计数器的例子：</p>

<pre><code class="language-typescript">import React, { Component } from &quot;react&quot;;

import Button from &quot;./Button&quot;; // 这里的 Button 是上面 SFC 部分的 Button 组件

const initialState = { clicksCount: 0 };
type State = Readonly&lt;typeof initialState&gt;;

class ButtonCounter extends Component&lt;object, State&gt; {
  readonly state: State = initialState;

  public render() {
    const { clicksCount } = this.state;
    return (
      &lt;&gt;
        &lt;Button onClick={this.handleIncrement}&gt;Increment&lt;/Button&gt;
        &lt;Button onClick={this.handleDecrement}&gt;Decrement&lt;/Button&gt;
        You've clicked me {clicksCount} times!
      &lt;/&gt;
    );
  }

  private handleIncrement = () =&gt; this.setState(incrementClicksCount);
  private handleDecrement = () =&gt; this.setState(decrementClicksCount);
}

const incrementClicksCount = (prevState: State) =&gt; ({
  clicksCount: prevState.clicksCount + 1
});
const decrementClicksCount = (prevState: State) =&gt; ({
  clicksCount: prevState.clicksCount - 1
});
</code></pre>

<p>若要读懂这段代码，可以从<code>@types/react</code> 中的 <code>index.d.ts</code>说起：</p>

<blockquote>
<p>注：以下代码都去除了大段的注释，若需要查看官方的注释请至 <code>npm install</code> 后下载的 <code>./node_modules/@types/react</code> 中查看。</p>
</blockquote>

<pre><code class="language-typescript">interface Component&lt;P = {}, S = {}, SS = any&gt;
  extends ComponentLifecycle&lt;P, S, SS&gt; {}

class PureComponent&lt;P = {}, S = {}, SS = any&gt; extends Component&lt;P, S, SS&gt; {}

class Component&lt;P, S&gt; {
  constructor(props: Readonly&lt;P&gt;);
  setState&lt;K extends keyof S&gt;(
    state:
      | ((prevState: Readonly&lt;S&gt;, props: Readonly&lt;P&gt;) =&gt; Pick&lt;S, K&gt; | S | null)
      | (Pick&lt;S, K&gt; | S | null),
    callback?: () =&gt; void
  ): void;

  forceUpdate(callBack?: () =&gt; void): void;
  render(): ReactNode;
  readonly props: Readonly&lt;{ children?: ReactNode }&gt; &amp; Readonly&lt;P&gt;;
  state: Readonly&lt;S&gt;;
  context: any;
  refs: {
    [key: string]: ReactInstance;
  };
}
</code></pre>

<p>我们常用的 Component 类就是在这里被定义的，其中 P 代表 props，S 代表 state。在这里我们可以发现，props 和 state 都使用了 readonly 或者是使用了 Mapped types 中的 Readonly。
而 Component 的 Interface 继承了 ComponentLifecycle 的 Interface，源码如下：</p>

<pre><code class="language-typescript">interface &lt;P, S, SS = any&gt; extends NewLifecycle&lt;P, S, SS&gt;, DeprecatedLifecycle&lt;P, S&gt; {
	componentDidMount?(): void;
	shouldComponentUpdate?(nextProps: Readonly&lt;P&gt;, nextState: Readonly&lt;S&gt;, nextContext: any): boolean;
	componentWillUnmount?(): void;
	componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
}
</code></pre>

<p>ComponentLifecycle 的 Interface 定义了一些常用的生命周期函数的类型如 componentDidMount、shouldComponentUpdate、componentWillUnmount 和 componentDidCatch。ComponentLifecycle 同样继承了 NewLifecycle 和 DeprecatedLifecycle 两个接口，代码分别如下：</p>

<pre><code class="language-typescript">interface NewLifecycle&lt;P, S, SS&gt; {
  getSnapshotBeforeUpdate?(
    prevProps: Readonly&lt;P&gt;,
    prevState: Readonly&lt;S&gt;
  ): SS | null;
  componentDidUpdate?(
    prevProps: Readonly&lt;P&gt;,
    prevState: Readonly&lt;S&gt;,
    snapshot?: SS
  ): void;
}

interface DeprecatedLifecycle&lt;P, S&gt; {
  componentWillMount?(): void;
  UNSAFE_componentWillMount?(): void;
  componentWillReceiveProps?(nextProps: Readonly&lt;P&gt;, nextContext: any): void;
  UNSAFE_componentWillReceiveProps?(
    nextProps: Readonly&lt;P&gt;,
    nextContext: any
  ): void;
  componentWillUpdate?(
    nextProps: Readonly&lt;P&gt;,
    nextState: Readonly&lt;S&gt;,
    nextContext: any
  ): void;
  UNSAFE_componentWillUpdate?(
    nextProps: Readonly&lt;P&gt;,
    nextState: Readonly&lt;S&gt;,
    nextContext: any
  ): void;
}
</code></pre>

<p>NewLifecycle 是 React 16.3 新增的生命周期钩子，而 DeprecatedLifecycle 则是 React 16.3 之前常用的生命周期钩子，即将在未来版本被废弃。</p>

<p>所以通过以上分析，我们可以知道，React 的 Class 继承于 <code>class Component&lt;P, S&gt;</code>，而 <code>class Component&lt;P, S&gt;</code> 是泛型 <code>interface Component&lt;P = {}, S = {}, SS = any&gt;</code> 的实现。其中 P 是 props 的类型，S 是 state 的类型，它们都是 object 类型。</p>

<p><strong>因此，TypeScript 的有状态组件大致可以按以下步骤来编写或者阅读：</strong></p>

<ul>
<li>设置 initialState，并根据 initialState 来设定 State 类型或者 State 的 interface：</li>
</ul>

<pre><code class="language-typescript">const initialState = { clicksCount: 0 };
type State = Readonly&lt;typeof initialState&gt;;
</code></pre>

<ul>
<li>使用 type 或者 interface 设定 props 类型</li>
<li><code>class Example extends Component&lt;P, S&gt;</code> 这里需要指定 props 和 state 的类型 P 和 S</li>
<li><code>readonly state: State = initialState;</code> 这里建议将 state 设置为 readonly 类型，防止 state 被直接修改</li>
<li>生命周期方法可以使用 public 来修饰（tslint 要求 class 内部方法必须加入 public 或者 private 来修饰）</li>
<li>内部方法可以使用 private 来修饰以保护其安全性</li>
</ul>

<h2 id="小-tips">小 Tips</h2>

<ol>
<li>从上面的 d.ts 文件的分析可以得知， <code>setState()</code> 的具体逻辑是可以被提取到组件外部的，这样做的优点是可以将操作 state 的方法剥离出来维护，不需要了解渲染逻辑。</li>
<li>在使用 mock 数据调试组件的时候，我们可以多用 any 类型来节约 React 组件调试时间成本，直至数据结构完全确定后，再编写完整的数据验证流程</li>
<li>如果你想使用一个 package 但是遇到了找不到 @types 相关 package 的报错，可以到 Microsoft 的 <a href="https://microsoft.github.io/TypeSearch/">TypeScript Types Search</a> 查询需要 <code>npm install</code> 什么 package</li>
</ol>

<h2 id="reference">Reference</h2>

<h3 id="typescript-官方文档">TypeScript 官方文档</h3>

<ul>
<li><a href="https://www.typescriptlang.org/">英文版</a></li>
<li><a href="https://www.tslang.cn/">中文版</a></li>
</ul>

<h3 id="ultimate-react-component-patterns-with-typescript-2-8">Ultimate React Component Patterns with Typescript 2.8</h3>

<ul>
<li><a href="https://levelup.gitconnected.com/ultimate-react-component-patterns-with-typescript-2-8-82990c516935">英文原版</a></li>
<li><a href="https://juejin.im/post/5b07caf16fb9a07aa83f2977">蚂蚁金服技术团队翻译版</a></li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>ElizurHz </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://elizurhz.cn/frontend/typescript-for-jser/>https://elizurhz.cn/frontend/typescript-for-jser/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://elizurhz.cn/tags/typescript/">
                    #typescript</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://elizurhz.cn/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/" class="prev" rel="prev" title="mpvue 小程序开发踩坑记"><i class="iconfont icon-left"></i>&nbsp;mpvue 小程序开发踩坑记</a>
         
        
        <a href="https://elizurhz.cn/frontend/canvas-writing-pad/" class="next" rel="next" title="Canvas 手写板的实现与优化">Canvas 手写板的实现与优化&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://elizurhz.cn/">ElizurHz</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
