<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>La Vie en Code - 编码人生 on La Vie en Code - 编码人生</title>
    <link>https://elizurhz.cn/</link>
    <description>Recent content in La Vie en Code - 编码人生 on La Vie en Code - 编码人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 18 Jul 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Amazon AWS Serverless 部署 React 项目</title>
      <link>https://elizurhz.cn/ops/aws-serverless-deployment/</link>
      <pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/ops/aws-serverless-deployment/</guid>
      <description>

&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;

&lt;h2 id=&#34;为什么使用-serverless&#34;&gt;为什么使用 Serverless&lt;/h2&gt;

&lt;p&gt;因为它是按量(请求数)付费的，相比于 EC 或者容器的按时间付费会节省很多成本，并且 EC 往往会遇到带宽限制的问题，增加带宽会提高很多成本。&lt;/p&gt;

&lt;h2 id=&#34;prerequisite&#34;&gt;Prerequisite&lt;/h2&gt;

&lt;p&gt;如果要使用 Amazon AWS Serverless 来部署 React 项目，我们需要一个叫做 &lt;code&gt;serverless&lt;/code&gt; 的 npm package。同时我们还需要在项目下编写 &lt;code&gt;serverless.yml&lt;/code&gt;。具体的写法可以参考 &lt;code&gt;serverless&lt;/code&gt; 的&lt;a href=&#34;https://serverless.com/&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;csr-create-react-app&#34;&gt;CSR(create-react-app)&lt;/h1&gt;

&lt;p&gt;客户端渲染，也就是我们最常用的 create-react-app 搭出来的项目，使用 Serverless 的方式部署到 AWS 其实很简单。要让我们的部署能够运行起来，在 AWS 上我们只需要一个服务：S3。S3 有一个静态页面托管的服务，并且会自动生成一个可访问的地址。这个静态站点可以运行我们打包好的 web app。&lt;/p&gt;

&lt;h2 id=&#34;手动部署&#34;&gt;手动部署&lt;/h2&gt;

&lt;p&gt;首先只要在 AWS S3 的控制面板里创建存储桶就可以了，配置可以都用默认配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其次，我们需要进入已经建好的存储桶，把静态网站托管打开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着我们需要注意，一定要把 error.html 指向 index.html。因为我们可能在项目中使用 react-router，而在 S3 的静态文件托管中，任何子路径都会被认为是 error，因为我们使用 create-react-app 创建的项目，入口文件只有一个 index.html，而不是有其他 html 文件的多页面应用。只有把错误页面指向 index.html，才能正常使用 react-router。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里会显示该存储桶的访问地址，通过这个地址就可以访问了。接着我们在存储桶的“概述”标签页上传我们打包好的文件（index.html 需要在存储桶的根目录），这样我们的站点就可以访问了。&lt;/p&gt;

&lt;p&gt;如果需要 https，我们可以在 CloudFront 上创建一个域名，把源指向我们的 S3 bucket 就可以了。这个过程无需我们申请任何的证书。&lt;/p&gt;

&lt;h2 id=&#34;serverless-命令行部署&#34;&gt;serverless 命令行部署&lt;/h2&gt;

&lt;p&gt;首先我们需要安装 serverless：运行 &lt;code&gt;yarn add --global serverless&lt;/code&gt;(如果你安装了 yarn) 或者 &lt;code&gt;npm install -g serverless&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;serverless 这个 npm package 可以使用插件来辅助进行部署。这里推荐使用 &lt;code&gt;serverless-finch&lt;/code&gt; 进行部署。我们需要编写一个 &lt;code&gt;serverless.yml&lt;/code&gt; 文件，serverless 包会读取这个文件的配置进行部署。参考配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;service: your-app-name

frameworkVersion: &amp;quot;=1.38.0&amp;quot;

# AWS 的配置
provider:
  name: aws
  runtime: nodejs6.10
  stage: dev
  region: us-east-2
  profile: default

plugins:
  - serverless-finch

# 以下为 serverless-finch 的配置
custom:
  client:
    bucketName: your-bucket-name # 需要和 S3 上创建的 bucket 同名
    distributionFolder: build # 本地打包的输出目录
    indexDocument: index.html # 同 S3 上静态文件托管中设置的入口文档
    errorDocument: index.html # 同 S3 上静态文件托管中设置的错误文档
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们需要在 AWS Console 的 IAM 上创建一个能读写 S3 的角色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进入 IAM 的控制台，左侧菜单选择“用户”，然后添加用户。接着填写用户名，并且需要勾选“编程访问”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着要给创建的用户附加权限，这边推荐可以选择 AmazonS3FullAccess。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成创建之后，这里会出现 ID 和密钥，接着我们需要用它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;serverless config credentials --provider aws --key [YOUR_KEY] --secret [YOUR_SECRET]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 key 填写 ID，secret 填写密钥。这一步是设置我们 serverless 的当前用户权限。&lt;strong&gt;注意如果需要切换用户，需要用 AWS CLI 来切换，实测 serverless 中覆盖掉 credentials 的配置并不会生效。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样我们就完成了配置。需要部署的时候，我们只需要打包好文件，然后运行 &lt;code&gt;serverless client deploy&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h1 id=&#34;ssr-next-js&#34;&gt;SSR(Next.js)&lt;/h1&gt;

&lt;p&gt;由于篇幅限制，并且我个人踩坑踩了好几个星期，很多细节没法回忆起来或者无法详细说明。并且作为前端开发者，我们其实并不需要了解整个 AWS Serverless 的工作原理，我们只需要配合后端/运维人员把我们代码层面需要做的做好即可。所以这里只提供一个大概的方案。&lt;/p&gt;

&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;

&lt;p&gt;与 CSR App 不同的是，SSR App 部署完成后并不能直接访问静态页面，而是要通过 API Gateway 去访问（地址会在部署完之后显示在命令行，或者可以在 AWS 的 API Gateway 控制台查看）。当我们访问 API Gateway 时，API Gateway 会解析相应的请求（也就是路由），并转发至 AWS Lambda。而 AWS Lambda 则会根据我们写好的 Lambda 函数（&lt;code&gt;./server/lambda.js&lt;/code&gt;）来访问 S3 上存储的对应的静态文件。&lt;/p&gt;

&lt;p&gt;当然我们也可以设置自定义的域名，但是最好是在 Route53 申请，这样才能享受到 AWS 的一系列服务（全家桶）。&lt;/p&gt;

&lt;h2 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h2&gt;

&lt;p&gt;API Gateway 有几个基本概念/配置项。&lt;/p&gt;

&lt;p&gt;首先是 stage，它代表的是不同的阶段，例如开发环境、测试环境、生产环境等等。在 API Gateway 的访问域名中会有一个 &lt;code&gt;/{stage}&lt;/code&gt; 的路径。&lt;/p&gt;

&lt;p&gt;其次是&amp;rdquo;资源&amp;rdquo;，这里就是配置 API 访问的了。我们只需要设置一个通用的访问如 &lt;code&gt;/{proxy+}&lt;/code&gt; 即可，因为我们有许多路由，不可能每个都配置到这里来，而不可访问的路由最好使用 Next.js 中的 &lt;code&gt;_error.js&lt;/code&gt; 来做，而不是在这里限制。&lt;/p&gt;

&lt;h2 id=&#34;serverless&#34;&gt;serverless&lt;/h2&gt;

&lt;p&gt;这里会使用到一些不同的插件，原来的 serverless-finch 将不再使用，因为它是设置静态文件托管的。这里使用到了两个：&lt;code&gt;serverless-apigw-binary&lt;/code&gt; 和 &lt;code&gt;serverless-domain-manager&lt;/code&gt;。&lt;code&gt;serverless-apigw-binary&lt;/code&gt; 是用于配置 API Gateway 的，而 &lt;code&gt;serverless-domain-manager&lt;/code&gt; 可以把自定义域名到 S3 bucket 的整个流程的配置都配置好。由于涉及到机密问题，这里就不把 &lt;code&gt;serverless.yml&lt;/code&gt; 放出来了，具体可以去搜索一下这两个包的使用方式。&lt;/p&gt;

&lt;h2 id=&#34;lambda&#34;&gt;Lambda&lt;/h2&gt;

&lt;p&gt;Lambda 其实就是一个压缩文件，里面是各种函数包。它实际上有点类似于一个小型的虚拟机，所以 Next.js 中每个页面打包出来都有 5.9MB。AWS 上的 Lambda 平台会做一个从 API Gateway 到我们上传的函数包中对应的文件的映射，这样就实现了路由功能。&lt;/p&gt;

&lt;p&gt;Lambda 在 SSR(Next.js) 中其实就是那个进行渲染和路由导航的 Node.js 服务。而实际上它就是一个 Node 服务器，可以用任意的 Node 框架来写。这里我使用的是 Express。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const express = require(&amp;quot;express&amp;quot;);
const routes = require(&amp;quot;./routes&amp;quot;); // next-routes 做的自定义路由

const app = express();

// host the static files
app.use(&amp;quot;/_next/static&amp;quot;, express.static(path.join(__dirname, &amp;quot;/static&amp;quot;)));
app.use(&amp;quot;/static&amp;quot;, express.static(&amp;quot;static&amp;quot;));

app.get(&amp;quot;*&amp;quot;, (req, res) =&amp;gt; {
  const parsedUrl = parse(req.url, true);
  const { pathname, query, search } = parsedUrl;

  // Map url to page directory
  const matchRoute = routes.match(pathname);
  if (matchRoute &amp;amp;&amp;amp; matchRoute.route) {
    const page = matchRoute.route.page;
    const params = matchRoute.params;

    if (params) {
      if (search) {
        req.url += &amp;quot;&amp;amp;&amp;quot; + querystring.stringify(params);
      } else {
        req.url += &amp;quot;?&amp;quot; + querystring.stringify(params);
      }

      try {
        __non_webpack_require__(`./serverless/pages${page}`).render(
          req,
          res,
          parsedUrl,
          Object.assign(params, query)
        );
      } catch (err) {
        __non_webpack_require__(&amp;quot;./serverless/pages/_error&amp;quot;).render(
          req,
          res,
          parsedUrl,
          Object.assign(params, query)
        );
      }
    } else {
      try {
        __non_webpack_require__(`./serverless/pages${page}`).render(
          req,
          res,
          parsedUrl
        );
      } catch (err) {
        __non_webpack_require__(&amp;quot;./serverless/pages/_error&amp;quot;).render(
          req,
          res,
          parsedUrl
        );
      }
    }
  } else {
    __non_webpack_require__(&amp;quot;./serverless/pages/_error&amp;quot;).render(
      req,
      res,
      parsedUrl
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边实际上就是在做路由的映射，然后载入 Next.js 打包出来对应的页面入口，接着就可以使用 React 的能力进行渲染。关于 Next.js，可以参考我的另一篇博文：&lt;a href=&#34;https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/&#34;&gt;Next.js 实战：从 CSR 迁移到 SSR&lt;/a&gt;。但是在实际生产中，这个文件是需要被编译成 ES5 的。所以我们还需要写一个 Webpack 配置来打包它，只需要在根目录建一个 &lt;code&gt;webpack.config.js&lt;/code&gt; 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// webpack.config.js
const path = require(&amp;quot;path&amp;quot;);
const CopyWebpackPlugin = require(&amp;quot;copy-webpack-plugin&amp;quot;);

const LAMBDA_FILE_LOC = path.join(__dirname, &amp;quot;./server/lambda.js&amp;quot;);
const LAMBDA_DIR = path.join(__dirname, &amp;quot;./build&amp;quot;);
const LAMBDA_FILE_PROD = &amp;quot;./lambda_prod.js&amp;quot;;

const plugins = [
  new CopyWebpackPlugin([
    // your custom config
  ])
];

// 打包配置
module.exports = {
  entry: LAMBDA_FILE_LOC,
  externals: [&amp;quot;aws-sdk&amp;quot;], // 设置成 AWS Lambda 支持的格式
  output: {
    libraryTarget: &amp;quot;commonjs&amp;quot;,
    filename: LAMBDA_FILE_PROD,
    path: LAMBDA_DIR
  },
  target: &amp;quot;node&amp;quot;,
  node: {
    __filename: false,
    __dirname: false
  },
  mode: &amp;quot;production&amp;quot;,
  plugins
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 &lt;code&gt;npx webpack&lt;/code&gt; 即可进行打包。使用 &lt;code&gt;CopyWebpackPlugin&lt;/code&gt; 的原因主要是，我们会遇到一些文件无法被 Next.js 打包，但是它们又是 Web App 运行必需的，或者是 AWS Lambda 的函数包需要的。所以我们只能手动把它们拷贝到 Next.js 的 build 目录，因为 serverless 会根据这个目录来打包出 AWS Lambda 所需的函数包。&lt;/p&gt;

&lt;h2 id=&#34;部署流程&#34;&gt;部署流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先会先运行 &lt;code&gt;next build&lt;/code&gt;，将文件打包至 &lt;code&gt;./build&lt;/code&gt; 目录。由于在 &lt;code&gt;next.config.js&lt;/code&gt; 中设置了 &lt;code&gt;target: &#39;serverless&#39;&lt;/code&gt;，所以打包出来的文件是 serverless 的版本，会与云主机、容器部署的版本不同。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译 &lt;code&gt;./server/lambda.js&lt;/code&gt;. 并在 &lt;code&gt;./build&lt;/code&gt; 目录下生成 &lt;code&gt;lambda_prod.js&lt;/code&gt;。这一步主要是要把 ES6 写的 lambda 函数编译成 ES5，这样 AWS Lambda 才能正常访问它。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将所需文件打包成 &lt;code&gt;.zip&lt;/code&gt;。压缩文件会在 &lt;code&gt;./.serverless&lt;/code&gt; 目录下生成。 需要打包的内容可以在 &lt;code&gt;serverless.yml&lt;/code&gt; 的如下字段中设置：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package:
  exclude:
    - ./**
  include:
    - build/**
    - static/**
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;上传压缩文件至 S3，同时会自动修改 API Gateway 和 AWS Lambda 的相应设置。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Next.js 实战：从 CSR 迁移到 SSR</title>
      <link>https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/</guid>
      <description>

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CSR: 客户端渲染，Client Side Rendering&lt;/li&gt;
&lt;li&gt;SSR: 服务端渲染，Server Side Rendering&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;目前正在做一个项目，由于采用了敏捷开发，所以我们的自主权比较大，领导也让我们尝试使用 SSR，所以我们自然而然在原有的 create-react-app 创建的应用的基础上选择了 Next.js。&lt;/p&gt;

&lt;p&gt;下面大致说明一下 SSR 项目与 CSR 项目到底有什么不同。&lt;/p&gt;

&lt;h2 id=&#34;关于浏览器与-dom&#34;&gt;关于浏览器与 DOM&lt;/h2&gt;

&lt;p&gt;SSR 项目还是一个运行在浏览器的项目，所以是可以支持浏览器 API 的，但是它是由一个 Node.js 服务器来写入 html，而不是像 CSR 一样加载静态的 js 来渲染。这样会导致问题就是，如果在渲染时立即调用了浏览器/DOM 相关的 API，此时可能浏览器环境还未加载完成，那么就会出现 &lt;code&gt;document is not defined&lt;/code&gt; 的错误。&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;document is not defined&lt;/code&gt;，比较常遇到的情况有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面调用了 document、window 相关的 API&lt;/li&gt;
&lt;li&gt;使用了 ReactDOM.createPortal。由于 ReactDOM.createPortal 必须有一个挂载的 DOM 节点，所以在浏览器环境完成前是无法使用的，解决方法就是在 &lt;code&gt;componentDidMount&lt;/code&gt; 之后再加载：用变量进行条件渲染，参考&lt;a href=&#34;https://github.com/zeit/next.js/tree/canary/examples/with-portals&#34;&gt;官方例子&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;某些组件如果使用 DOM API，且在被引用时未使用 &lt;code&gt;next/dynamic&lt;/code&gt; 进行异步加载，也可能会导致这种问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;packages&#34;&gt;Packages&lt;/h2&gt;

&lt;p&gt;大部分 CSR App 中关键的 packages 都可以直接在 Next.js 中使用，例如 redux, redux-saga, react-intl 等，但是使用的方式和在 CSR App 中的有所区别。另外，Next.js 中需要使用 &lt;code&gt;@zeit&lt;/code&gt; 的一些 packages，它们与 SSR 相关。&lt;/p&gt;

&lt;h2 id=&#34;next-config-js&#34;&gt;next.config.js&lt;/h2&gt;

&lt;p&gt;这个是放在根目录的 next 的配置文件，我们在这里可以配置一些 webpack loaders 的支持，例如 CSS（如果不配置就只能支持行内和 styled-jsx）, SASS, TypeScript 等，需要安装一些 &lt;code&gt;@zeit&lt;/code&gt; 的 plugins。&lt;/p&gt;

&lt;p&gt;根据项目需求，我做了如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const withTypescript = require(&amp;quot;@zeit/next-typescript&amp;quot;);
const withCSS = require(&amp;quot;@zeit/next-css&amp;quot;);
const withSass = require(&amp;quot;@zeit/next-sass&amp;quot;);

module.exports = withSass(withCSS(withTypescript()));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;样式&#34;&gt;样式&lt;/h3&gt;

&lt;p&gt;在 Next.js 中，样式默认使用的是 React 的 inline style 或者 Next.js 的 styled-jsx，它们只能写在组件文件中。如果需要使用独立的 css 文件或者其他 css 预处理器，那么需要安装相关的&lt;a href=&#34;https://nextjs.org/docs/#importing-css--sass--less--stylus-files&#34;&gt;插件&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;就如上面代码所示，插件安装完之后需要在 &lt;code&gt;next.config.js&lt;/code&gt; 中进行配置。&lt;/p&gt;

&lt;h3 id=&#34;typescript&#34;&gt;TypeScript&lt;/h3&gt;

&lt;p&gt;Next.js 官方有 TypeScript 支持，需要安装 &lt;code&gt;@zeit/next-typescript&lt;/code&gt; 这个插件，并配置 &lt;code&gt;tsconfig.json&lt;/code&gt; 和 &lt;code&gt;next.config.js&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;server-js&#34;&gt;server.js&lt;/h2&gt;

&lt;p&gt;这是 SSR 和 CSR 最大的不同 —— 我们需要一个 Node.js 服务器。在 &lt;code&gt;package.json&lt;/code&gt; 中，默认的 &lt;code&gt;scripts&lt;/code&gt; 会运行 &lt;code&gt;next&lt;/code&gt; 这个命令，启动的是 Next.js 内置的 SSR 服务器，而如果我们写一个 Node.js 服务器，并在 &lt;code&gt;scripts&lt;/code&gt; 中运行它，同样可以实现 SSR 的功能，并且我们还可以在里面定制路由、渲染方式、缓存等等。&lt;/p&gt;

&lt;h3 id=&#34;路由&#34;&gt;路由&lt;/h3&gt;

&lt;p&gt;在 Next.js 中，我们使用 Node.js 框架（Koa）的路由，所以 &lt;code&gt;react-router&lt;/code&gt; 相关的代码都必须更改。详情可以参考&lt;a href=&#34;https://nextjs.org/docs/#routing&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;react-router&lt;/code&gt; 的 history 无法在 Next.js 中使用，我们可以使用 &lt;code&gt;next/router&lt;/code&gt; 替代之（&lt;code&gt;import Router from &#39;next/router&#39;&lt;/code&gt;）。例如 &lt;code&gt;history.push()&lt;/code&gt; 可以用 &lt;code&gt;Router.push()&lt;/code&gt; 替代；也可以 &lt;code&gt;import { withRouter } from &#39;next/router&#39;&lt;/code&gt; 来把路由参数注入到组件的 props 中。&lt;/li&gt;
&lt;li&gt;原本的 &lt;code&gt;react-router-dom&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 可以被 &lt;code&gt;next/link&lt;/code&gt; 的 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 取代，但是 props 有所不同，比如 &lt;code&gt;to&lt;/code&gt; 需要换成 &lt;code&gt;href&lt;/code&gt;，以及 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 中不能使用 text 节点等。&lt;/li&gt;
&lt;li&gt;路由与 &lt;code&gt;.js/.tsx&lt;/code&gt; 文件的绑定在 Koa 中完成，使用 &lt;code&gt;koa-router&lt;/code&gt; 的写法，当浏览器访问路由时，由服务端的中间件设置对应的 return body 并返回给前端。具体可以参考 &lt;a href=&#34;https://github.com/ZijianHe/koa-router&#34;&gt;koa-router&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;国际化&#34;&gt;国际化&lt;/h3&gt;

&lt;p&gt;国际化的方式已经在上面的 &lt;code&gt;server.js&lt;/code&gt; 的部分叙述过。在项目中我们一样需要一个存放 &lt;code&gt;.json&lt;/code&gt; 翻译文件的地方。&lt;/p&gt;

&lt;p&gt;下面是一段官方的代码示例，我在官方使用的 express 框架的基础上将其修改成了适用于 koa 的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const supportedLanguages = glob
  .sync(&amp;quot;./lang/*.json&amp;quot;)
  .map(f =&amp;gt; basename(f, &amp;quot;.json&amp;quot;));
const localeDataCache = new Map();
const getLocaleDataScript = locale =&amp;gt; {
  const lang = locale.split(&amp;quot;-&amp;quot;)[0];
  if (!localeDataCache.has(lang)) {
    const localeDataFile = require.resolve(`react-intl/locale-data/${lang}`);
    const localeDataScript = readFileSync(localeDataFile, &amp;quot;utf8&amp;quot;);
    localeDataCache.set(lang, localeDataScript);
  }
  return localeDataCache.get(lang);
};

const getMessages = locale =&amp;gt; {
  return require(`./lang/${locale}.json`);
};

const localization = ctx =&amp;gt; {
  const { req } = ctx;
  const { query } = ctx.request;
  let locale;
  if (query.lang) {
    locale = query.lang;
  } else {
    const accept = accepts(req);
    locale = accept.language(accept.languages(supportedLanguages)) || &amp;quot;en&amp;quot;;
  }
  req.locale = locale;
  req.localeDataScript = getLocaleDataScript(locale);
  req.messages = getMessages(locale);
  ctx.req = req;
  return ctx;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的目的是修改前端请求时的 context。来当浏览器访问路由时，服务端对应的 &lt;code&gt;Controller&lt;/code&gt; 可以获取到 koa 的 &lt;code&gt;context&lt;/code&gt; 对象，并通过一些方法把当前所需的国际化的文件内容加入到 &lt;code&gt;context.req&lt;/code&gt; 中，这样前端页面就可以接收到这些数据。&lt;/p&gt;

&lt;p&gt;在路由的 &lt;code&gt;Controller&lt;/code&gt; 处理 ctx 的时候，我们只需要调用 &lt;code&gt;localization&lt;/code&gt; 这个函数，对 ctx 进行一层“包装”即可。&lt;/p&gt;

&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;

&lt;p&gt;React SSR 或者说 Next.js 里，最常用的页面缓存工具就是 &lt;code&gt;lru-cache&lt;/code&gt; 了。使用 &lt;code&gt;lru-cache&lt;/code&gt; 可以减少不必要的渲染以及加快加载的速度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const getCacheKey = req =&amp;gt; `${req.url}`;

function renderAndCache(ctx, pagePath, queryParams) {
  const key = getCacheKey(ctx.req);

  // If we have a page in the cache, let&#39;s serve it
  if (ssrCache.has(key)) {
    console.log(`CACHE HIT: ${key}`);
    ctx.body = ssrCache.get(key);
    return;
  }

  // If not let&#39;s render the page into HTML
  return app
    .renderToHTML(ctx.req, ctx.res, pagePath, queryParams)
    .then(html =&amp;gt; {
      // Let&#39;s cache this page
      console.log(`CACHE MISS: ${key}`);
      ssrCache.set(key, html);
      ctx.body = html;
    })
    .catch(err =&amp;gt; {
      console.log(&amp;quot;ERRR&amp;quot;, err);
      return app.renderError(err, ctx.req, ctx.res, pagePath, queryParams);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的基本原理就是在向前端返回数据时进行判断，如果 存在 cache key，则调取缓存中相应的内容；否则服务端才会根据路由调用相应的 &lt;code&gt;Controller&lt;/code&gt; 向前端返回数据。&lt;/p&gt;

&lt;p&gt;如果需要使用它，我们可以将路由的 &lt;code&gt;Controller&lt;/code&gt; 直接设成 &lt;code&gt;renderAndCache&lt;/code&gt; 函数即可，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;router.get(&amp;quot;/your/path&amp;quot;, async ctx =&amp;gt; renderAndCache(ctx, &amp;quot;/your/path&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要结合国际化来使用，只要对 &lt;code&gt;renderAndCache&lt;/code&gt; 的第一个参数 &lt;code&gt;ctx&lt;/code&gt; 使用上面的 &lt;code&gt;localization&lt;/code&gt; 函数进行处理即可。&lt;/p&gt;

&lt;h2 id=&#34;pages&#34;&gt;pages&lt;/h2&gt;

&lt;p&gt;根目录的 &lt;code&gt;pages&lt;/code&gt; 文件夹是 Next.js 默认的路由对应的页面入口。&lt;/p&gt;

&lt;h3 id=&#34;app-tsx&#34;&gt;_app.tsx&lt;/h3&gt;

&lt;p&gt;这个文件相当于 CSR App 中的 &lt;code&gt;App.tsx&lt;/code&gt;。如果你不创建这个文件，SSR App 也可以运行，因为 Next.js 中有一个默认的 &lt;code&gt;_app.tsx&lt;/code&gt;。我们创建它是因为我们需要重写这个主入口组件，例如加入 Redux 的 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 和 &lt;code&gt;react-intl&lt;/code&gt; 的 &lt;code&gt;&amp;lt;IntlProvider&amp;gt;&lt;/code&gt; 等高阶组件。&lt;/p&gt;

&lt;h3 id=&#34;document-tsx&#34;&gt;_document.tsx&lt;/h3&gt;

&lt;p&gt;与 &lt;code&gt;_app.tsx&lt;/code&gt; 一样，这也是个 Next.js 内置的组件，而如果我们需要实现某霞功能，也需要重写它。它相当于是 CSR App 中的 &lt;code&gt;index.html&lt;/code&gt;。在 &lt;code&gt;_document.tsx&lt;/code&gt; 中，有 &lt;code&gt;&amp;lt;Head /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;Main /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;NextScript /&amp;gt;&lt;/code&gt; 等组件，&lt;code&gt;&amp;lt;Head /&amp;gt;&lt;/code&gt; 对应的就是 html 的 &lt;code&gt;&amp;lt;head /&amp;gt;&lt;/code&gt; 标签，&lt;code&gt;&amp;lt;Main /&amp;gt;&lt;/code&gt; 的位置则会注入 &lt;code&gt;_app.tsx&lt;/code&gt; 这个组件，&lt;code&gt;&amp;lt;NextScript /&amp;gt;&lt;/code&gt; 则是打包后一些 js 文件插入的位置。你可以在里面添加 style 和 script 等标签，它们将最终会渲染在页面上。&lt;code&gt;&amp;lt;NextScript /&amp;gt;&lt;/code&gt; 在 Next.js 的 production 环境中会默认启用 preload，这样可以节约加载的时间。&lt;/p&gt;

&lt;h2 id=&#34;项目结构&#34;&gt;项目结构&lt;/h2&gt;

&lt;p&gt;我们的实践方式是，把 &lt;code&gt;pages&lt;/code&gt; 作为 Container，在这里进行高阶组件的连接，包括 redux、国际化等等。其他的结构与 react + redux + redux-saga 的最佳实践无异。&lt;/p&gt;

&lt;h2 id=&#34;构建方式&#34;&gt;构建方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; 可以启动一个 dev server，它会自动构建项目到根目录下的 &lt;code&gt;.next&lt;/code&gt; 文件夹中，可以在代码保存后热更新。&lt;/li&gt;
&lt;li&gt;如果需要在 EC/Docker 之类的生产环境中运行，需要先 &lt;code&gt;build&lt;/code&gt;，以生产的环境变量构建项目，再 &lt;code&gt;start&lt;/code&gt; 启动服务。这里我们相当于是直接部署/使用了 Node.js 的 runtime，开启了一个 Node.js 进程，所以这一步可以用 pm2 等管理工具来替代。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next export&lt;/code&gt; 是可以输出静态文件的。它是根据 pages 的目录结构输出的，可以不依赖于服务端来展示静态页面，当然正常的 JavaScript 也是可以运行的。但是有一点就是，如果在后端加了一些修改渲染的操作，比如上面提到的缓存和国际化，那在这个打包方式下，它们是完全不可用的。也就是说如果你有在 Node.js 层加入一些除路由外的额外功能，那你是不能使用静态页面的方式构建并直接上传到 github pages 或者 firebase 等托管服务的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;错误提示&#34;&gt;错误提示&lt;/h2&gt;

&lt;p&gt;由于 Next.js 运行时每次都需要编译，如果编译未报错而在运行时报错，那么错误提示只会显示编译完的文件的错误位置，而不像 CSR 一样能显示原始文件的错误位置，这对调试非常不友好。最常遇到的就是 &lt;code&gt;document is not defined&lt;/code&gt;，但是大项目的迁移中很可能不记得自己那个地方用到了 DOM API 导致这样的报错。&lt;/p&gt;

&lt;h2 id=&#34;单元测试&#34;&gt;单元测试&lt;/h2&gt;

&lt;p&gt;由于 &lt;code&gt;create-react-app&lt;/code&gt; 自带 jest 并且将测试命令集成在了 react-scripts 中（inject 之前），我们不需要额外对 jest 的 match、mock、transform 等属性进行配置。在 Next.js 中，我们则需要重新对 jest 进行配置。&lt;/p&gt;

&lt;p&gt;我使用的 jest 配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  moduleFileExtensions: [&amp;quot;ts&amp;quot;, &amp;quot;tsx&amp;quot;, &amp;quot;js&amp;quot;],
  transform: {
    &amp;quot;^.+\\.tsx?$&amp;quot;: &amp;quot;ts-jest&amp;quot;,
    &amp;quot;^.+\\.js$&amp;quot;: &amp;quot;babel-jest&amp;quot;
  },
  testMatch: [&amp;quot;**/*.(test|spec).(ts|tsx)&amp;quot;, &amp;quot;**/__tests__/*&amp;quot;],
  globals: {
    &amp;quot;ts-jest&amp;quot;: {
      babelConfig: true,
      tsConfig: &amp;quot;jest.tsconfig.json&amp;quot;
    }
  },
  coveragePathIgnorePatterns: [&amp;quot;/node_modules/&amp;quot;, &amp;quot;enzyme.js&amp;quot;],
  setupFilesAfterEnv: [&amp;quot;&amp;lt;rootDir&amp;gt;/enzyme.js&amp;quot;],
  coverageReporters: [&amp;quot;json&amp;quot;, &amp;quot;lcov&amp;quot;, &amp;quot;text&amp;quot;, &amp;quot;text-summary&amp;quot;],
  moduleNameMapper: {
    &amp;quot;\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$&amp;quot;:
      &amp;quot;&amp;lt;rootDir&amp;gt;/__mocks__/fileMock.js&amp;quot;,
    &amp;quot;\\.(css|less|scss)$&amp;quot;: &amp;quot;&amp;lt;rootDir&amp;gt;/__mocks__/styleMock.js&amp;quot;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们项目使用了 TypeScript，所以需要用 ts-jest 来解析 TypeScript，同时我们需要配置一下运行单元测试是的 TypeScript 编译规则，也就是 &lt;code&gt;jest.tsconfig.json&lt;/code&gt; 这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;esnext&amp;quot;,
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;sourceMap&amp;quot;: false,
    &amp;quot;experimentalDecorators&amp;quot;: true,
    &amp;quot;noImplicitUseStrict&amp;quot;: true,
    &amp;quot;removeComments&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;lib&amp;quot;: [&amp;quot;es2017&amp;quot;, &amp;quot;dom&amp;quot;],
    &amp;quot;typeRoots&amp;quot;: [&amp;quot;node_modules/@types&amp;quot;]
  },
  &amp;quot;exclude&amp;quot;: [&amp;quot;node_modules&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;.next&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的配置仍然存在一个问题，就是：jest 中无法正常解析某些 import 语句。&lt;code&gt;&amp;quot;allowSyntheticDefaultImports&amp;quot;: true&lt;/code&gt; 这个 TypeScript 配置的目的是允许 default import。在某些包里是没有 default export 的，例如 React。在 JavaScript 中我们可以用 &lt;code&gt;import React from &#39;react&#39;&lt;/code&gt; 的原因是这个是直接从 react 包本体中引入的，而 react 包中是有 &lt;code&gt;module.exports&lt;/code&gt; 的语句的。但是在 TypeScript 中，import 实际上解析到的并不是 react 包本体，而是 &lt;code&gt;@types/react&lt;/code&gt; 这个包。而这个包的 index.d.ts 文件里是没有一个 default export 的，所以 TypeScript 中如果我们不使用 &lt;code&gt;&amp;quot;allowSyntheticDefaultImports&amp;quot;: true&lt;/code&gt; 的配置，&lt;code&gt;import React from &#39;react&#39;&lt;/code&gt; 是会报错的。而在 jest 执行的时候，我即使开启了配置，还是遇到了这样的报错。所以最后我们决定全部改成 &lt;code&gt;import * as React from &#39;react&#39;&lt;/code&gt; 的写法了。同样有这种情况的还有 &lt;code&gt;ReactDOM&lt;/code&gt; 和 &lt;code&gt;proptypes&lt;/code&gt; 这两个包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TypeScript &#43; 单元测试：从零开始的经验之谈</title>
      <link>https://elizurhz.cn/frontend/typescript-and-unit-testing-in-action/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/typescript-and-unit-testing-in-action/</guid>
      <description>

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;公司和部门内部之前有在推广 TypeScript，但是由于种种原因很难投入使用，但这次我参与了一个从零开始的项目，没有技术栈限制，领导也说希望用 TypeScript 试一试。作为开发团队中唯一认真学过 TypeScript 的人（在部门进行过内部分享，写过内部博客），我们的经验其实都是很缺乏的。&lt;/p&gt;

&lt;p&gt;另外，在这个项目中，除了 TypeScript 之外，单元测试也是我们团队首次尝试的。&lt;/p&gt;

&lt;p&gt;同时，我的性格和开发风格也比较偏向“探索者”，所以领导也布置给我一些预研、新尝试，所以自然而然便成了一个 leader 的角色。&lt;/p&gt;

&lt;h2 id=&#34;项目构架&#34;&gt;项目构架&lt;/h2&gt;

&lt;p&gt;我们使用 create-react-app 搭建项目，没有 &lt;code&gt;eject&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而对于文件的组织，我们采用了按模块划分的方式，即各个模块集成自己的 store, reducers, actions, 展示组件, 容器组件等，并设置一个入口文件将它们都暴露给外部，外部需要引用的时候直接引用这个文件即可。&lt;/p&gt;

&lt;p&gt;主目录结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── docs // 文档
├── e2e // E2E 测试
├── src
│   ├── App.tsx // 主页面
│   ├── index.tsx // 主入口
│   ├── common.d.ts // 全局通用类型
│   ├── components // 通用组件
│   ├── i18n // 国际化
│   ├── @types // 如果某个依赖包没有 TypeScript 支持，则在这里编写 d.ts 文件
│   ├── modules // 业务模块
│   │   ├── moduleA
│   │   ├── moduleB
│   │   ...
│   ├── styles // 全局 scss 样式文件
│   ├── services // 与服务端请求相关的封装
│   ├── constants // 通用常量
│   └── utils // 通用工具函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块内部结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── index.ts // 主入口，用于导出外部可能引用到的所有该模块的内容
├── [MODULE_NAME].d.ts // 该组件下的通用类型
├── actions // 该模块的 redux action
├── common // 该模块内的通用组件（一般是与模块业务比较相关的）
│   ├── commonComponentA // 组件文件夹，包含组件、样式、单元测试
│   │   ├── index.tsx
│   │   ├── index.test.tsx
│   │   └── index.module.scss
│   ├── componentB
│   ...
├── components // 模块内的展示组件
│   ├── componentA
│   │   ├── __test__ // 单元测试
│   │   │   ├── __snapshots__ // 快照测试，如果有快照测试，Jest 会自动创建它
│   │   │   ├── index.test.js
│   │   │   └── someComponent.test.js
│   │   ├── index.ts // 主入口，用于导出外部可能引用到的所有组件
│   │   ├── componentA.tsx // 展示组件
│   │   ├── componentAContainer.tsx // 容器组件
│   │   ├── someComponent.tsx // 其他组件
│   │   └── index.module.scss
│   ...
├── reducers // 该模块内的 reducer
│   ├── index.ts // 主入口
│   ├── featureA.ts // 各子功能的 reducers
│   ...
├── sagas // redux-saga
│   ├── index.ts // 主入口
│   ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;typescript&#34;&gt;TypeScript&lt;/h2&gt;

&lt;p&gt;在使用 TypeScript 时，遇到的问题也是唯一可能的问题就是类型不匹配。刚开始的时候，大家对 React 的各种类型都非常不熟悉，所以不知道设定成什么好。事实上这应该也是所有的开发者入门遇到的最大问题。解决这个问题的方法，一是去稍微读一下 react 的 &lt;code&gt;index.d.ts&lt;/code&gt;，知道它大概有什么类型；二是参考一下成熟的 TypeScript 项目。Ant Design 可能是最合适的项目参考了。怎么写类型，React 里有什么常用的类型，以及怎么去继承复用类型，这些问题都可以在 Ant Design 上找到答案。&lt;/p&gt;

&lt;p&gt;这里总结一些常用的 React 类型（特殊未注明的都需要 import）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 children 时用 &lt;code&gt;React.ReactNode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;inline CSS 使用 &lt;code&gt;React.CSSProperties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;input 的相关事件使用 &lt;code&gt;React.ChangeEvent&lt;/code&gt; (泛型为 &lt;code&gt;ChangeEvent&amp;lt;HTMLInputElement&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;鼠标相关的事件使用 &lt;code&gt;React.MouseEvent&lt;/code&gt; (泛型为 &lt;code&gt;MouseEvent&amp;lt;HTMLButtonElement&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render()&lt;/code&gt; 函数的返回值类型是 &lt;code&gt;JSX.Element&lt;/code&gt;，不需要 import。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外 &lt;code&gt;react-router&lt;/code&gt; 和 &lt;code&gt;react-intl&lt;/code&gt; 分别有各自的类型 &lt;code&gt;RouteComponentProps&lt;/code&gt; 和 &lt;code&gt;InjectedIntlProps&lt;/code&gt;，需要 import。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;使用 TypeScript 对于刚入门的新手来说绝对是很浪费时间的，因为你写同样一个组件，相比 JavaScript 来说可能会花上两倍的时间。但是我们团队差不多在开发的第二周开始就能熟练开发了，所以 TypeScript 需要的仅仅是一些前期的学习成本，到后面它并不会成为风险或者负担。&lt;/p&gt;

&lt;p&gt;但是花这些时间去学习 TypeScript，带来的好处是不言而喻的。首先我们开发下来的体验就是：极少 Bug。Bug 大部分都是在开发时被解决的，因为有了 TypeScript 的约束，我们一旦出现类型错误等等，在开发时就可以被及时发现并修复，所以部署上去之后能发现的 Bug 就少了很多了。当然对于减少 Bug 贡献更多的其实是单元测试，这个后面会说。&lt;/p&gt;

&lt;h2 id=&#34;单元测试&#34;&gt;单元测试&lt;/h2&gt;

&lt;p&gt;单元测试框架我们使用的是 jest + enzyme。React 的单元测试相关的文章很多，但是都是关于“框架怎么用”，很少有人总结“一个项目里到底该怎么组织测试”。最近看到了一篇 &lt;a href=&#34;https://juejin.im/post/5bd640abf265da0ad63c125e&#34;&gt;React 单元测试策略及落地 #一篇就够系列&lt;/a&gt; 写得非常好，我们的单元测试也基本是按照这个来组织的。&lt;/p&gt;

&lt;p&gt;参考上面的文章，我们的单元测试的组织方式是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;connect 组件不测&lt;/li&gt;
&lt;li&gt;展示组件需要测试

&lt;ul&gt;
&lt;li&gt;UI 用快照测试(Jest)&lt;/li&gt;
&lt;li&gt;分支渲染必测&lt;/li&gt;
&lt;li&gt;事件必测&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;工具函数需要测试&lt;/li&gt;
&lt;li&gt;reducers 需要测试&lt;/li&gt;
&lt;li&gt;sagas 需要测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们的单元测试全部用 JavaScript 编写，这点也参考了 Ant Design。我认为单元测试没必要去真正完整地把那些 props mock 出来，因为我们是在验证代码逻辑的正确性，应该更多关注与代码本身，而不是类型有没有正确。如果在使用时传入了错误的类型，那么编译是不会通过的，这是 TypeScript 的编译器帮我们做的，再写关于类型错误的测试用例其实是画蛇添足。另外，在项目变得复杂之后，往往会出现一些很难 mock 的类型，强行去 mock 它们只会浪费我们写测试的时间。&lt;/p&gt;

&lt;h3 id=&#34;组件&#34;&gt;组件&lt;/h3&gt;

&lt;p&gt;我们的组件分为业务组件和通用组件。通用组件的测试就比较简单了，针对各个 props 进行测试即可，目的就是覆盖所有的分支逻辑和事件，同时用快照测试测 UI。而业务组件经常涉及到一些很复杂的 props，更有可能出现各种高阶组件，所以我们团队约定，在业务组件中不进行任何的高阶组件装饰。&lt;/p&gt;

&lt;p&gt;在测试组件的时候，必然会使用到 enzyme。在 enzyme 的使用上，我们确实碰到了很多问题，最大的问题还是在没经验的时候很难把目的转化成代码。例如我需要找一个“props 中有 &lt;code&gt;type=&amp;quot;primary&amp;quot;&lt;/code&gt; 的 Button 组件”，或者“触发 Button 子组件的 onClick 方法”。当然这也和官方文档写的不够（有的可能找不到）有关，并且很多文章也不会涉及到这种深入的内容。&lt;/p&gt;

&lt;h3 id=&#34;reducers&#34;&gt;reducers&lt;/h3&gt;

&lt;p&gt;reducers 测试比较简单，首先需要模拟出我们需要的 store，然后触发不同的 actions 去调用 reducers 的不同处理逻辑。具体测试方法官方文档都有说明，这里不再赘述。&lt;/p&gt;

&lt;h3 id=&#34;sagas&#34;&gt;sagas&lt;/h3&gt;

&lt;p&gt;sagas 的测试在官方文档也有专门页面说明。首先 saga 一定是异步的，而我们单元测试并不关注异步的结果，只需要测试相应的 saga 是否被正确调用。redux-saga 中有 &lt;code&gt;runSaga()&lt;/code&gt; 的 API 可以帮助我们完成单元测试。&lt;/p&gt;

&lt;h3 id=&#34;测试规范&#34;&gt;测试规范&lt;/h3&gt;

&lt;p&gt;在项目中，单元测试的规范化也是非常重要的。首先我们需要保证用例能实现你的测试目的，其次还需要有可读性。所以我对于单元测试质量的理解大概如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试描述需写精确，以便他人阅读，也方便说明该组、某个测试在测什么

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;describe&lt;/code&gt; 的第一个参数表示这一组测试在做什么&lt;/li&gt;
&lt;li&gt;&lt;code&gt;it&lt;/code&gt; 的第一个参数表示这个测试在做什么&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试的 expect 需要符合测试目的(即 &lt;code&gt;it&lt;/code&gt; 的描述)

&lt;ul&gt;
&lt;li&gt;例如给某个 input 赋初始 value，想判断它是否显示正确的 value，此时不能简单判断某个 DOM 存在&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果需要测试是否渲染成功，请使用 Jest 的快照测试，不要去判断某个 DOM 或者某个子组件是否存在

&lt;ul&gt;
&lt;li&gt;我们无法从某个 DOM 节点存在推导出组件是正常渲染的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;单元测试其实也是很耗时间的，特别是在不熟练的时候，可能在写测试时花的时间比开发花的时间还多。但是单元测试能够直接带来的好处就是极大减少了 Bug 数量。QA 往往是以业务场景来进行黑盒测试，他们不了解我们代码的写法，很多情况就是 QA 测试能通，但是实际上蕴藏了很多能产生 bug 的地方。在编写单元测试的过程中，我们也可以和 QA 一样去构思不同的业务场景，编写不同的测试用例，在这个过程中我们也会发现代码可能对于某些场景、逻辑的处理有缺失，可以依此对代码进行修正和补充。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;TypeScript 和单元测试刚入门的时候会觉得这些东西没用而且浪费时间，但是真正会用它们了之后其实是“真香”，很推荐开发者们都投入这个时间成本，因为它们后期带来的回报是完全可以弥补这个成本，甚至还有赚的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Canvas 手写板的实现与优化</title>
      <link>https://elizurhz.cn/frontend/canvas-writing-pad/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/canvas-writing-pad/</guid>
      <description>

&lt;p&gt;最近在公司接了几个项目，都和 Canvas 手绘手写有关的，有历史遗留项目，还有要从头写的新需求。之前对 Canvas 的认知比较少，只写过一个带动画的圆环百分比小组件（&lt;a href=&#34;https://github.com/ElizurHz/vue-percentage&#34;&gt;GitHub - ElizurHz/vue-percentage: 圆环百分比小组件&lt;/a&gt;），是定好数据后再把它画到 Canvas 上，而手写板是第一次接触。&lt;/p&gt;

&lt;p&gt;本文所涉及的代码是基于 &lt;a href=&#34;https://github.com/szimek/signature_pad&#34;&gt;szimek/signature_pad&lt;/a&gt; 这个开源组件进行改造的，所以下面会对源码进行一些解析，也会讲解一些我自己对其进行改造的经验。&lt;/p&gt;

&lt;h2 id=&#34;canvas-相关基础知识&#34;&gt;Canvas 相关基础知识&lt;/h2&gt;

&lt;p&gt;本文列举一些本文涉及到的必备知识和常用的 API，API 具体内容不过多赘述，详情可以在 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API&#34;&gt;Canvas - Web API 接口参考 | MDN&lt;/a&gt; 查看。&lt;/p&gt;

&lt;h3 id=&#34;基本用法&#34;&gt;基本用法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 是 HTML5 中的一个标签，我们可以以如下方式书写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;canvas id=&amp;quot;test&amp;quot; width=&amp;quot;150&amp;quot; height=&amp;quot;150&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 width 和 height 是 canvas 的必需属性，否则无法看到绘制的内容。在初始化时我们也可以通过 &lt;code&gt;document.getElementById&lt;/code&gt; 的方式获取 DOM 节点，并设置其 width 和 height 属性。&lt;strong&gt;【注意：在已经绘制过的 canvas 上重设这两个属性会导致已绘制内容被清空】&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如需在 canvas 上绘制，我们需要获取它的“渲染上下文 (The rendering context)”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const test = document.getElementById(&#39;test&#39;)
const ctx = test.getContext(&#39;2d&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;绘制&#34;&gt;绘制&lt;/h3&gt;

&lt;p&gt;在 Canvas 中我们定位使用的是坐标系，(0, 0) 代表的是最左上的点，可视区域最右下的点为 (width, height)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;context.clearRect(x, y, width, height): 以 (x, y) 为基准（左上角的点），清空长为 width、宽为 height 的矩形中所绘制的所有内容&lt;/li&gt;
&lt;li&gt;context.eginPath(): 新建路径&lt;/li&gt;
&lt;li&gt;context.closePath(): 闭合路径&lt;/li&gt;
&lt;li&gt;context.stroke(): 绘制轮廓&lt;/li&gt;
&lt;li&gt;context.moveTo(x, y): 移动至点 (x, y)&lt;/li&gt;
&lt;li&gt;context.lineTo(x, y): 绘制一条从当前点到 (x, y) 的直线&lt;/li&gt;
&lt;li&gt;context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y): 三次贝塞尔曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与图片相关的 API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;canvas.toBlob(): 当前 canvas 转化为 blob 对象，参数是一个回调函数，回调函数的参数就是 blob 对象。&lt;strong&gt;回调函数是异步执行的！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;canvas.toDataURL(): 转化为 base64 编码的 url。参数为图片格式，如 &lt;code&gt;&#39;image/png&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;context.drawImage(): 把图片绘制到 canvas 上。它有三种使用方式，根据传参数量的不同会有不同的结果。详情见 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage&#34;&gt;CanvasRenderingContext2D.drawImage() - Web API 接口参考 | MDN&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;贝塞尔曲线&#34;&gt;贝塞尔曲线&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A&#34;&gt;贝塞尔曲线 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/canvas-writing-pad/Bezier_3_big.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲一下本文涉及到的三次贝塞尔曲线。它有起点、控制点 1、控制点 2、终点四个关键的点。&lt;/p&gt;

&lt;p&gt;三次贝塞尔曲线的公式如下（LeaveIt 主题的 Dark Mode 下会看不清，请切换到 Light Mode）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/canvas-writing-pad/bezier_3_formulation.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中 t 为参数。使 t 逐渐从 0 增大到 1，即可通过这个方程式画出贝塞尔曲线。&lt;/p&gt;

&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;

&lt;p&gt;实现手写板，我们需要监听 Canvas 上的事件。由于我们可能是用鼠标去绘画，也可能是在触屏上绘画，所以我们除了监听鼠标事件之外，还需要监听触摸事件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mousedown/touchstart: 鼠标点击/开始触摸&lt;/li&gt;
&lt;li&gt;mousemove/touchmove: 鼠标/触摸移动中&lt;/li&gt;
&lt;li&gt;mouseup/touchend: 鼠标按键抬起/触摸结束(离开屏幕)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用这些 API 能满足大多数情况下的需求，但是现在出现了如 Surface Pen, Apple Pen 这类的手写笔，W3C 也有相应的新标准：PointerEvent (&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent&#34;&gt;PointerEvent - Web API 接口 | MDN&lt;/a&gt;)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PointerEvent 接口代表了由 指针 引发的 DOM 事件的状态，包括接触点的位置，引发事件的设备类型，接触表面受到的压力等。
指针 是输入设备的硬件层抽象（比如鼠标，触摸笔，或触摸屏上的一个触摸点）。指针 能指向一个具体表面（如屏幕）上的一个（或一组）坐标。
指针的 击中检测 指浏览器用来检测 指针事件的目标元素的过程。大多数情况下，这个目标元素是由 指针的位置和元素在文章中的位置和分层共同决定的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PointerEvent 的使用方法和 MouseEvent、TouchEvent 很类似，但有新增一些有用的 Properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PointerEvent.pointerType: 这个 property 表示的是接触类型，有 3 种 string 类型的值 - mouse, pen, touch，分别代表鼠标、触控笔、触摸。&lt;/li&gt;
&lt;li&gt;PointerEvent.pressure: 这个 property 表示的是压力等级，数值范围是从 0 到 1 ，如果我们没有压感触控笔，或者使用鼠标，那么这个值默认是 0.5。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实现方案&#34;&gt;实现方案&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;历史遗留的项目中使用的是监听 move 的事件，每次都用 &lt;code&gt;lineTo()&lt;/code&gt;和&lt;code&gt;stroke()&lt;/code&gt;绘制出线条。这样做存在的问题是延迟很严重，笔画不跟笔，同时锯齿感也很严重。&lt;/li&gt;
&lt;li&gt;参考了 &lt;a href=&#34;https://github.com/szimek/signature_pad&#34;&gt;GitHub - szimek/signature_pad: HTML5 canvas based smooth signature drawing&lt;/a&gt; 的实现方案，使用的是三次贝塞尔曲线，由于三次贝塞尔曲线的绘制需要至少 4 个点，分别是起点、控制点 1、控制点 2、终点，所以不能每次 move 都 &lt;code&gt;stroke()&lt;/code&gt;进行绘制，而是需要记录点坐标并通过计算来绘制。实际效果比上面一种方法的延迟和锯齿感都好很多，&lt;strong&gt;但是唯独在 Surface Book + Surface Pen 上的延迟感还是很明显，而前一代的 iPad Pro + Apple Pen 非常流畅，不知道有没有做过 Surface Pen 适配的大神能解答这个问题&lt;/strong&gt;。于是我就想能不能用 PointerEvent 来解决，但测试用的 Surface Book 是公司的开发机，我们小组只有一台，常常被其他开发和 QA 抢去使用，所以没有机会去验证这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;接下来，我们对 &lt;a href=&#34;https://github.com/szimek/signature_pad&#34;&gt;szimek/signature_pad&lt;/a&gt; 的源码进行一番解析。需要注意的是，master 分支的源码是用 TypeScript 写的，而在 gh-pages 分支上有 ES5 的版本。为了让不懂 ts 的读者能看懂，下面会对 &lt;a href=&#34;https://github.com/szimek/signature_pad/blob/gh-pages/js/signature_pad.js&#34;&gt;ES5 版本&lt;/a&gt; 的代码进行解析。&lt;/p&gt;

&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;

&lt;p&gt;这里用了两个辅助类，Bezier 是贝塞尔曲线，而 Point 是 canvas 中需要用到的点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i &amp;lt;= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i &amp;gt; 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

Point.prototype.equals = function (other) {
  return this.x === other.x &amp;amp;&amp;amp; this.y === other.y &amp;amp;&amp;amp; this.time === other.time;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是 Point 这个类中，原作者加入了点绘制的时间，在原作者的项目中是有根据绘制速度调整笔画粗细的，但这个在我的改造中因为需求的缘故被去掉了。&lt;/p&gt;

&lt;h3 id=&#34;mousedown-touchstart&#34;&gt;mousedown/touchstart&lt;/h3&gt;

&lt;p&gt;首先源码使用构造函数创建了一个 SignaturePad 的类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === &#39;function&#39;) {
    this.onBegin(event);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里开始的代码会出现很多 this 或者 self，它们如果没有特殊说明都是指代的构造函数中的 this 本身。&lt;/p&gt;

&lt;p&gt;这部分没有什么关键的代码，直接调用 &lt;code&gt;this._strokeUpdate&lt;/code&gt; 了。&lt;code&gt;onBegin&lt;/code&gt; 是用户可以自定义的回调函数。&lt;/p&gt;

&lt;h3 id=&#34;mousemove-touchmove&#34;&gt;mousemove/touchmove&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y); // 根据 event 对象中的 clientX 和 clientY 生成该点在 canvas 坐标系中的 Point 对象
  var lastPointGroup = this._data[this._data.length - 1];
  var lastPoint = lastPointGroup &amp;amp;&amp;amp; lastPointGroup[lastPointGroup.length - 1];
  var isLastPointTooClose = lastPoint &amp;amp;&amp;amp; point.distanceTo(lastPoint) &amp;lt; this.minDistance;

  // 如果绘制的点和之前的点距离太近，则跳过该点的绘制
  // Skip this point if it&#39;s too close to the previous one
  if (!(lastPoint &amp;amp;&amp;amp; isLastPointTooClose)) {
    var _addPoint = this._addPoint(point),
        curve = _addPoint.curve,
        widths = _addPoint.widths;

    if (curve &amp;amp;&amp;amp; widths) {
      this._drawCurve(curve, widths.start, widths.end);
    }

    this._data[this._data.length - 1].push({
      x: point.x,
      y: point.y,
      time: point.time,
      color: this.penColor
    });
  }
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

/*
 * 生成 Bezier 对象和曲线的宽度值
 * curve: Bezier 对象
 * widths: 包含 start 和 end 两个 properties
*/
SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length &amp;gt; 2) {
    // Bezier 类需要 4 个点的参数，作者为了减少延迟，把第一个点复制了一次，构造成 4 个点的数组，以此计算前两个点之间的三次贝塞尔曲线的控制点
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

/*
 * 绘制贝塞尔曲线
 * 绘制方法为从 0 至 1 逐步增大贝塞尔曲线的参数 t
 * 代码实际上就是公式的计算
*/
SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length()); // 绘制步长是曲线的长度

  ctx.beginPath();

  for (var i = 0; i &amp;lt; drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

// 绘制弧线
SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

// 计算贝塞尔曲线的控制点
SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分就是绘图的核心算法了，我在项目中也是直接使用了作者编写的代码。
在 &lt;code&gt;_addPoint()&lt;/code&gt; 中有名为 &lt;code&gt;_calculateCurveWidths&lt;/code&gt; 的函数，是原作者用于根据绘制速度计算笔画粗细的算法，原代码对应的相关参数是 &lt;code&gt;constructor&lt;/code&gt; 中的 &lt;code&gt;this.maxWidth&lt;/code&gt; 和 &lt;code&gt;this.minWidth&lt;/code&gt;。
由于我做的项目不需要这个功能，所以我只需要把 &lt;code&gt;this.maxWidth&lt;/code&gt; 和 &lt;code&gt;this.minWidth&lt;/code&gt; 设置成相同的值即可。
这个功能详情可以参考前文提供的作者的 GitHub 上的源码。&lt;/p&gt;

&lt;p&gt;主要内容已经用中文备注在代码中了，总结起来就是：选取 3 个点来计算控制点，根据控制点绘制出两点之间的曲线&lt;/p&gt;

&lt;h3 id=&#34;mouseup-touchend&#34;&gt;mouseup/touchend&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length &amp;gt; 2; // 如果点的数量太少，则无法绘制曲线
  var point = this.points[0]; // Point instance

  if (!canDrawCurve &amp;amp;&amp;amp; point) {
    this._drawDot(point); // 点数量太少时改为绘制单个点
  }

  if (point) {
    var lastPointGroup = this._data[this._data.length - 1];
    var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object

    // 相同的点会被排除，不会被绘制
    // When drawing a dot, there&#39;s only one point in a group, so without this check
    // such group would end up with exactly the same 2 points.
    if (!point.equals(lastPoint)) {
      lastPointGroup.push({
        x: point.x,
        y: point.y,
        time: point.time,
        color: this.penColor
      });
    }
  }

  if (typeof this.onEnd === &#39;function&#39;) {
    this.onEnd(event);
  }
};

// 画点
SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === &#39;function&#39; ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里作者做了一个处理，就是在生成有效的点数量太少时则不会绘制曲线，改为绘制单点。如果忽略了此步，则会出现点触和小范围内移动无反应的情况，严重影响手写体验。&lt;/p&gt;

&lt;h2 id=&#34;其他功能&#34;&gt;其他功能&lt;/h2&gt;

&lt;p&gt;这部分功能都是我根据需求加进去的。&lt;/p&gt;

&lt;h3 id=&#34;单次手写保存成图片&#34;&gt;单次手写保存成图片&lt;/h3&gt;

&lt;p&gt;首先我使用的 canvas 区域很大，但是实际上可能有手写内容的范围很小，所以这边要做一步剪裁的操作。
在上面的代码中有一个 &lt;code&gt;this._data&lt;/code&gt; 的变量，这个变量记录了所有绘制过的点。
因此我们可以通过这个坐标数据来找出一个包含所有点的区域，再用 &lt;code&gt;drawImage()&lt;/code&gt; 将其绘制到一个大小和这个区域相同的、隐藏的 canvas 中。
接着使用 &lt;code&gt;toBlob()&lt;/code&gt; 或者 &lt;code&gt;toDataURL()&lt;/code&gt; 就可以导出图片了。&lt;/p&gt;

&lt;h3 id=&#34;所有的手写内容拼接并保存为一张图片&#34;&gt;所有的手写内容拼接并保存为一张图片&lt;/h3&gt;

&lt;p&gt;上面的【单次手写保存成图片】，在项目中我们是把它们排列起来，有空格、换行、退格等操作供排版，但是最后需要把这些所有的内容都导出成一张图片进行保存。
这里同样需要用到 &lt;code&gt;drawImage()&lt;/code&gt;，不过区别在于不需要裁切。&lt;/p&gt;

&lt;p&gt;我的解决方案是：首先每张图大小不同，所以我给每一行横向排列的图片定了一个固定的高度，超过这个高度的图片会被等比缩放到这个高度，未超过的则不作处理。
而绘制上去之后，每次都会移动绘制起始点，在同一行内的则直接向右侧平移（缩放后的）图片的宽度，空格就向右移动一段空白的位置，换行则向下移动一行的高度并移动到最左侧。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;仅仅是一个入门级的操作，但是用比较粗暴的方式实现的话，体验上和更优的方案的差距会比较明显。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ECS 上的 git 管理工具踩坑记</title>
      <link>https://elizurhz.cn/ops/remote-private-git-first-look/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/ops/remote-private-git-first-look/</guid>
      <description>

&lt;h1 id=&#34;ecs-上的-git-管理工具踩坑记&#34;&gt;ECS 上的 git 管理工具踩坑记&lt;/h1&gt;

&lt;h2 id=&#34;gitlab&#34;&gt;gitlab&lt;/h2&gt;

&lt;h3 id=&#34;在-centos-上安装-gitlab&#34;&gt;在 CentOS 上安装 gitlab&lt;/h3&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://blog.csdn.net/caib1109/article/details/51756246&#34;&gt;8 小时外实践系列(六) - 在阿里云服务器上搭建 GitLab(草稿) - CSDN 博客&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;gitlab 非常吃性能，在 1 核 1G 的服务器上安装后会导致机子非常卡，同时域名/IP 访问也会出现 502，查资料之后发现是配置太低的问题。官方推荐的配置是 2 核心 8G 内存，我们普通个人用户显然难以支付这么昂贵的服务器配置，更不用说海外主机了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用-docker-部署-gitlab&#34;&gt;使用 docker 部署 gitlab&lt;/h3&gt;

&lt;p&gt;只需要在 docker hub 中 &lt;code&gt;docker pull gitlab/gitlab-ce&lt;/code&gt; 就行，然后我启动容器的的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker run --detach \
  --hostname gitlab.mydomain.com \
  --publish 8443:443 --publish 80:80 --publish 2222:22 \
  --name gitlab \
  --restart always \
  --volume /srv/gitlab/config:/etc/gitlab \
  --volume /srv/gitlab/logs:/var/log/gitlab \
  --volume /srv/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如需修改 gitlab.rb 的配置，只需要 &lt;code&gt;vim /srv/gitlab/config/gitlab.rb&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;一般需要配置的有：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;external_url &#39;你的域名或者IP&#39; # 改成你的域名或者 IP，如果你的端口映射不是 80，那也不能在这里加端口
gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 2222 # 防止和本机 22 端口冲突
unicorn[&#39;port&#39;] = 8999 # 如果你的 8080 端口被占用的话
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;另外记住，如果单开某个端口，需要在 ECS 实例的安全组中允许这个端口被某个或者某些 IP 访问。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置完成之后需要在容器中 reconfigure: &lt;code&gt;docker exec -it gitlab gitlab-ctl reconfigure&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;然而我按照上面的方式完成之后，通过域名或者 IP 进入仍是 502。
后来我尝试了在不同机子上部署。例如在群辉 DS218+ 上用同样的方式配置会出现 容器意外停止 的问题；在我的 iMac 本机上用 docker 部署就可以正常访问和进行代码管理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;gogs&#34;&gt;gogs&lt;/h2&gt;

&lt;p&gt;gogs 不像 gitlab 那样吃性能，功能也很完善，不过 gogs 需要有额外的数据库依赖，如 MySQL。具体的部署方式参考以下两篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/5f5e419b5de8&#34;&gt;docker 安装 mysql - 简书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2a7acb07b352&#34;&gt;docker 安装 gogs - 简书&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;勘误：在《docker 安装 mysql - 简书》中，创建网络的命令不是 &lt;code&gt;docker create network backend&lt;/code&gt; 而是 &lt;code&gt;docker network create backend&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我的容器启动代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 启动 MySQL
docker run -d --name mysql57 \
--net=backend \ # 加入创建的 backend 网络中
-p 3306:3306 \
-e MYSQL_ROOT_PASSWORD=root \
-v /srv/mysql/data:/var/lib/mysql \
-v /srv/mysql/conf:/etc/mysql/conf.d \
# 启动 gogs
docker run -d \
-p 10022:22 -p 3000:3000 \
--name=gogs \
--net=backend \ # 加入创建的 backend 网络中
-v /srv/gogs/:/data gogs/gogs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时访问服务器的 3000 端口即可进入设置界面，记住要把 localhost 全部改成服务器 ip。&lt;/p&gt;

&lt;h3 id=&#34;关于-gogs-的数据库设置&#34;&gt;关于 gogs 的数据库设置&lt;/h3&gt;

&lt;p&gt;首先由于本例使用了 docker network，所以可以直接使用 容器名:端口 来访问，例如 mysql57:3306。&lt;/p&gt;

&lt;p&gt;另外我们需要在 mysql 容器中创建一个数据库，否则 gogs 无法完成设置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it mysql57 /bin/bash
mysql -u root -p
# 然后输入密码，如果你没更改密码，则密码是 root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在 mysql 命令行中创建数据库，gogs 默认数据库名就是 gogs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE gogs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们在网页中就可以完成 gogs 的初始化设置了。&lt;/p&gt;

&lt;p&gt;如果想要使用 gogs，首先我们要注册一个账号，注意第一个注册的账号默认是拥有最高权限的账号。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在实际使用中，我遇到了 git clone 时发现有 not a repository 的问题，可能是 IP/域名、端口等等设置的问题，仍在研究中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/caib1109/article/details/51756246&#34;&gt;8 小时外实践系列(六) - 在阿里云服务器上搭建 GitLab(草稿) - CSDN 博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/5f5e419b5de8&#34;&gt;docker 安装 mysql - 简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/2a7acb07b352&#34;&gt;docker 安装 gogs - 简书&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GitHub 上 Fork 的仓库如何与原仓库同步并提交内容</title>
      <link>https://elizurhz.cn/ops/git-upstream/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/ops/git-upstream/</guid>
      <description>

&lt;h1 id=&#34;github-上-fork-的仓库如何与原仓库同步并提交内容&#34;&gt;GitHub 上 Fork 的仓库如何与原仓库同步并提交内容&lt;/h1&gt;

&lt;p&gt;我们可能有时会遇到需要向 GitHub 上的开源的项目提交代码。在 GitHub 中，由于你不是那个开源项目中有权限提交代码的人，你只能 Fork 后再发起 Pull Request。&lt;/p&gt;

&lt;h2 id=&#34;fork-仓库&#34;&gt;Fork 仓库&lt;/h2&gt;

&lt;p&gt;你可以在 GitHub 网页上点击 Fork，之后你可以在你的个人主页的 Repository 中找到你 Fork 的仓库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/git-upstream/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后你就可以将其 clone 到本地。&lt;/p&gt;

&lt;h2 id=&#34;fork-的本地仓库与源仓库连接&#34;&gt;Fork 的本地仓库与源仓库连接&lt;/h2&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://help.github.com/articles/syncing-a-fork/&#34;&gt;Syncing a fork - User Documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先在命令行工具中输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时应该显示如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们没有将其连接到源仓库，所以需要用命令去连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的地址是&lt;strong&gt;源仓库&lt;/strong&gt;的地址。接着我们再输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时应该能看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了与与源仓库的连接。&lt;/p&gt;

&lt;h2 id=&#34;fork-的仓库与源仓库同步代码&#34;&gt;Fork 的仓库与源仓库同步代码&lt;/h2&gt;

&lt;p&gt;首先：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch upstream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取源仓库更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以将本地 master 分支更新到最新。我们就可以在此基础上创建新分支提交 PR。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React &#43; TypeScript 从云玩家到入门</title>
      <link>https://elizurhz.cn/frontend/typescript-for-jser/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/typescript-for-jser/</guid>
      <description>

&lt;h1 id=&#34;react-typescript-从云玩家到入门&#34;&gt;React + TypeScript 从云玩家到入门&lt;/h1&gt;

&lt;p&gt;TypeScript 对我们开发最大的帮助就是类型检查，所以玩转 TypeScript 其实就是在玩转类型。而 TypeScript 本身和 Java, C# 等面向对象的语言有非常多类似的地方，有相应经验的读者能够较快地入门。本文旨在于帮助无面向对象开发经验的 JavaScript 使用者能最快速地上手并使用 TypeScript 编写 React 应用。由于篇幅和定位所限，本文将不会涉及到较为复杂的组件设计模式。&lt;/p&gt;

&lt;h2 id=&#34;typescript-基础&#34;&gt;TypeScript 基础&lt;/h2&gt;

&lt;p&gt;这部分主要介绍入门 TypeScript 必须掌握的，以及 React 开发中经常会用到的一些语法规范。&lt;/p&gt;

&lt;h3 id=&#34;基础类型&#34;&gt;基础类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;number: 数字&lt;/li&gt;
&lt;li&gt;string: 字符串&lt;/li&gt;
&lt;li&gt;boolean: 布尔值&lt;/li&gt;
&lt;li&gt;Array: 数组。在使用数组类型的时候必须标记数组中的数据类型，如 &lt;code&gt;number[]&lt;/code&gt; 或者 &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tuple: 元组。&lt;code&gt;let x: [string, number];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;any: 任意类型&lt;/li&gt;
&lt;li&gt;void: 空，一般用于函数的返回值&lt;/li&gt;
&lt;li&gt;never: 永远不会出现的类型，一般用于函数的返回值，例如抛出错误或者永远不结束的死循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;可选类型&#34;&gt;可选类型&lt;/h3&gt;

&lt;p&gt;标记为可选类型的属性并非是必须的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface IObj {
  str?: string;
  num: number;
}

// tslint 不报错
let obj1: IObj = {
  num: 123
};

// tslint 报错
let obj2: IObj = {
  str: &amp;quot;asdf&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/typescript-for-jser/optional-error.png&#34; alt=&#34;optional-error&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;readonly&#34;&gt;Readonly&lt;/h3&gt;

&lt;p&gt;一般在 Interface 和 Class 中会使用。设置为 &lt;code&gt;readonly&lt;/code&gt; 的变量、属性，一旦定义后就无法直接修改。如果在代码中有修改的操作，则 tslint 会报错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/typescript-for-jser/readonly-error.png&#34; alt=&#34;readonly-error&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function add(x: number, y: number): number {
  return x + y;
}

let myAdd: (x: number, y: number) =&amp;gt; number = function(
  x: number,
  y: number
): number {
  return x + y;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的类型限制主要在参数和返回值的位置需要定义。如果在等号左侧已经定义了类型，那么右侧可以不需要写类型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let myAdd: (baseValue: number, increment: number) =&amp;gt; number = function(x, y) {
  return x + y;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个在 TypeScript 中被称作 “contextual typing”。&lt;/p&gt;

&lt;h2 id=&#34;interface&#34;&gt;interface&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;One of TypeScript’s core principles is that type-checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural subtyping”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Interface 一般用于描述一个较为复杂的限制，例如在一个对象中限制某些属性的类型。有时被称为“鸭子类型”。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&amp;rdquo;
在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface ITest {
  a: number;
  b: string;
}

const test: ITest = {
  a: 1,
  b: &amp;quot;123&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Interface 和 class 的区别:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Interface 和 class 在 TypeScript 中都可以去描述一个限制，与 PHP、Java 中的 interface、class 一样，TypeScript 中的 interface 只做声明不做实现。&lt;/li&gt;
&lt;li&gt;如果把上面的 interface 声明换成 class，tslint 不会报错，代码可以正常执行，但是二者编译出来的 JavaScript 不同。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 使用 interface 编译后的代码
var test = {
  a: 1,
  b: &amp;quot;123&amp;quot;
};

// 使用 class 编译后的代码
var ITest = /** @class */ (function() {
  function ITest() {}
  return ITest;
})();
var test = {
  a: 1,
  b: &amp;quot;123&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;class 可以使用 implements 关键字来实现 interface。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类型别名&#34;&gt;类型别名&lt;/h3&gt;

&lt;p&gt;TypeScript 中允许使用 type 关键字来声明类型别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type State = {
  a: string;
  b: Array&amp;lt;number&amp;gt;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型别名和 interface 通常具有同样的功能，但是类型别名不能被 &lt;code&gt;extends&lt;/code&gt; 或者 &lt;code&gt;implements&lt;/code&gt;，也不能 &lt;code&gt;extends&lt;/code&gt; 或者 &lt;code&gt;implements&lt;/code&gt; 其他类型。并且类型别名在编译器中显示的是 Object 字面量类型，而 interface 显示是 interface。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because &lt;a href=&#34;https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle&#34;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.
【软件中的对象应该对于扩展是开放的，但是对于修改是封闭的】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;泛型&#34;&gt;泛型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function identity(arg: any): any {
  return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们在写这样一个函数的时候，参数和返回值都可以是任意类型，但实际上这样我们就丢失了参数和返回值的类型信息（实际上输入和输出应该是相同的类型）。
这时我们可以用一个类型变量 T：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function identity&amp;lt;T&amp;gt;(arg: T): T {
  return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样保证了参数和返回值的类型都是 T。
我们可以通过如下的方式使用这个泛型函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let output = identity&amp;lt;string&amp;gt;(&amp;quot;myString&amp;quot;); // type of output will be &#39;string&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;映射类型&#34;&gt;映射类型&lt;/h3&gt;

&lt;p&gt;映射类型包括 Partial 和 Readonly，它们可以在原有 interface 的基础上分别映射出所有属性都是可选类型，和所有属性都是只读的新的 type。这两种映射类型实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type Readonly&amp;lt;T&amp;gt; = { readonly [P in keyof T]: T[P] };
type Partial&amp;lt;T&amp;gt; = { [P in keyof T]?: T[P] };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在-react-中使用-typescript&#34;&gt;在 React 中使用 TypeScript&lt;/h2&gt;

&lt;h3 id=&#34;创建一个-react-typescript-的项目&#34;&gt;创建一个 React + TypeScript 的项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;create-react-app
通过 create-react-app 来搭建，我们只需要在命令中加入额外参数即可：
&lt;code&gt;create-react-app my-app --scripts-version=react-scripts-ts&lt;/code&gt;
搭建出来的项目结构与 JavaScript 版本基本相同，区别在于根目录有&lt;code&gt;tsconfig.json&lt;/code&gt;、&lt;code&gt;tslint.json&lt;/code&gt; 等 TypeScript 相关的文件。&lt;code&gt;tsconfig.json&lt;/code&gt; 用于告诉 &lt;code&gt;ts-loader&lt;/code&gt; 如何编译 .ts 文件，而 &lt;code&gt;tslint.json&lt;/code&gt; 则是 tslint (TypeScript 语法检查器) 的配置。&lt;/li&gt;
&lt;li&gt;手动安装
手动安装需要通过 npm 或者 yarn 安装 &lt;code&gt;typescript&lt;/code&gt; 和 &lt;code&gt;ts-loader&lt;/code&gt; 等 TypeScript 相关的 package，同时需要手动配置 &lt;code&gt;tsconfig.json&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;definitelytyped-d-ts&#34;&gt;DefinitelyTyped - *.d.ts&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/DefinitelyTyped/DefinitelyTyped&#34;&gt;GitHub - DefinitelyTyped/DefinitelyTyped: The repository for high quality TypeScript type definitions.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TypeScript 的模块发布的时候都是打包成 JavaScript 来发布的，但是这样会丢失定义好的数据类型。 .d.ts 可以约定 type, class, interface, function, 变量以及常量等的行为，相当于是一个 package 或者 library 的“说明书”。&lt;/p&gt;

&lt;p&gt;在 React 中，我们常常会需要安装一些如 &lt;code&gt;@types/react-router-dom&lt;/code&gt; 这种以 &lt;code&gt;@types&lt;/code&gt; 作为开头的 package。在 JS 中我们直接 &lt;code&gt;npm install react-router-dom&lt;/code&gt; 即可，但是在 TypeScript 中，如果没有 DefinitelyTyped，将会报如下的错误：
&lt;img src=&#34;https://elizurhz.cn/images/typescript-for-jser/types-error.png&#34; alt=&#34;@types-error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然并不是所有的 package 都需要一个对应的 &lt;code&gt;@types&lt;/code&gt; ，不少 package 自身已经有 .d.ts 文件了，例如 antd，所以我们不需要额外的 &lt;code&gt;@types&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&#34;无状态组件&#34;&gt;无状态组件&lt;/h3&gt;

&lt;p&gt;在 JavaScript 中，我们可以按如下的方式写一个 Stateless Functional Component ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &amp;quot;react&amp;quot;;
const Button = ({ onClick, children }) =&amp;gt; (
  &amp;lt;button onClick={handleClick}&amp;gt;{children}&amp;lt;/button&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在 TypeScript 中，我们需要加入类型，所以具体怎么加呢？我们可以通过 &lt;code&gt;@types/react&lt;/code&gt; 中的 &lt;code&gt;index.d.ts&lt;/code&gt;来进行分析：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：以下代码都去除了大段的注释，若需要查看官方的注释请至 &lt;code&gt;npm install&lt;/code&gt; 后下载的 &lt;code&gt;./node_modules/@types/react&lt;/code&gt; 中查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type SFC&amp;lt;P = {}&amp;gt; = StatelessComponent&amp;lt;P&amp;gt;;
interface StatelessComponent&amp;lt;P = {}&amp;gt; {
  (props: P &amp;amp; { children?: ReactNode }, context?: any): ReactElement&amp;lt;
    any
  &amp;gt; | null;
  propTypes?: ValidationMap&amp;lt;P&amp;gt;;
  contextTypes?: ValidationMap&amp;lt;any&amp;gt;;
  defaultProps?: Partial&amp;lt;P&amp;gt;;
  displayName?: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这段代码中可以看出，props 是 P 和 一个对象的联合类型，P 指的是我们通常传入的 props，而对象中的 children 就是 React 中的 children，是可选类型，type 是 ReactNode，是 React 中的类型。另外在 React 的 &lt;code&gt;index.d.ts&lt;/code&gt;中，对于事件有专门的类型定义 &lt;code&gt;MouseEvent&lt;/code&gt;（同时也有其他 Event 的类型定义）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface MouseEvent&amp;lt;T = Element&amp;gt; extends SyntheticEvent&amp;lt;T&amp;gt; {
  altKey: boolean;
  button: number;
  buttons: number;
  clientX: number;
  clientY: number;
  ctrlKey: boolean;
  getModifierState(key: string): boolean;
  metaKey: boolean;
  nativeEvent: NativeMouseEvent;
  pageX: number;
  pageY: number;
  relatedTarget: EventTarget;
  screenX: number;
  screenY: number;
  shiftKey: boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以针对上面的 JavaScript 代码，我们可以按如下的方式写出相应的 TypeScript 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import React, { MouseEvent, ReactNode } from &amp;quot;react&amp;quot;;
interface IProps {
  onClick(e: MouseEvent&amp;lt;HTMLElement&amp;gt;): void;
  children?: ReactNode;
}
const Button = ({ onClick: handleClick, children }: IProps) =&amp;gt; (
  &amp;lt;button onClick={handleClick}&amp;gt;{children}&amp;lt;/button&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;HTMLElement&lt;/code&gt; 被定义在&lt;code&gt;@types/react&lt;/code&gt; 中的&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Element {}
interface HTMLElement extends Element {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有状态组件&#34;&gt;有状态组件&lt;/h3&gt;

&lt;p&gt;无状态组件其实是一个函数，只需要按照函数的写法来实现即可。而对于有状态组件，这边有一个计数器的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;

import Button from &amp;quot;./Button&amp;quot;; // 这里的 Button 是上面 SFC 部分的 Button 组件

const initialState = { clicksCount: 0 };
type State = Readonly&amp;lt;typeof initialState&amp;gt;;

class ButtonCounter extends Component&amp;lt;object, State&amp;gt; {
  readonly state: State = initialState;

  public render() {
    const { clicksCount } = this.state;
    return (
      &amp;lt;&amp;gt;
        &amp;lt;Button onClick={this.handleIncrement}&amp;gt;Increment&amp;lt;/Button&amp;gt;
        &amp;lt;Button onClick={this.handleDecrement}&amp;gt;Decrement&amp;lt;/Button&amp;gt;
        You&#39;ve clicked me {clicksCount} times!
      &amp;lt;/&amp;gt;
    );
  }

  private handleIncrement = () =&amp;gt; this.setState(incrementClicksCount);
  private handleDecrement = () =&amp;gt; this.setState(decrementClicksCount);
}

const incrementClicksCount = (prevState: State) =&amp;gt; ({
  clicksCount: prevState.clicksCount + 1
});
const decrementClicksCount = (prevState: State) =&amp;gt; ({
  clicksCount: prevState.clicksCount - 1
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要读懂这段代码，可以从&lt;code&gt;@types/react&lt;/code&gt; 中的 &lt;code&gt;index.d.ts&lt;/code&gt;说起：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：以下代码都去除了大段的注释，若需要查看官方的注释请至 &lt;code&gt;npm install&lt;/code&gt; 后下载的 &lt;code&gt;./node_modules/@types/react&lt;/code&gt; 中查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Component&amp;lt;P = {}, S = {}, SS = any&amp;gt;
  extends ComponentLifecycle&amp;lt;P, S, SS&amp;gt; {}

class PureComponent&amp;lt;P = {}, S = {}, SS = any&amp;gt; extends Component&amp;lt;P, S, SS&amp;gt; {}

class Component&amp;lt;P, S&amp;gt; {
  constructor(props: Readonly&amp;lt;P&amp;gt;);
  setState&amp;lt;K extends keyof S&amp;gt;(
    state:
      | ((prevState: Readonly&amp;lt;S&amp;gt;, props: Readonly&amp;lt;P&amp;gt;) =&amp;gt; Pick&amp;lt;S, K&amp;gt; | S | null)
      | (Pick&amp;lt;S, K&amp;gt; | S | null),
    callback?: () =&amp;gt; void
  ): void;

  forceUpdate(callBack?: () =&amp;gt; void): void;
  render(): ReactNode;
  readonly props: Readonly&amp;lt;{ children?: ReactNode }&amp;gt; &amp;amp; Readonly&amp;lt;P&amp;gt;;
  state: Readonly&amp;lt;S&amp;gt;;
  context: any;
  refs: {
    [key: string]: ReactInstance;
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们常用的 Component 类就是在这里被定义的，其中 P 代表 props，S 代表 state。在这里我们可以发现，props 和 state 都使用了 readonly 或者是使用了 Mapped types 中的 Readonly。
而 Component 的 Interface 继承了 ComponentLifecycle 的 Interface，源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface &amp;lt;P, S, SS = any&amp;gt; extends NewLifecycle&amp;lt;P, S, SS&amp;gt;, DeprecatedLifecycle&amp;lt;P, S&amp;gt; {
	componentDidMount?(): void;
	shouldComponentUpdate?(nextProps: Readonly&amp;lt;P&amp;gt;, nextState: Readonly&amp;lt;S&amp;gt;, nextContext: any): boolean;
	componentWillUnmount?(): void;
	componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ComponentLifecycle 的 Interface 定义了一些常用的生命周期函数的类型如 componentDidMount、shouldComponentUpdate、componentWillUnmount 和 componentDidCatch。ComponentLifecycle 同样继承了 NewLifecycle 和 DeprecatedLifecycle 两个接口，代码分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface NewLifecycle&amp;lt;P, S, SS&amp;gt; {
  getSnapshotBeforeUpdate?(
    prevProps: Readonly&amp;lt;P&amp;gt;,
    prevState: Readonly&amp;lt;S&amp;gt;
  ): SS | null;
  componentDidUpdate?(
    prevProps: Readonly&amp;lt;P&amp;gt;,
    prevState: Readonly&amp;lt;S&amp;gt;,
    snapshot?: SS
  ): void;
}

interface DeprecatedLifecycle&amp;lt;P, S&amp;gt; {
  componentWillMount?(): void;
  UNSAFE_componentWillMount?(): void;
  componentWillReceiveProps?(nextProps: Readonly&amp;lt;P&amp;gt;, nextContext: any): void;
  UNSAFE_componentWillReceiveProps?(
    nextProps: Readonly&amp;lt;P&amp;gt;,
    nextContext: any
  ): void;
  componentWillUpdate?(
    nextProps: Readonly&amp;lt;P&amp;gt;,
    nextState: Readonly&amp;lt;S&amp;gt;,
    nextContext: any
  ): void;
  UNSAFE_componentWillUpdate?(
    nextProps: Readonly&amp;lt;P&amp;gt;,
    nextState: Readonly&amp;lt;S&amp;gt;,
    nextContext: any
  ): void;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NewLifecycle 是 React 16.3 新增的生命周期钩子，而 DeprecatedLifecycle 则是 React 16.3 之前常用的生命周期钩子，即将在未来版本被废弃。&lt;/p&gt;

&lt;p&gt;所以通过以上分析，我们可以知道，React 的 Class 继承于 &lt;code&gt;class Component&amp;lt;P, S&amp;gt;&lt;/code&gt;，而 &lt;code&gt;class Component&amp;lt;P, S&amp;gt;&lt;/code&gt; 是泛型 &lt;code&gt;interface Component&amp;lt;P = {}, S = {}, SS = any&amp;gt;&lt;/code&gt; 的实现。其中 P 是 props 的类型，S 是 state 的类型，它们都是 object 类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因此，TypeScript 的有状态组件大致可以按以下步骤来编写或者阅读：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置 initialState，并根据 initialState 来设定 State 类型或者 State 的 interface：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const initialState = { clicksCount: 0 };
type State = Readonly&amp;lt;typeof initialState&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用 type 或者 interface 设定 props 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class Example extends Component&amp;lt;P, S&amp;gt;&lt;/code&gt; 这里需要指定 props 和 state 的类型 P 和 S&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly state: State = initialState;&lt;/code&gt; 这里建议将 state 设置为 readonly 类型，防止 state 被直接修改&lt;/li&gt;
&lt;li&gt;生命周期方法可以使用 public 来修饰（tslint 要求 class 内部方法必须加入 public 或者 private 来修饰）&lt;/li&gt;
&lt;li&gt;内部方法可以使用 private 来修饰以保护其安全性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;小-tips&#34;&gt;小 Tips&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;从上面的 d.ts 文件的分析可以得知， &lt;code&gt;setState()&lt;/code&gt; 的具体逻辑是可以被提取到组件外部的，这样做的优点是可以将操作 state 的方法剥离出来维护，不需要了解渲染逻辑。&lt;/li&gt;
&lt;li&gt;在使用 mock 数据调试组件的时候，我们可以多用 any 类型来节约 React 组件调试时间成本，直至数据结构完全确定后，再编写完整的数据验证流程&lt;/li&gt;
&lt;li&gt;如果你想使用一个 package 但是遇到了找不到 @types 相关 package 的报错，可以到 Microsoft 的 &lt;a href=&#34;https://microsoft.github.io/TypeSearch/&#34;&gt;TypeScript Types Search&lt;/a&gt; 查询需要 &lt;code&gt;npm install&lt;/code&gt; 什么 package&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;h3 id=&#34;typescript-官方文档&#34;&gt;TypeScript 官方文档&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;英文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tslang.cn/&#34;&gt;中文版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ultimate-react-component-patterns-with-typescript-2-8&#34;&gt;Ultimate React Component Patterns with Typescript 2.8&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://levelup.gitconnected.com/ultimate-react-component-patterns-with-typescript-2-8-82990c516935&#34;&gt;英文原版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5b07caf16fb9a07aa83f2977&#34;&gt;蚂蚁金服技术团队翻译版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mpvue 小程序开发踩坑记</title>
      <link>https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/</guid>
      <description>

&lt;h1 id=&#34;mpvue-小程序开发踩坑记&#34;&gt;mpvue 小程序开发踩坑记&lt;/h1&gt;

&lt;p&gt;之前公司决定开发一款小程序。&lt;/p&gt;

&lt;p&gt;我接触微信小程序也就一两个月的时间，没使用过小程序官方的开发语言，而是直接使用 mpvue 上手了，自己开发了一个因为内容的原因无法上架的 DEMO。正好也被推上了前端部门的 leader，所以也就接下了这个任务。&lt;/p&gt;

&lt;p&gt;使用 mpvue 的因为本以为由 Vue 转小程序用 mpvue 会方便，不过没想到坑挺多的，一般的 Web 开发者如果以 Vue 的思维入手会遇到很多麻烦，因为小程序的运行环境和浏览器完全不同。&lt;/p&gt;

&lt;p&gt;另外京东凹凸实验室的 Taro 也是一个非常好的框架，不过我没有去深入研究它。考虑到公司技术栈转 Vue 的要求，我们团队选择了 mpvue，然而我个人认为 mpvue 还是个不太成熟的框架，文档不完善，在开发编译时也容易出 bug，另外就是分包加载的支持比较慢，好在最近出了新版本的 mpvue-loader。但是新版本的 mpvue-loader 完全更改了 app.json/main.json 文件的写法，文档中也没有明确提到，只能通过新的 quickstart 来了解新的写法。&lt;/p&gt;

&lt;h2 id=&#34;我对小程序和-mpvue-的理解&#34;&gt;我对小程序和 mpvue 的理解&lt;/h2&gt;

&lt;h3 id=&#34;mpvue&#34;&gt;mpvue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;mpvue 是美团开发的，允许开发者使用 Vue 语法来编写小程序的框架。&lt;/li&gt;
&lt;li&gt;小程序和 Web 应用的不同之处是它依靠微信 App 内的 JavaScript 引擎和 WXML/WXSS 引擎进行渲染，所以与 Web 端相比，小程序里不存在 DOM，无法使用原生 DOM 的操作，也不存在浏览器的各种 API。&lt;/li&gt;
&lt;li&gt;在使用 mpvue 时，实际上可以看作是用 Vue 构建多页 Web App。&lt;/li&gt;
&lt;li&gt;在 Webpack 打包时，Vue Web App 是最终打包成 index.html 以及 css 和 js 文件各 1 个（如果你不开 source map 的话）。而 mpvue-loader 是将 Vue 语法转换成小程序原生语法的 Webpack loader，打包后的文件实际上就是原生小程序的语法（js 除外），这样就可以在小程序开发工具中预览和 debug。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;weui&#34;&gt;weui&lt;/h3&gt;

&lt;p&gt;weui 是腾讯开发的 css 框架，可以用于编写腾讯规范的小程序控件。&lt;/p&gt;

&lt;h3 id=&#34;小程序开发工具-微信公众平台-小程序&#34;&gt;小程序开发工具/微信公众平台 - 小程序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;小程序开发工具是用于本地 debug 的工具，使用了 Chrome Devtools，并可以进行真机调试以及发布体验版

&lt;ul&gt;
&lt;li&gt;真机调试：使用小程序上的“远程调试”按钮即可调试，在开发者的微信中的小程序列表中显示为“开发版”&lt;/li&gt;
&lt;li&gt;体验版：使用小程序上的“上传”按钮即可发布体验版，开发者和体验者扫码后可以访问，在开发者和体验者的微信中的小程序列表中显示为“体验版”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;微信公众平台 - 小程序 是小程序项目的管理后台

&lt;ul&gt;
&lt;li&gt;小程序和公众号是两个独立的账号，可以相互关联&lt;/li&gt;
&lt;li&gt;如果要团队协作开发，必须要在微信公众平台上添加开发者和体验者&lt;/li&gt;
&lt;li&gt;若需要使用网络请求，必须在微信公众平台上添加 https 的服务器&lt;/li&gt;
&lt;li&gt;https 服务器的 URL 可以是二级、三级&amp;hellip;域名，但不能带相对路径，例如可以是 api.test.example.cn 或者 api.example.cn，但不能使用 api.example.com/v1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;微信支付&#34;&gt;微信支付&lt;/h2&gt;

&lt;p&gt;微信支付需要小程序上线之后在微信公众平台中申请开通。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&#34;&gt;【微信支付】微信小程序支付开发者文档&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取 openid&lt;/li&gt;
&lt;li&gt;请求支付接口获取 &lt;code&gt;wx.requestPayment()&lt;/code&gt; 所需参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wx.requestPayment()&lt;/code&gt; 发起支付请求，参数见&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/api-pay.html#wxrequestpaymentobject&#34;&gt;微信支付 · 小程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果在手机上操作会直接弹出微信支付相关弹窗，在开发者工具中操作则会生成二维码，扫描即可；在手机上可以直接弹出微信支付的弹窗。&lt;/li&gt;
&lt;li&gt;支付完成后使用 &lt;code&gt;wx.reLaunch&lt;/code&gt; 转跳到结果页面，但是使用 &lt;code&gt;wx.reLaunch&lt;/code&gt; 时，在 Android 上会提示 reLaunch:fail can not invoke reLaunch in background，此时只需加一个 setTimeout 即可。因为调用微信支付的窗口时，实际上会先把当前的 page 隐藏，如果在体验版里打开调试模式可以看到页面先 onHide 再 onShow，而我们需要在支付成功后转跳，所以 &lt;code&gt;wx.reLaunch&lt;/code&gt; 是放在 &lt;code&gt;wx.requestPayment()&lt;/code&gt; 的回调中执行的，此时页面仍没有 onShow，而 &lt;code&gt;wx.reLaunch&lt;/code&gt; 需要在 onShow 之后才能调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;mpvue-小程序开发中需要注意的点&#34;&gt;mpvue 小程序开发中需要注意的点&lt;/h2&gt;

&lt;h3 id=&#34;mpvue-的项目结构&#34;&gt;mpvue 的项目结构&lt;/h3&gt;

&lt;p&gt;我们可以在官方的 quickstart 模板的基础上进行开发【&lt;a href=&#34;http://mpvue.com/mpvue/quickstart/&#34;&gt;Quickstart - mpvue-docs&lt;/a&gt;】。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;static - 静态文件&lt;/li&gt;
&lt;li&gt;src - pages - A - 页面 A - A.vue - .vue 页面 - main.js - Vue 的 js 文件，用于挂载页面 - main.json - 小程序的页面配置文件 - components - 公用组件 - utils - 工具 - app.json - 小程序的 app.json 主文件 - App.vue - 小程序主入口 - main.js - 类似 Vue 的 main.js，加载全局内容，挂载 Vue 实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;小程序有包大小的限制&#34;&gt;小程序有包大小的限制&lt;/h3&gt;

&lt;p&gt;主包最大为 2MB，各个分包大小最大为 8MB。在较大型的小程序开发时，最好是将各个模块独立出来，尽可能只保留入口页面和 Tab 标签页对应的页面在主包中。&lt;/p&gt;

&lt;p&gt;分包加载只有在 mpvue-loader@1.1.x 版本才支持。&lt;/p&gt;

&lt;p&gt;会打包到主包的内容（包括但不限于如下内容）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;放在 app.json 中的 pages 中的页面&lt;/li&gt;
&lt;li&gt;静态文件，如图片&lt;/li&gt;
&lt;li&gt;公用组件&lt;/li&gt;
&lt;li&gt;vuex&lt;/li&gt;
&lt;li&gt;utils&lt;/li&gt;
&lt;li&gt;安装的各种有被引用的 package&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：千万不要因为某个功能用某个 package 做很方便，就安装并引入它，因为这些 package 全部会打包到主包的 vender.js 中！这样很容易造成主包大小过大！&lt;/p&gt;

&lt;p&gt;如果一个 package 是你不得不引入的核心 package（例如 vue, vuex, node-sass, sass-loader 等），那么就将它引入。&lt;/p&gt;

&lt;p&gt;如果一个 package 你只使用到它的 1% 的功能（或者有非常多的功能用不上），请不要引入！例如安装了 qs, moment 和 lodash 之后，在我们公司的项目中，打包后的 vender.js 最大可以达到 1.6MB，而在移除它们所有的引用之后只有 462 KB。&lt;/p&gt;

&lt;p&gt;JS 的大型工具库（如 lodash）千万不要引入 mpvue，因为它们大部分都可以简单地用原生 JS 实现。&lt;/p&gt;

&lt;p&gt;占用空间的静态图片尽可能使用在线资源。导航栏图标和各种 icon，为了用户体验，建议放在本地。&lt;/p&gt;

&lt;h3 id=&#34;小程序有页面栈的限制&#34;&gt;小程序有页面栈的限制&lt;/h3&gt;

&lt;p&gt;由于性能的限制，小程序页面栈中最多只能存在 5 个页面，也就是最多只能转跳 5 层。 此时就需要善用清空页面栈的方法，例如转跳的时候使用 redirectTo / relaunch 等方法。但是在页面栈被清空之后，小程序右上角的返回按钮就会消失，所以在产品设计时处理好转跳逻辑是很关键的。详情见小程序文档：&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/ui-navigate.html&#34;&gt;导航 · 小程序 API&lt;/a&gt;，&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html&#34;&gt;导航 · 小程序组件&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;小程序页面间传值&#34;&gt;小程序页面间传值&lt;/h3&gt;

&lt;p&gt;小程序页面间的传值靠的是路由的 params，类似于 vue-router 中的 params。在新页面中，若要接收值，则需要在 onLoad 生命周期中接收，onLoad 方法的第一个参数即为传入的 params 对象。&lt;/p&gt;

&lt;p&gt;注意：params 传值默认的数据类型是 String。&lt;/p&gt;

&lt;h3 id=&#34;返回时清空数据&#34;&gt;返回时清空数据&lt;/h3&gt;

&lt;p&gt;小程序在点击左上角返回的时候不能自动清空当前页面的数据，如果需要清空数据，我们需要手动在 onUnload 的生命周期钩子里将 Vue 的 data 中的所有数据还原成初始状态。&lt;/p&gt;

&lt;h3 id=&#34;返回上一页-上-x-页-时携带参数&#34;&gt;返回上一页（上 X 页）时携带参数&lt;/h3&gt;

&lt;p&gt;我们在返回时会使用 &lt;code&gt;wx.navigateBack()&lt;/code&gt;，这个方法不可携带参数。所以我们需要用小程序内置的 Storage 或者 Vuex 进行数据存取的操作。&lt;/p&gt;

&lt;p&gt;不建议/不应该使用其他可以带参数的导航方式，因为它们会破坏现有的页面栈或者导致页面栈混乱，除非有特殊的需求。&lt;/p&gt;

&lt;h3 id=&#34;小程序的生命周期&#34;&gt;小程序的生命周期&lt;/h3&gt;

&lt;p&gt;小程序有自己一套生命周期，和 Vue 的生命周期不冲突，但是行为有所区别。&lt;/p&gt;

&lt;p&gt;举例来说，一个页面加载时，这些生命周期钩子会按如下顺序被调用：onLoad, onShow, mounted。页面存在页面栈中时，如果返回该页面，不会触发 onLoad 和 mounted，但是会触发 onShow，因为这个页面已经被挂载了。
更多小程序生命周期的详情请看小程序的官方开发文档。&lt;/p&gt;

&lt;h3 id=&#34;网络请求&#34;&gt;网络请求&lt;/h3&gt;

&lt;p&gt;小程序中发起网络请求可以使用 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject&#34;&gt;wx.request()&lt;/a&gt;，也可以使用 &lt;a href=&#34;https://www.npmjs.com/package/flyio&#34;&gt;fly.io&lt;/a&gt;，一个类似 axios 的开源库。&lt;/p&gt;

&lt;h3 id=&#34;小程序的数据存储&#34;&gt;小程序的数据存储&lt;/h3&gt;

&lt;p&gt;在 Web 中我们有 session 和 WebStorage 可以存储一些公用数据如 token。而小程序有自己的本地缓存：&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/data.html&#34;&gt;数据缓存 · 小程序&lt;/a&gt;，用法和 WebStorage 相似，但是有同步和异步方法的区别。&lt;/p&gt;

&lt;p&gt;在 mpvue 中我们同样可以使用 vuex，但是需要注意的是我们无法像 Web 开发时一样在 &lt;code&gt;new Vue()&lt;/code&gt; 的时候传入 vuex 作为参数，而是需要手动挂载到 Vue.prototype 上。&lt;/p&gt;

&lt;h3 id=&#34;登录与授权&#34;&gt;登录与授权&lt;/h3&gt;

&lt;p&gt;微信的授权弹窗在目前版本中无法主动触发，需要用 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/component/button.html&#34;&gt;button 的 open-type 属性&lt;/a&gt; 获取授权。授权弹窗只能获取微信的用户信息。授权弹窗中有 encryptedData 和 iv，这两个数据很关键，可以让服务端解码出 unionId。unionId 是用户唯一标识，在第三方登录授权中需要使用到。&lt;/p&gt;

&lt;p&gt;如果需要微信开发者平台的第三方登录，需要使用 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html&#34;&gt;wx.login()&lt;/a&gt; 的方法获取 code，并发送给服务端处理，通过 code 可以获取 sessionKey 和 openid。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wx.login()&lt;/code&gt; 一定要在授权弹窗之前调用，因为解密 encryptedData 和 iv 需要 sessionKey，sessionKey 是从 code 获得的。在 &lt;code&gt;wx.login()&lt;/code&gt; 得到的 code（以及 code 获取的 sessionKey） 之后获取的 encryptedData 和 iv 是一一对应的，若颠倒顺序，则 encryptedData 和 iv 无法和 sessionKey 对应上。&lt;/p&gt;

&lt;h3 id=&#34;标签&#34;&gt;标签&lt;/h3&gt;

&lt;p&gt;mpvue 中可以使用 Web 的标签，最后会被编译成对应的小程序标签；也可以使用小程序的原生标签。小程序的原生标签可以帮助我们做很多 Web 标签无法实现的工作，例如 swiper 和 swiper-item 可以实现左滑右滑切换 Tab 页；scroll-view 实际上是一个 &lt;code&gt;overflow-(x/y): auto;&lt;/code&gt; 的块级元素，并且本身不带滚动条，但是注意 scroll-view 并不会触发 onReachBottom 的钩子。&lt;/p&gt;

&lt;h3 id=&#34;分页加载&#34;&gt;分页加载&lt;/h3&gt;

&lt;p&gt;分页加载有两种方式: onReachBottom 和 scroll-view&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 onReachBottom 时不能使用 scroll-view，只能使用普通的 view / div。scroll-view 使用 @scrolltolower (原生小程序是 bindscrolltolower) 的 event。&lt;/li&gt;
&lt;li&gt;包裹着列表组件的容器必须保证能滚动到屏幕底部，也就是说 CSS 里对高度的设置需要注意&lt;/li&gt;
&lt;li&gt;页面&lt;em&gt;组件中需要有变量记录当前页码或者下一页的页码，在触发 onReachBottom&lt;/em&gt;@scrolltolower 时使用这个页码去获取新的分页数据&lt;/li&gt;
&lt;li&gt;分页加载完成后，数据需要加到原列表数组的最后&lt;/li&gt;
&lt;li&gt;页面&lt;em&gt;组件中需要有变量记录总页数，在 onReachBottom&lt;/em&gt;@scrolltolower 时，如果已经到最后一页则不继续加载或者弹出提示&lt;/li&gt;
&lt;li&gt;在进行一些复杂操作的时候记得清空当前页码和总页数，防止数据混乱&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;图片&#34;&gt;图片&lt;/h3&gt;

&lt;p&gt;小程序中的 image 如果不手动设置大小，会默认被设置为 320*240 (rpx)。小程序中 image 的自适应和 Web 开发并不一样，使用的是 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/component/image.html&#34;&gt;image 的 mode 属性&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;小程序的 image 不支持 svg 的图片，需要用 css 的 background-image。&lt;/p&gt;

&lt;p&gt;app.json 中，TabBar 的 icon 不能用 svg。&lt;/p&gt;

&lt;p&gt;在 mpvue 中可以使用 iconfont。&lt;/p&gt;

&lt;h3 id=&#34;关于边框&#34;&gt;关于边框&lt;/h3&gt;

&lt;p&gt;mpvue-weui 和微信小程序的某写原生组件如 button 会有自带的边框，它们都是写在 &lt;code&gt;::after&lt;/code&gt; 伪元素中的，如果你使用 border-radius 的话，会导致某些边框消失。此时建议将其隐藏并重新用下面的 rpx 的方式来写边框。&lt;/p&gt;

&lt;h3 id=&#34;长度单位与-1-像素边框&#34;&gt;长度单位与 1 像素边框&lt;/h3&gt;

&lt;p&gt;按照从移动 H5 转过来的思维，1 像素边框一般需要用伪元素来写。小程序中同样可以使用 ::after 伪元素写 1 像素的边框，但是实际的显示出来的位置都和 Web 有区别。可以参考 &lt;a href=&#34;http://kuangpf.com/mpvue-weui/#/README&#34;&gt;mpvue-weui&lt;/a&gt; 的 weui.css 中的方式进行开发。&lt;/p&gt;

&lt;p&gt;但事实上，微信小程序的 rpx 就是自适应单位，相当于移动 H5 做自适应常用的 rem。1rpx = 0.5px = 1 物理像素。所以我们实际上可以使用 rpx 来写 1 像素边框。当然微信小程序也支持 rem，规定屏幕宽度为 20rem，所以 1rem = (屏幕宽度 / 20)rpx。&lt;/p&gt;

&lt;p&gt;button 在有 border-radius 的时候可能边框显示不全，此时建议用 div 包裹 button 并在 div 上写 1px 的 border，隐藏 button 自带的 border。&lt;/p&gt;

&lt;h3 id=&#34;position-fixed&#34;&gt;position: fixed&lt;/h3&gt;

&lt;p&gt;小程序的 position: fixed 和 Web 上的表现有所不同。如果 mpvue 小程序的页面中有其他 Vue 组件，那么在组件中设定的 &lt;code&gt;position: fixed&lt;/code&gt; 只会相对于这个组件是 fixed，并不会在页面中 fixed。如果设定 &lt;code&gt;bottom: 0&lt;/code&gt;，那么它只会固定在 Vue 组件的底部，而不是整个页面的底部。也就是说，mpvue 小程序中的 Vue 组件实际上是一个 BFC。&lt;/p&gt;

&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;

&lt;p&gt;mpvue 中同样有事件，但是调取参数 e 的值的方式和 Web 不同，需要使用 &lt;code&gt;e.mp.detail&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;点击导航条转跳到相应位置-类似通讯录&#34;&gt;点击导航条转跳到相应位置（类似通讯录）&lt;/h3&gt;

&lt;p&gt;在项目中，服务端只会给出所有的城市列表，之后我们需要在本地对其进行分类。按字母分类使用了 &lt;a href=&#34;https://github.com/hotoo/pinyin&#34;&gt;GitHub - hotoo/pinyin: 汉字拼音 ➜ hàn zì pīn yīn&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;页面分为侧边字母导航条和城市列表。项目的需求是只需要列出满足条件的部分城市，所以导航字母也需要根据城市动态显示。&lt;/p&gt;

&lt;p&gt;点击字母滚动到对应位置的功能使用了 scroll-view 的 scroll-into-view，在 scroll-into-view 上动态绑定对应字母的唯一 id（变量在 Vue 的 data 中），同时在我们渲染城市的时候，需要在最外层加上属性 id，与 scroll-into-view 上的 id 要对应。&lt;/p&gt;

&lt;p&gt;字母导航条中，我们需要设定一个 data-i，并在 click 事件中用 &lt;code&gt;e.currentTarget.dataset.i&lt;/code&gt; 获取这个 data-i，并赋值给 data 中绑定 id 的变量，这样就可以直接转跳到相应的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;city&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;city__body&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;current-city&amp;quot;&amp;gt;当前定位城市：{{ city.city }}&amp;lt;/div&amp;gt;
      &amp;lt;scroll-view scroll-y class=&amp;quot;alphabet&amp;quot; :scroll-into-view=&amp;quot;&#39;id-&#39; + toView&amp;quot;&amp;gt;
        &amp;lt;div
          :id=&amp;quot;&#39;id-&#39; + index&amp;quot;
          v-for=&amp;quot;(item, index) in filteredCities&amp;quot;
          :key=&amp;quot;item.firstLetter + index&amp;quot;
        &amp;gt;
          &amp;lt;div class=&amp;quot;weui-cells__title&amp;quot;&amp;gt;{{ item.firstLetter }}&amp;lt;/div&amp;gt;
          &amp;lt;div class=&amp;quot;weui-cells weui-cells_after-title&amp;quot;&amp;gt;
            &amp;lt;div
              class=&amp;quot;weui-cell&amp;quot;
              v-for=&amp;quot;(_item, _index) in item.cities&amp;quot;
              :key=&amp;quot;_item.cityCode + _index&amp;quot;
              @click=&amp;quot;setCity(_item)&amp;quot;
            &amp;gt;
              &amp;lt;div class=&amp;quot;weui-cell__bd&amp;quot;&amp;gt;{{ _item.city }}&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/scroll-view&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;city__letters&amp;quot;&amp;gt;
      &amp;lt;div
        v-for=&amp;quot;(item, index) in nav&amp;quot;
        :key=&amp;quot;item&amp;quot;
        @click=&amp;quot;setAlphabet&amp;quot;
        :data-i=&amp;quot;index&amp;quot;
      &amp;gt;
        {{item}}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script&amp;gt;
export default {
	data() {
    return {
      nav: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;],
      toView: 0,
      cities: []
    }
  },
	onLoad() {
	  // 获取城市
	  getCity().then(res =&amp;gt; {
      if (/* 调用成功 */) {
        const categoriedCities = []
        const cities = []
        let nav = []
        for (const item of res.data.data) {
          // 提取城市首字母，放入导航列表
          const py = pinyin(item.city, { style: pinyin.STYLE_FIRST_LETTER })
          const firstLetter = py[0][0].toUpperCase()
          if (firstLetter.length === 1) {
            nav.push(firstLetter)
          }
          // 构造新的数据，加入首字母
          const newItem = {
            ...item,
            firstLetter,
            city: item.city.substring(0, item.city.length - 1)
          }
          cities.push(newItem)
        }
        // 导航里去除重复的字母
        nav = [...new Set(nav)]
        // 根据导航的字母，把上面构造的数据按照字母进行重新分类，得到最后需要的结果
        // 对每个字母，在上面构造的数据中筛选出相应字母的所有城市，放入一个对象中并 push 入最终数组
        for (const item of nav) {
          const sameLetterCities = cities.filter(i =&amp;gt; i.firstLetter === item)
          categoriedCities.push({
            firstLetter: item,
            cities: sameLetterCities
          })
        }
        this.nav = nav
        this.cities = categoriedCities
      }
    })
	}
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于域名和备案</title>
      <link>https://elizurhz.cn/ops/domain-and-website-approve/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/ops/domain-and-website-approve/</guid>
      <description>

&lt;h1 id=&#34;关于域名和备案&#34;&gt;关于域名和备案&lt;/h1&gt;

&lt;p&gt;我本人主要也只做过个人备案，做博客和个人展示页面，所以不大了解企业备案，能提供的信息也有限。&lt;/p&gt;

&lt;h2 id=&#34;域名&#34;&gt;域名&lt;/h2&gt;

&lt;h2 id=&#34;icp-备案&#34;&gt;ICP 备案&lt;/h2&gt;

&lt;p&gt;ICP 备案可以直接在阿里云或者其他平台上提供的备案服务中进行。&lt;/p&gt;

&lt;p&gt;所有 DNS 指向国内节点服务器的域名都需要进行 ICP 备案，如果不备案无法正常访问。如果是指向海外节点（包括港澳台），就可以不需要备案。&lt;/p&gt;

&lt;p&gt;个人备案对网站名的要求挺严格的，不能涉及行业信息，不能带域名中的关键字等等。&lt;/p&gt;

&lt;p&gt;个人备案有网站内容的限制，一般流量小的话是不会被发现，我是第一次完成备案后想要备案第二个域名，阿里云方面顺便告知我之前那个不行要下架整改。。。&lt;/p&gt;

&lt;h2 id=&#34;公安备案&#34;&gt;公安备案&lt;/h2&gt;

&lt;p&gt;这个没有什么需要注意的，只需要上公安备案的网站按流程操作就可以了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前后端分离项目在阿里云/七牛云的简单部署</title>
      <link>https://elizurhz.cn/ops/c-s-ops/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/ops/c-s-ops/</guid>
      <description>

&lt;h1 id=&#34;前后端分离项目在阿里云-七牛云的简单部署&#34;&gt;前后端分离项目在阿里云/七牛云的简单部署&lt;/h1&gt;

&lt;h2 id=&#34;购买主机&#34;&gt;购买主机&lt;/h2&gt;

&lt;p&gt;我购买了两台主机，都是的是 1 核 + 1GHz + 1Mbps 的配置，系统一台是为 Ubuntu 14.04，另一台是 CentOS 7.4。直连实测 700 多 KB 的 Webpack 生产打包后的 React 的 js 文件需要十多秒才能加载，速度大约 60KB/s。&lt;/p&gt;

&lt;h2 id=&#34;启动实例&#34;&gt;启动实例&lt;/h2&gt;

&lt;p&gt;购买后实例是自动启动的，但是需要进行一些初始化的设置。&lt;/p&gt;

&lt;p&gt;进入 ECS 的实例页面，首先如果需要从控制台远程连接，阿里云会提供一个远程连接密码，这个密码需要记住，每次从控制台远程连接时会需要。&lt;/p&gt;

&lt;p&gt;我们正常的开发一般是从 Terminal 或者 FileZilla 等 SFTP 客户端去连接服务器，为了进行此操作，我们需要设置初始密码。控制台的实例页面点击 “更多” =&amp;gt; “密码/密钥” =&amp;gt; “重置密码” 即可重置 Linux 登录密码，也是 ssh 的密码。重置后我们就可以使用刚刚输入的密码，通过 &lt;code&gt;ssh root@${yourServerIp}&lt;/code&gt; 登陆。如果你已经在购买的 ECS 时候设置了密码或者密钥，那可以不需要在此设置密码。&lt;/p&gt;

&lt;p&gt;而 FileZilla 也是一样，建立一个 SFTP 连接，使用用户 root 和更改好的密码即可。&lt;/p&gt;

&lt;h2 id=&#34;系统配置&#34;&gt;系统配置&lt;/h2&gt;

&lt;p&gt;首先我们需要把包管理器源替换成国内的源，Ubuntu 的 apt 可以使用清华的源，CentOS 的 yum 可以使用阿里云的源。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ubuntu&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /etc/apt/
sudo cp sources.list sources.list.bak  # 备份 source.list
sudo vim sources.list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着将 source.list 中的源替换为清华的源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，更新源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get update # 更新源
sudo apt-get upgrade # 更新软件
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;CentOS&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /etc/yum.repos.d/
wget http://mirrors.aliyun.com/repo/Centos-7.repo # 下载 repo
mv CentOs-Base.repo CentOs-Base.repo.bak # 备份
mv Centos-7.repo CentOs-Base.repo # 替换
# 更新
yum clean all
yum makecache
yum update
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-nginx&#34;&gt;安装 nginx&lt;/h3&gt;

&lt;p&gt;需要安装的依赖：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcc gcc-c++&lt;/li&gt;
&lt;li&gt;pcre&lt;/li&gt;
&lt;li&gt;openssl&lt;/li&gt;
&lt;li&gt;zlib&lt;/li&gt;
&lt;li&gt;zlib-devel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上可以都用 yum 安装。安装完成之后 &lt;code&gt;yum install -y nginx&lt;/code&gt; 即可成功安装 nginx。如果以上依赖未完全安装，在安装 nginx 时则会提示某个包未安装。&lt;/p&gt;

&lt;h3 id=&#34;配置-nginx&#34;&gt;配置 Nginx&lt;/h3&gt;

&lt;p&gt;根据版本的不同，nginx 的配置文件可以放在 site-enable 或者 conf.d 中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代理端口、域名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;try_files&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;https&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SSL 证书&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强制转写为 https&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强制转跳
例如一级域名转跳到 www 二级域名&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;部署服务端&#34;&gt;部署服务端&lt;/h3&gt;

&lt;p&gt;我的项目服务端用的是 Koa2，托管在 bitbucket 上。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从 bitbucket 上将项目拉取下来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install&lt;/code&gt; 安装需要的 npm packages。&lt;/li&gt;
&lt;li&gt;通过 pm2 启动服务，我的项目用的是 Koa2 的脚手架，使用命令 &lt;code&gt;pm2 start ./bin/www --watch&lt;/code&gt; 即可。&lt;/li&gt;
&lt;li&gt;可以通过 &lt;code&gt;pm2 list&lt;/code&gt; 查看正在运行的服务，例如我有部署多个后端服务；通过 &lt;code&gt;pm2 describe ${id}&lt;/code&gt; 和 &lt;code&gt;pm2 show ${id}&lt;/code&gt; 可以查看某个服务的详情。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;mongodb&#34;&gt;MongoDB&lt;/h3&gt;

&lt;p&gt;如果需要在本机（非服务器所在内网）测试访问 MongoDB，则需要修改 MonogoDB 配置。&lt;/p&gt;

&lt;h2 id=&#34;云解析-dns&#34;&gt;云解析 DNS&lt;/h2&gt;

&lt;h2 id=&#34;安全组&#34;&gt;安全组&lt;/h2&gt;

&lt;h2 id=&#34;ssl&#34;&gt;SSL&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>前后端分离项目的容器化</title>
      <link>https://elizurhz.cn/ops/docker-ops/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/ops/docker-ops/</guid>
      <description>

&lt;h1 id=&#34;前后端分离项目的容器化&#34;&gt;前后端分离项目的容器化&lt;/h1&gt;

&lt;h2 id=&#34;docker&#34;&gt;docker&lt;/h2&gt;

&lt;p&gt;CentOS 7 上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install -y docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基本命令&#34;&gt;基本命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker images # 列出当前本地所有的 docker 镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker search [docker-name] # 在 docker hub 中搜索镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull [docker-name] # 在 docker hub 中拉取镜像到本机
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run \ # 启动镜像
-d \ # --detach
-h example.com  \ # --hostname，主机
-p 8443:443 -p 8888:80 -p 2222:22 \ # --publish 端口，格式：本机端口:容器端口，将容器端口映射到本机端口
--name example \ # 容器的名字
-e XXX=xxx \ # 指定环境变量
-v /your/local/path:/your/image/path \ # --volume，格式：本机路径:容器路径，挂载卷，可以使本机的目录和容器中的目录互通、同步，可以用于持久化容器数据
[docker-name] # 镜像名字，如 mysql, gitlab/gitlab-ce 等
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker ps # 查看所有已创建的镜像
docker ps -a # 查看所有运行中的镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker start/stop/restart/rm [container id/container name] # 启动、停止、重启、删除某个容器，可以使用容器 id 或者容器名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容器在 docker run 之后会在 &lt;code&gt;docker ps -a&lt;/code&gt; 的列表中，如果需要重新运行这个容器，必须先停止它再 rm。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 React 中使用防抖动</title>
      <link>https://elizurhz.cn/frontend/react-debounce/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/react-debounce/</guid>
      <description>

&lt;h1 id=&#34;在-react-中使用防抖动&#34;&gt;在 React 中使用防抖动&lt;/h1&gt;

&lt;h2 id=&#34;什么是防抖动&#34;&gt;什么是防抖动&lt;/h2&gt;

&lt;p&gt;防抖动其实就是保证在事件发生后的固定时间内，如果再触发该事件，则重新计算延时，直到这段延时内没有再次触发事件，则执行用户自定的函数。&lt;/p&gt;

&lt;p&gt;更进一步说，防抖动分为立即执行和非立即执行，立即执行的运作方式有所不同，它是会先执行用户自定的函数，若在一段延时内未再触发该事件，则触发该事件才能再次执行函数；在该延时内触发的事件不执行函数，且重新计算延时。&lt;/p&gt;

&lt;h3 id=&#34;基础版&#34;&gt;基础版&lt;/h3&gt;

&lt;p&gt;关于防抖动的详情和具体实现，网上很多文章应该都介绍过了，这里不赘述，推荐一篇看过的应该是最好的文章：&lt;a href=&#34;https://juejin.im/post/5b651dc15188251aa30c8669&#34;&gt;函数防抖和节流 - 掘金&lt;/a&gt; 。不过这种代码实现比较“传统”，使用的是 ES5 和闭包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function debounce(func, wait) {
  var timeout;

  return function () {
    var context = this;
    var args = arguments;

    if (timeout) clearTimeout(timeout);

    timeout = setTimeout(function(){
      func.apply(context, args)
    }, wait);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是按照上面的 ES5 + 闭包的形式编写 debounce 函数，那么使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function print(value) {
  console.log(value)
}

debounce(print, 100)(&#39;123&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是 &lt;a href=&#34;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/debounce.js&#34;&gt;lodash&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/jashkenas/underscore/blob/d5fe0fd4060f13b40608cb9d92eda6d857e8752c/underscore.js#L887&#34;&gt;underscore&lt;/a&gt; 中 debounce 的实现与使用方式。&lt;/p&gt;

&lt;h3 id=&#34;进阶版&#34;&gt;进阶版&lt;/h3&gt;

&lt;p&gt;当然，我们也可以使用 Promise 来实现防抖动，参考：&lt;a href=&#34;https://juejin.im/post/5bdb155b5188257f62136ce8&#34;&gt;理解函数防抖 Debounce - 掘金&lt;/a&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function debounce(method, wait, immediate) {
  let timeout
  let result
  let debounced = function(...args) {
    return new Promise(resolve =&amp;gt; {
      let context = this
      if (timeout) {
        clearTimeout(timeout)
      }
      if (immediate) {
        let callNow = !timeout
        timeout = setTimeout(() =&amp;gt; {
          timeout = null
        }, wait)
        if (callNow) {
          result = method.apply(context, args)
          resolve(result)
        }
      } else {
        timeout = setTimeout(() =&amp;gt; {
          result = method.apply(context, args)
          resolve(result)
        }, wait)
      }
    })
  }

  debounced.cancel = function() {
    clearTimeout(timeout)
    timeout = null
  }

  return debounced
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function print(value) {
  return value
}

let debouncedFn = debounce(print, 1000, false)

debouncedFn(&#39;wtf&#39;).then(val =&amp;gt; {
  console.log(val)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;react-中的防抖动&#34;&gt;React 中的防抖动&lt;/h2&gt;

&lt;p&gt;在 React 中，我们经常会需要在虚拟 DOM 上添加事件，比如最常用的 button 的 onClick 以及 input 的 onChange。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class Test extends React.Component {
  onInputChange = (e) =&amp;gt; {
    console.log(e.target.value)
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;input onChange={this.onInputChange} /&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如有如上所示的一个组件，如果我们想实现 debounce 触发 onChange 的话，我们需要这么写（假设以上面的 Promise 版本作为组件中的 debounce 函数）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class Test extends React.Component {
  constructor(props) {
    super(props)
    this.debounceInputChange = debounce(this.onInputChange, 666, false)
  }

  onInputChange = (e) =&amp;gt; {
    console.log(e.target.value)
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;input onChange={this.debounceInputChange} /&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class Test extends React.Component {
  onInputChange = debounce((e) =&amp;gt; {
    console.log(e.target.value)
  }, 666, false)

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;input onChange={this.onInputChange} /&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不可以写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class Test extends React.Component {
  onInputChange = (e) =&amp;gt; {
    debounce(this.requestAPI(), 666, false)
  }

  requestAPI = () =&amp;gt; {
    // some API request
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;input onChange={this.onInputChange} /&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要在输入的时候防抖动请求服务端数据，这样写的结果就是仍然每次输入都会触发 input 的 onChange 事件，并且每次都会向服务端发出请求，只是每个请求会在 666 ms 的延时之后依次执行。&lt;/p&gt;

&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;

&lt;p&gt;React 中的事件都是&lt;a href=&#34;https://reactjs.org/docs/events.html&#34;&gt;合成事件（SyntheticEvent）&lt;/a&gt;，而合成事件有个特性是 &lt;a href=&#34;https://reactjs.org/docs/events.html#event-pooling&#34;&gt;Event Pooling&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;简单说就是在使用 debounce 函数之后 event 对象的所有属性都会变成 null。这时只要在代码前面加入 &lt;code&gt;e.persist()&lt;/code&gt; 即可移除合成事件，这样在 debounce 包装之后，函数仍然可以获取到 event 对象。&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;PS&lt;/h2&gt;

&lt;p&gt;在我使用百度地图的 localSearch 时，我将 setState 放在了它的 JSONP Callback 中，这样 debounce 也无法解决返回顺序不一致的问题。同时如果进行快速输入，触发和数据返回的时间可能也不太一样。所以当遇到有服务端请求的并且需要使用 debounce 来对触发事件进行防抖动时，最好加入一个判断，当服务端返回值和请求值能对应上时才 setState。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>掘金翻译计划</title>
      <link>https://elizurhz.cn/translation/translation/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/translation/translation/</guid>
      <description>&lt;p&gt;掘金翻译计划译者 from 2018.12.20&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5c1cdaaa6fb9a049aa6f0f8b&#34;&gt;【译】 用 React 和 Node.js 实现受保护的路由和权限验证 - 掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5c260f13e51d45473a5c07a4&#34;&gt;【译】 2019 年你应该要知道的 11 个 React UI 组件库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5c3cbb91e51d4550932771ce&#34;&gt;【译】 2019 年值得学习的顶级 JavaScript 框架与主题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>用 IntelliJ IDEA 配置 Maven Project 并使用 Tomcat 在本机运行</title>
      <link>https://elizurhz.cn/backend/maven-tomcat-idea/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/backend/maven-tomcat-idea/</guid>
      <description>

&lt;h1 id=&#34;用-intellij-idea-配置-maven-project-并使用-tomcat-在本机运行&#34;&gt;用 IntelliJ IDEA 配置 Maven Project 并使用 Tomcat 在本机运行&lt;/h1&gt;

&lt;p&gt;作为一个前端开发，时不时会参与维护一些老的前后端未分离的项目，而服务端渲染的老项目大多还是以 Java 为主，这样就起码需要懂得怎样配置项目，怎样起服务，否则天天需要服务端的同学帮忙岂不是很麻烦。&lt;/p&gt;

&lt;h2 id=&#34;java-环境&#34;&gt;Java 环境&lt;/h2&gt;

&lt;p&gt;首先上官网下载 JDK，然后安装。我这里使用 1.8 的版本，因为太高版本好像不支持。&lt;/p&gt;

&lt;p&gt;然后下载 IntelliJ IDEA。&lt;/p&gt;

&lt;p&gt;接着打开项目。这里以 Windows 10 为例（公司内网服务只能用有线连接的台式机访问很蛋疼不能用 Mac 开发）。首先 File =&amp;gt; New =&amp;gt; Project from Existing Sources&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/open.png&#34; alt=&#34;open&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后选择项目并使用默认配置即可。&lt;/p&gt;

&lt;h2 id=&#34;配置-maven&#34;&gt;配置 Maven&lt;/h2&gt;

&lt;p&gt;点开右侧栏中的 Maven Projects，点击设置按钮&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/maven-1.png&#34; alt=&#34;maven-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按如图所示选择 Maven home directory（内有相应的依赖配置）。另外在 User settings file 右侧勾选 override，然后选择 Maven home directory 中的 &lt;code&gt;/conf/settings.xml&lt;/code&gt; 文件。然后 Apply 即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/maven-2.jpg&#34; alt=&#34;maven-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着右下角会提示你是否需要 Import，选择 Import 即可。或者你可以在 Maven 面板中先双击 clean，然后再双击 install。这一步会完成 Maven 依赖的安装。&lt;/p&gt;

&lt;h2 id=&#34;配置-tomcat&#34;&gt;配置 Tomcat&lt;/h2&gt;

&lt;p&gt;首先找到右上角的工具栏，红框所示位置如果你没有配置 Tomcat，会显示 Add Configuration。点击这里即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/tomcat-1.png&#34; alt=&#34;tomcat-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后点击 ➕ ，找到 Tomcat Server，添加 Local。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/tomcat-2.png&#34; alt=&#34;tomcat-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着我们需要配置 Tomcat home。点击面板右侧的 Application server 右侧的 &lt;code&gt;Configure...&lt;/code&gt;，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/tomcat-3.png&#34; alt=&#34;tomcat-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;配置 Tomcat home，选择你下好的 Tomcat 的包的根目录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/tomcat-4.jpg&#34; alt=&#34;tomcat-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着切换到 Deployment 标签，➕ =&amp;gt; Artifact&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/tomcat-5.png&#34; alt=&#34;tomcat-5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里你可以看到当前可用的 war 包，选择“war exploded”的那个，然后点 OK，Apply。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/maven-tomcat-idea/tomcat-6.png&#34; alt=&#34;tomcat-6&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后点击右上角的 Debug（虫子）按钮，等待 Tomcat 服务器启动即可。IntelliJ IDEA 会在你指定的浏览器里自动打开你配置的那个本地地址，在那里即可访问你做好的模板页面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://elizurhz.cn/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/about/</guid>
      <description>

&lt;h2 id=&#34;about-the-blog-s-name&#34;&gt;About the Blog&amp;rsquo;s Name&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://i.y.qq.com/v8/playsong.html?songid=218828571&amp;amp;source=yqq#wechat_redirect&#34;&gt;라비앙로즈 (La Vie en Rose) - IZ*ONE (아이즈원)&lt;/a&gt;：玫瑰人生。&lt;/p&gt;

&lt;p&gt;因此受到启发而产生的名字。&lt;/p&gt;

&lt;h2 id=&#34;me&#34;&gt;Me&lt;/h2&gt;

&lt;h3 id=&#34;intro&#34;&gt;Intro&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript 全栈&lt;/li&gt;
&lt;li&gt;主 React，兴趣 Node.js &amp;amp; 移动开发&lt;/li&gt;
&lt;li&gt;全平台主机游戏玩家&lt;/li&gt;
&lt;li&gt;数码玩家&lt;/li&gt;
&lt;li&gt;HiFi 发烧友&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;education&#34;&gt;Education&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2010.09 ~ 2014.06 福州大学物流管理专业学士&lt;/li&gt;
&lt;li&gt;2015.03 ~ 2016.12 Master of Information Technology @ The University of Queensland, Major in Data Mining&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;career&#34;&gt;Career&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2017.03 开始第一份工作&lt;/li&gt;
&lt;li&gt;2018.09 入职 &lt;a href=&#34;http://www.nd.com.cn&#34;&gt;网龙&lt;/a&gt; @ 厦门&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;open-source-contribution&#34;&gt;Open Source Contribution&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;掘金翻译计划译者 from 2018.12.20&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;contact&#34;&gt;Contact&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ElizurHz&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://weibo.com/1955273297&#34;&gt;微博&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/%E7%9A%93%E6%B3%BD-%E5%BE%90-88877090/&#34;&gt;LinkedIn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Email: elizurhz@gmail.com&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>