<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Variation Palladion - 撕裂时间的帕拉迪昂 on Variation Palladion - 撕裂时间的帕拉迪昂</title>
    <link>https://elizurhz.cn/</link>
    <description>Recent content in Variation Palladion - 撕裂时间的帕拉迪昂 on Variation Palladion - 撕裂时间的帕拉迪昂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 10 Dec 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Apple M1 对前端开发者有什么影响</title>
      <link>https://elizurhz.cn/tips/apple-m1-for-fe/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/tips/apple-m1-for-fe/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇文章主要是从我最近微博动态等提取的观点整合成的一份总结，就不详细附图了，有兴趣可以关注下我的微博，在顶部导航栏的“About”中有，可能写得更详细，不过个人情绪也比较多，可能没有这篇文章来得客观。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近入手了 M1 Mac mini，低配加到 16G 内存，就迫不及待拿来尝试。目前从前端的角度来说，基本是正面的。&lt;/p&gt;

&lt;p&gt;硬件上就不多说了，M1 有计算能力、内存带宽、SSD 速度、功耗、发热等方面的优势，总体体验是好于 Intel 不少的。&lt;/p&gt;

&lt;p&gt;软件上可能有很多人担心兼容性问题。就前端来说，其实完全是可解决的问题。首先前端依赖的工具主要是 Node.js、文本编辑器（非 IDE，如 VSCode）以及 npm 生态。Node.js 是可以通过 Rosetta 2 安装及运行的，ARM 版正在研发中。VSCode 同样，不过 Insider 版本已经有 ARM 的支持了。至于 npm 这个就很不好说了，大部分包其实都是可以直接 import/require 的 js 文件，并没有环境依赖，然而还是有少部分怪异的包，比如我们非常常用的 node-sass，它在安装的时候需要根据你本机环境来编译，因为开发者尚未适配，所以无法识别当前 environment，这时你只能手动编译，需要利用 unix 的 arch 指令，加上前缀 arch -x86_64 运行 npm rebuild node-sass。&lt;/p&gt;

&lt;p&gt;说到 arch -x86_64，它在 ARM 的 macOS 上其实可以起到一种“欺骗”的作用，让你的命令完全通过 Rosetta 2 以 Intel 的兼容模式运行。homebrew 就是很好的例子，开发者尚未兼容时可以使用它来安装。不过其实没必要滥用，只需要在遇到不适配的时候使用即可。&lt;/p&gt;

&lt;p&gt;那么 M1 在实际开发中有什么优势呢。前端在开发中需要高性能计算的场景其实不多，除非是有特殊功能需求。比较常见的情况是跑单元测试，由于 Jest 是会占满所有 CPU 物理核心的，所以这还是可以一定程度上从前端角度来评价的。实际结果大概是，接近 800 个 case，M1 比近两年内的 Intel 的 Mac 要快上 10 秒左右，而且还能同时做别的事（Intel 机型会变卡甚至可能就卡得做不了别的事了）。&lt;/p&gt;

&lt;p&gt;那么缺点还是有的，一是雷电口都只有两个，二是 GPU 性能。GPU 要打目前的中高端独显是不可能的，但是其实前端开发中用不到这些。比较大的影响就是视频输出能力，Intel 的机型特别是带独显的，输出三四个非 4K 分辨率是没什么问题，但是 M1 最多只能支持 2 个屏幕（包括内建的），也就是 MacBook 只能外接一个，Mac mini 可以两个但是必须 HDMI + USB-C（双 C 还真的不行[流汗 2]）。众所周知显示器数量和生产力成正比关系，所以这可能是个问题。不过如果有 iPad Pro 或者 iPad Air 4 的话还可以用随航接一个。&lt;/p&gt;

&lt;p&gt;尽管有影响生产力的小问题，总体来说我对它的评价还是正面的，可以立即入手作为生产力，外接显示器的问题甚至你想为它改变你的工作流我觉得也是值的。&lt;/p&gt;

&lt;p&gt;所以我已经下单准备把我以前的主力工作机 18 款 15 寸低配 MacBook Pro 拿去回收折抵换一台新的低配版 M1 MacBook Air 了，当然还是加到 16G 内存。8G 我觉得是不够用的，因为我在使用 16G 的 Mac mini 进行开发的时候经常会遇到剩余 5G 左右的情况，Chrome 和 Node 都非常吃内存，所以 8G 内存应该会非常卡。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apollo GraphQL 在 React 中的应用</title>
      <link>https://elizurhz.cn/frontend/apollo-react/</link>
      <pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/apollo-react/</guid>
      <description>

&lt;p&gt;这篇文章大概介绍下 GraphQL 的使用，Apollo 的使用，以及我在项目中遇到的一些场景和情况。&lt;/p&gt;

&lt;p&gt;Apollo 是生产级的 GraphQL 框架（官方简介）。那么我使用 Apollo 的契机是，我们项目的后端（美国团队）已经长期在使用 GraphQL。在这个项目初期，后端是有提供 SDK 给部分接口的，但是后来由于业务的发展，我们还是全部接入 GraphQL，因为他们的很多服务都是提供 GraphQL 的 endpoint 的，封装成 SDK 相对困难。&lt;/p&gt;

&lt;h2 id=&#34;graphql&#34;&gt;GraphQL&lt;/h2&gt;

&lt;p&gt;注：本节示例代码大多来自于 &lt;a href=&#34;https://graphql.org/&#34;&gt;GraphQL 官网&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;提到 GraphQL，不明白的人可能会联想到 SQL。这确实没错，GraphQL 本身就是一种 query language。在 Apollo 中，我们需要借助 &lt;code&gt;gql&lt;/code&gt; 这个包来写 queries 和 mutations。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;import gql from &#39;graphql-tag&#39;

const SAMPLE_QUERY = gql`
  {
    hero {
      name
      height
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的是不需要传入任何参数的 query。而我们知道，大部分接口都需要参数，所以使用 &lt;code&gt;gql&lt;/code&gt; 包我们需要这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const SAMPLE_QUERY_WITH_VARIABLES = gql`
  query HeroNameAndFriends($episode: Episode) {
    hero(episode: $episode) {
      name
      friends {
        name
      }
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HeroNameAndFriends&lt;/code&gt; 在 GraphQL 里叫做 &lt;code&gt;operation name&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而在 GraphQL 中我们还会有一种常用的模式就是 Fragments。以官网的代码为例，使用 &lt;code&gt;gql&lt;/code&gt; 包我们需要这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const sampleFragments = {
  fragments: {
    entry: gql`
      fragment comparisonFields on Character {
        name
        appearsIn
        friends {
          name
        }
      }
    `
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fragments 可以用来定义重复使用的一种数据结构，这样我们可以不需要重复定义这些 schema。假设有个适用场景是用户管理系统，用户有一系列共有的属性，我们就可以将其定义为 Fragments。在进行各种 queries 和 mutations 的时候，例如请求用户列表、修改用户信息等等，我们就可以直接引用这个 Fragments，而不用重复写这段 schema，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const SAMPLE_QUERY_WITH_FRAGMENTS = gql`
  query findHero($episode: Episode) {
    leftComparison: hero(episode: $episode) {
      ...comparisonFields
    }
    rightComparison: hero(episode: $episode) {
      ...comparisonFields
    }
  }
  ${sampleFragments.fragments.entry}
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mutations 的写法和 query 非常相似，只需要把 &lt;code&gt;query&lt;/code&gt; 关键字换成 &lt;code&gt;mutation&lt;/code&gt; 即可。
这里非常容易遇到变量名字写错等等问题，写的时候还需要仔细参考模板。
另外关于 GraphQL 中的类型，例如上面示例代码中的 &lt;code&gt;Episode&lt;/code&gt; 和 &lt;code&gt;Character&lt;/code&gt;，这个一般是在后端定义的。至于如何获取类型名，这个后端是会在 endpoint 提供一个 playground 来显示有哪些 queries 哪些 mutations 可用的，包括需要传的参数都会写出来，也就相当于一个 API 文档。我们也可以在 playground 上测试我们的 queries 和 mutations 有没有写对。另外关于参数和类型，带感叹号的就是必传参数，其他并没有太多需要注意的地方。&lt;/p&gt;

&lt;h2 id=&#34;apollo&#34;&gt;Apollo&lt;/h2&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;注：本节示例代码主要来自于 &lt;a href=&#34;https://www.apollographql.com/&#34;&gt;Apollo 官网&lt;/a&gt;，以 3.0beta 版本的 API 为准。&lt;/p&gt;

&lt;p&gt;上面简单介绍了下怎样写 queries 和 mutations，但是我们需要一个工具来发起 GraphQL 请求。在 React 中，除了 Apollo，还有 Facebook 做的 Relay。我没用过 Relay，但是看评价是说它比较“重”。本文就着重介绍 Apollo。&lt;/p&gt;

&lt;p&gt;Apollo 是个工具，它有各端的实现，而在 React 端它可以以组件的形式存在于 App 中。要使用 Apollo，我们需要先做两件事：写创建 &lt;code&gt;ApolloClient&lt;/code&gt; 的代码，和将 &lt;code&gt;ApolloProvider&lt;/code&gt; 加入到组件树中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;/** apolloClient.js */
import { ApolloClient } from &#39;apollo-client&#39;;
import { InMemoryCache } from &#39;apollo-cache-inmemory&#39;;
import { HttpLink } from &#39;apollo-link-http&#39;;

// Instantiate required constructor fields
const cache = new InMemoryCache();
const link = new HttpLink({
  uri: &#39;http://yourbackendendpoint.com/graphql&#39;,
});

const client = new ApolloClient({
  // Provide required constructor fields
  cache: cache,
  link: link,

  // Provide some optional constructor fields
  name: &#39;react-web-client&#39;,
  version: &#39;1.3&#39;,
  queryDeduplication: false,
  defaultOptions: {
    watchQuery: {
      fetchPolicy: &#39;cache-and-network&#39;,
    },
  },
});

export default client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照上面的方式创建一个 &lt;code&gt;ApolloClient&lt;/code&gt;，然后我们可以在组件中引用它，因为 &lt;code&gt;ApolloProvider&lt;/code&gt; 需要它作为 prop 传入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSX&#34;&gt;import React from &#39;react&#39;;
import { render } from &#39;react-dom&#39;;
import client from &#39;./client&#39; // sample

import { ApolloProvider } from &#39;@apollo/react-hooks&#39;;

const App = () =&amp;gt; (
  &amp;lt;ApolloProvider client={client}&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;h2&amp;gt;My first Apollo app 🚀&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/ApolloProvider&amp;gt;
);

render(&amp;lt;App /&amp;gt;, document.getElementById(&#39;root&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;题外话：需要注意一下 &lt;code&gt;ApolloProvider&lt;/code&gt; 注入的位置，同时创建 &lt;code&gt;ApolloClient&lt;/code&gt; 的时候需要导出一个创建 client 的函数（如果业务定制较为复杂的话可能需要这么做，例如绑定通用的错误处理和国际化）时，需要防止 &lt;code&gt;ApolloProvider&lt;/code&gt; re-render 导致的 &lt;code&gt;ApolloClient&lt;/code&gt; 被重复创建，因为这样相当于会清空 Apollo 的缓存，导致额外不必要的网络请求。缓存相关的内容会在下面提到。&lt;/p&gt;

&lt;p&gt;而如果我们要发起请求，我们需要使用 Apollo 提供的 API。Apollo 提供了 &lt;code&gt;&amp;lt;Query /&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;Mutation /&amp;gt;&lt;/code&gt; 的组件，它们是以 render callback 的模式来应用的。而我在项目中主要运用了 hooks。Apollo 的 hooks 主要常用的有 3 个，分别是 &lt;code&gt;useQuery&lt;/code&gt;, &lt;code&gt;useLazyQuery&lt;/code&gt; 和 &lt;code&gt;useMutation&lt;/code&gt;。&lt;code&gt;useQuery&lt;/code&gt; 和 &lt;code&gt;useLazyQuery&lt;/code&gt; 的区别是，&lt;code&gt;useQuery&lt;/code&gt; 在组件 render/re-render 的时候会自动执行（发起请求），而 &lt;code&gt;useLazyQuery&lt;/code&gt; 则允许用户在特定的时候调用一个函数来发起请求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSX&#34;&gt;/** useQuery */
import { gql, useQuery } from &#39;@apollo/client&#39;; // 注： 3.0beta 将 gql 整合至 @apollo/client 包中，和上文的从 &#39;graphql-tag&#39; 包中引用的方式并不冲突

const GET_GREETING = gql`
  query GetGreeting($language: String!) {
    greeting(language: $language) {
      message
    }
  }
`;

function Hello() {
  const { loading, error, data } = useQuery(GET_GREETING, {
    variables: { language: &#39;english&#39; },
  });
  if (loading) return &amp;lt;p&amp;gt;Loading ...&amp;lt;/p&amp;gt;;
  return &amp;lt;h1&amp;gt;Hello {data.greeting.message}!&amp;lt;/h1&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSX&#34;&gt;/** useLazyQuery */
import { gql, useLazyQuery } from &amp;quot;@apollo/client&amp;quot;;

const GET_GREETING = gql`
  query GetGreeting($language: String!) {
    greeting(language: $language) {
      message
    }
  }
`;

function Hello() {
  const [loadGreeting, { called, loading, data }] = useLazyQuery(
    GET_GREETING,
    { variables: { language: &amp;quot;english&amp;quot; } }
  );
  if (called &amp;amp;&amp;amp; loading) return &amp;lt;p&amp;gt;Loading ...&amp;lt;/p&amp;gt;
  if (!called) {
    return &amp;lt;button onClick={() =&amp;gt; loadGreeting()}&amp;gt;Load greeting&amp;lt;/button&amp;gt;
  }
  return &amp;lt;h1&amp;gt;Hello {data.greeting.message}!&amp;lt;/h1&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSX&#34;&gt;/** useMutation */
import { gql, useMutation } from &#39;@apollo/client&#39;;

const ADD_TODO = gql`
  mutation AddTodo($type: String!) {
    addTodo(type: $type) {
      id
      type
    }
  }
`;

function AddTodo() {
  let input;
  const [addTodo, { data }] = useMutation(ADD_TODO);

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;form
        onSubmit={e =&amp;gt; {
          e.preventDefault();
          addTodo({ variables: { type: input.value } });
          input.value = &#39;&#39;;
        }}
      &amp;gt;
        &amp;lt;input
          ref={node =&amp;gt; {
            input = node;
          }}
        /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Add Todo&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面分别展示了 &lt;code&gt;useQuery&lt;/code&gt;, &lt;code&gt;useLazyQuery&lt;/code&gt; 和 &lt;code&gt;useMutation&lt;/code&gt; 的用法。如果了解 hooks 的话，参考 Apollo 的 API 文档应该上手难度不大。那么在上一节提到的请求参数，我们就可以在这边以 &lt;code&gt;variables&lt;/code&gt; 传入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const [loadGreeting, { called, loading, data }] = useLazyQuery(
  GET_GREETING,
  { variables: { language: &amp;quot;english&amp;quot; } } // 参数
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在 Apollo 中，&lt;code&gt;options&lt;/code&gt; 是非常重要的，它可以定制 queries 和 mutations 的行为。举例来说，&lt;code&gt;variables&lt;/code&gt; 其实就是 &lt;code&gt;options&lt;/code&gt; 的一部分。在 queries 中有几个比较重要的参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;notifyOnNetworkStatusChange: &lt;code&gt;networkStatus&lt;/code&gt; 变化的时候是否需要 re-render 组件&lt;/li&gt;
&lt;li&gt;fetchPolicy: 这关系到 Apollo 会不会缓存数据。设置为 &lt;code&gt;cache-first&lt;/code&gt; 的话，针对同样的请求参数，Apollo 会直接读取 client 中的缓存而不会重新请求；设置为 &lt;code&gt;network-only&lt;/code&gt; 的话，则会每次都请求新的数据&lt;/li&gt;
&lt;li&gt;pollInterval: 轮询间隔时间。虽然我们常规的业务不需要轮询，但是这个参数其实是可以用作刷新策略的&lt;/li&gt;
&lt;li&gt;onCompleted: 请求完成后的回调。我一般比较少用这个，因为之前有发现它会被重复调用的 bug。监听数据状态其实可以简单地用 &lt;code&gt;useEffect&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么这些参数如何使用呢？假设我们有个场景，在一个用户列表打开一个弹窗，修改用户信息后需要重新获取用户列表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSX&#34;&gt;import React, { useState, useEffect } from &#39;react&#39;

const UserModule = () =&amp;gt; {
  const [pollInterval, setPollInterval] = useState(0)

  const [updateUserInfo, { data: mutationData }] = useMutation(UPDATE_USER_INFO); // updateUserInfo 会在某处被调用

  const [called, loading, data] = useQuery(
    GET_USERS,
    {
      variables: {}, // 省略
      pollInterval
    }
  )

  useEffect(() =&amp;gt; {
    // mutation 成功
    if (mutationData.res === &#39;success&#39;) {
      setPollInterval(500)
    }
  }, [mutationData])

  useEffect(() =&amp;gt; {
    // 重置 pollInterval 防止重复请求
    if (data &amp;amp;&amp;amp; pollInterval !== 0) {
      setPollInterval(0)
    }
  }, [data])

  // 数据处理和渲染就不实现了
  return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码逻辑是：发起 &lt;code&gt;UPDATE_USER_INFO&lt;/code&gt; 的 mutation，请求成功后将 &lt;code&gt;pollInterval&lt;/code&gt; 设置成 500ms，这样 &lt;code&gt;GET_USERS&lt;/code&gt; 的 query 就会在 500ms 后重新请求。这个重新请求是无视缓存的，就算你设置缓存为 &lt;code&gt;cache-first&lt;/code&gt; 也会重新请求。而 &lt;code&gt;fetchPolicy&lt;/code&gt; 主要影响的是 &lt;code&gt;variables&lt;/code&gt; 变化导致的行为，例如请求一个用户表格会有不同页码、每页数量、排序字段、过滤字段等参数，使用同样的参数是读取缓存还是重新获取数据。接着我们需要找一个时机将 &lt;code&gt;pollInterval&lt;/code&gt; 重新设置成 0，防止无限循环的请求。另外建议不要在 React 组件中使用 &lt;code&gt;setTimeout&lt;/code&gt; 去设置 &lt;code&gt;pollInterval&lt;/code&gt;，因为我们看上面的代码涉及到了很多 state 变化和 effects，这些在 React 中某种程度上是“异步”的，如果在业务很复杂的场景下使用 &lt;code&gt;setTimeout&lt;/code&gt;，反而会导致组件的行为难以控制，而且也可能会出现在已经 unmounted 的组件上更新 state 的 error，尽管对用户使用的影响不大，但是对性能是不利的。&lt;/p&gt;

&lt;h3 id=&#34;单元测试&#34;&gt;单元测试&lt;/h3&gt;

&lt;p&gt;我们知道 React 组件的单元测试可以用 jest + enzyme 来完成。单元测试的时候我们一般会使用 shallow render。而在使用了 Apollo 相关的 API 比如 hooks 之后，jest 会提示我们该组件没有 &lt;code&gt;ApolloProvider&lt;/code&gt;，这些 Apollo 相关的 API 只能在 &lt;code&gt;ApolloProvider&lt;/code&gt; 内使用。Apollo 也提供了用于测试的 API：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;import { MockedProvider } from &amp;quot;@apollo/client/testing&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体使用例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;import { MockedProvider } from &amp;quot;@apollo/client/testing&amp;quot;;
import { mount } from &#39;enzyme&#39;

const mocks = [
  {
    request: {
      query: SOME_QUERY,
      variables: { first: 4 }
    },
    result: {
      data: {
        dog: {
          name: &amp;quot;Douglas&amp;quot;
        }
      }
    }
  },
  {
    request: {
      query: SOME_QUERY,
      variables: { first: 8}
    },
    error: new Error(&amp;quot;Something went wrong&amp;quot;)
  }
]

it(&amp;quot;runs the mocked query&amp;quot;, () =&amp;gt; {
  const wrapper = mount(
    &amp;lt;MockedProvider mocks={mocks}&amp;gt;
      &amp;lt;MyQueryComponent /&amp;gt;
    &amp;lt;/MockedProvider&amp;gt;
  )
  // Run assertions on &amp;lt;MyQueryComponent/&amp;gt;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是把组件实际渲染的部分和 &lt;code&gt;MockedProvider&lt;/code&gt; 写在同一个组件内，那么测试的时候需要用 &lt;code&gt;mount&lt;/code&gt;，否则无法将组件内部的内容渲染出来。对测试比较友好的方式可能是，将 queries/mutations 的部分独立出来做一个 container 组件，渲染部分作为 dumb 组件。但是这具体得看这方面的需求和代码规范是怎么制定的。&lt;/p&gt;

&lt;p&gt;目前这个测试可能还是有点 bug 的状态，我目前项目还没迁移到 3.0beta，所以不大清楚会不会在新版修复。我在旧版中遇到过几种情况，例如 mock 的数据都写对，但实际上返回了 network error，提示参数有问题；还有遇到过 mocks 里写两个对象会出现读取错误的问题，也就是不方便同时 mock 多个 queries/mutations。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重新了解 React - React Fiber</title>
      <link>https://elizurhz.cn/frontend/react-fiber/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/react-fiber/</guid>
      <description>

&lt;h1 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h1&gt;

&lt;p&gt;我第一次使用 React 大概是在 2017 年吧，那个时候大概是 React v15 的时代。我学 React 的方法确实很普通，从例子入手，让代码能够跑起来而已。接着就是看各种实战和开源的 sample。然后我在任职的第一家公司，从不知道怎么定位的大学刚毕业的新人，正式转岗到前端。那个时候在做 Vue 的项目（我硕士的时候在学校就有在做 Vue 的项目了），也有幸碰到了几位有点经验的前端，稍微学了学一个完整的项目是怎样的构架。接着就是跳槽，背了一大堆应付面试的东西，包括 React 的一些东西，结果发现实际面试的效果却不理想。由于一直在小公司，一直追求功能的发布上线，而不是原理和性能，因此我根本没有什么机会去学习、运用这些知识。就这样，我到了网龙，在网龙前前后后也做了几个项目。大公司里，同事的水平确实不太一样，大家也会更多关注这些方面的东西。特别是最近做了新的项目，我算是项目从 0 开始搭建的主力了。我们在项目中用了最新的技术，包括 Hooks 这种社区中还没有大规模投入生产的技术，我也发现我在技术上其实存在很多的不足。在工作的过程中，一次次地看文档、一次次地与同事交流，能一次次地学到新东西，也发现其实很有必要把这些东西总结起来。&lt;/p&gt;

&lt;h1 id=&#34;还在谈-react-的-diff-算法和虚拟-dom-你可能已经-out-了&#34;&gt;还在谈 React 的 diff 算法和虚拟 DOM？你可能已经 Out 了！&lt;/h1&gt;

&lt;p&gt;2018 年初和年中我经历过一些面试，React 的 diff 算法和虚拟 DOM 其实是遇到得比较多的 React 的原理的面试题，当然这些知识从一些专门讲面试的文章里可以看到。其实很多人都会为了准备面试而去背这些原理，包括我。不过说实话，里面有些东西确实开发中有用，例如列表渲染时 key 的使用，以及找出为什么列表渲染时数据不会变化的问题。但是真的要认真讨论起来，其实有一些概念并不完全正确，比如“虚拟 DOM”：
React 中有 reconciler，它是负责运行 diff 算法的。它仅仅相当于一个运算器，最终的渲染需要靠一个渲染环境来完成，例如浏览器的 DOM 环境。我们把它称作“虚拟 DOM”不过是因为这个名词使用很广泛而已，而它实际上是个 Tree 而已。React Native 也用它，在 React Native 中我们可能不应该把它称作为“虚拟 DOM”，因为 React Native 中并没有 DOM，而是会渲染成原生控件。&lt;/p&gt;

&lt;h1 id=&#34;从-diff-算法-说起&#34;&gt;从“diff 算法”说起&lt;/h1&gt;

&lt;p&gt;其实 diff 这个概念并不是很严格地能代指我们现在的场景。&lt;a href=&#34;https://en.wikipedia.org/wiki/Diff&#34;&gt;Wikipedia&lt;/a&gt; 上 diff 的定义是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In computing, the diff utility is a data comparison tool that calculates and displays the differences between two files.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而 &lt;a href=&#34;https://reactjs.org/docs/reconciliation.html&#34;&gt;React 官方文档&lt;/a&gt;中提到的 &lt;code&gt;“diffing” algorithm&lt;/code&gt; 其实是来自于&lt;a href=&#34;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&#34;&gt;这篇论文&lt;/a&gt;，是计算&lt;strong&gt;从一棵树转变成另一棵树需要的最少操作次数&lt;/strong&gt;的 state of the art 的算法，算法复杂度是 O(n³)。React 团队对它做了改进，实现了启发式的 O(n) 的算法，&lt;strong&gt;这个算法叫做 &lt;a href=&#34;https://reactjs.org/docs/reconciliation.html&#34;&gt;Reconciliation&lt;/a&gt;&lt;/strong&gt;。&lt;code&gt;Reconciliation&lt;/code&gt; 这个名词很少在中文社区被提到，我也是看了 React Fiber 的相关文章才知道它的，然而它可是天天被面试官问到的东西啊！不知道是大家英文不好还是怎么的，在二次传播的过程中竟然把这东西给忽略掉了。这样的二次传播其实是不友好的，这也是为什么都推荐去阅读英文文档。而 Reconciliation 具体的策略是什么，想必大家都应该了然于胸了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在比较中遇到不同的的 DOM Element 或者 Component 会直接重建该子树&lt;/li&gt;
&lt;li&gt;相同 type 的元素则不会，但是会判断是否重渲染。官方文档说的是 &amp;ldquo;React updates the props of the underlying component instance to match the new element, and calls componentWillReceiveProps() and componentWillUpdate() on the underlying instance.&amp;ldquo;，但是这个文档应该是很早写的，v16.3 以后应该有所变化了，首先我们有用于优化的 PureComponent、shouldComponentUpdate、React.memo 等方式，其次 componentWillReceiveProps() and componentWillUpdate() 即将 deprecated 了&lt;/li&gt;
&lt;li&gt;遇到同类但不同 key 的元素会直接重建该子树，反之则不会&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;“diff 算法”在 v16.8 中当然还是有用的，但是现在的 React 渲染没有这么简单了！如果继续使用“diff 算法”，那在渲染大量元素的时候会出现严重的“掉帧”现象。而 React 团队在 v16 发布的时候就已经对渲染算法进行了重构。所以现在你还只停留在“diff 算法”中的话，你就 out 了！&lt;/p&gt;

&lt;h1 id=&#34;react-fiber&#34;&gt;React Fiber&lt;/h1&gt;

&lt;p&gt;在 React 中，有一个 Reconciler，它就是负责运行 reconciliation 算法的。在 React v15 以及更早的版本，React 使用的是 Stack Reconciler，而 v16 开始使用的则是 Fiber Reconciler，也就是我们所说的“React Fiber”。&lt;/p&gt;

&lt;h2 id=&#34;why-react-fiber&#34;&gt;Why React Fiber&lt;/h2&gt;

&lt;p&gt;简单总结下就是：Stack Reconciler （React v16 以前）在执行渲染的时候，会占用浏览器的主线程，直到渲染完成，这样任何的操作都会被阻塞；而 Fiber Reconciler （React v16 以后）则可以拆分渲染任务，每隔一段时间可以去确定是否有更高优先级的任务（例如用户输入），并优先执行它们。这个最直观的体现就是渲染一棵很大的组件树的性能大大提高了。&lt;/p&gt;

&lt;h2 id=&#34;what-is-fiber&#34;&gt;What is fiber&lt;/h2&gt;

&lt;p&gt;官方文档的介绍：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Its main goals are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to split interruptible work in chunks.&lt;/li&gt;
&lt;li&gt;Ability to prioritize, rebase and reuse work in progress.&lt;/li&gt;
&lt;li&gt;Ability to yield back and forth between parents and children to support layout in React.&lt;/li&gt;
&lt;li&gt;Ability to return multiple elements from render().&lt;/li&gt;
&lt;li&gt;Better support for error boundaries.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;requestidlecallback-requestanimationframe&#34;&gt;requestIdleCallback &amp;amp; requestAnimationFrame&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/acdlite/react-fiber-architecture&#34;&gt;React Fiber Architecture&lt;/a&gt; 这篇文章说到，fiber 是基于这两个浏览器 API 来优化的。&lt;/p&gt;

&lt;p&gt;MDN 上这两个 API 的定义如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;window.requestIdleCallback() 会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟敏感的事件产生影响。&lt;/p&gt;

&lt;p&gt;window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，requestAnimationFrame 可以用于执行高优先级的任务，而 requestIdleCallback 可以用于执行低优先级的任务。那么二者到底是怎么执行的呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/2600/1*ad-k5hYKQnRQJF8tv8BIqg.png&#34; alt=&#34;Life of a frame (main thread edition)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器中，每一帧里需要做的事如上图所示。其中 也就是说，requestAnimationFrame 的 callback 会在 rAF 阶段执行。假设我们想要我们动画的 FPS 保持在 60，那么我们需要保证在 1 帧（1000/60 ms）里能够做完这些事。而如果 1 帧里做完了这些事并且有空闲时间，那么就可以执行 requestIdleCallback 的 callback。另外关于 60FPS，通常我们认为 60 是个理想的数值，FPS 小于 20 会感受到明显的卡顿，而大于 60 需要额外的资源但是人眼无法感受到明显的变化。&lt;/p&gt;

&lt;h2 id=&#34;scheduling&#34;&gt;Scheduling&lt;/h2&gt;

&lt;p&gt;关于调度：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没必要实时更新所有的 UI&lt;/li&gt;
&lt;li&gt;不同类型的更新有不同的优先级，例如动画的优先级会高于 store 的更新&lt;/li&gt;
&lt;li&gt;React 的实现方式是 &amp;ldquo;pull&amp;rdquo; 的，它会帮助我我们决定事务的优先级。它不像某些库的 &amp;ldquo;push&amp;rdquo; 方式，在有新的 data 的时候就执行计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而 Fiber Reconciler 中有个 Scheduler，它可以用于调度任务，高优先级的任务会被先执行，而 diff 属于低优先级的任务，会在高优先级的任务执行完成后再执行。&lt;/p&gt;

&lt;h2 id=&#34;渲染过程&#34;&gt;渲染过程&lt;/h2&gt;

&lt;p&gt;在执行渲染的时候，Fiber Reconciler 会根据虚拟 DOM 生成一棵 Fiber Tree。这个阶段是可以被打断的。在生成 Fiber Tree 的时候，每生成一个节点，都会把控制权交还给主线程，看是否有更高优先级的任务，如果没有则继续构建，否则会打断 Fiber Tree 的构建。如果在这个阶段被打断，那么 Fiber Reconciler 会重新生成新的 Fiber Tree。这个阶段主要是在 React 组件的 render/reconciliation 阶段，对应生命周期钩子就是渲染或者重渲染前那些。而 Fiber Tree 上的每个节点中，如果有 side effect，就会进行标记，在这个阶段中会生成一个 effect list。&lt;/p&gt;

&lt;p&gt;在经过这个阶段之后，会进入到 commit 的阶段，此时会对需要更新的节点进行批量更新，如更新 DOM 树、调用组件生命周期函数以及更新 ref 等内部状态。该阶段不能被打断，所以尽可能不要在 componentDidMount、componentDidUpdate 和 componentWillUnmount 中做很耗资源的操作。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/acdlite/react-fiber-architecture&#34;&gt;React Fiber Architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000018250127&#34;&gt;React Fiber 原理介绍 - 前端大宝剑 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader3&#34;&gt;完全理解 React Fiber | 黯羽轻扬&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>More About React Hooks</title>
      <link>https://elizurhz.cn/frontend/more-about-react-hooks/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/more-about-react-hooks/</guid>
      <description>

&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;

&lt;p&gt;这篇文章是关于我前一篇关于 React Hooks 的文章（&lt;a href=&#34;https://elizurhz.cn/frontend/how-hooks-helps/&#34;&gt;React Hooks 能给我们带来什么 | La Vie en Code - 编码人生&lt;/a&gt;）的延伸。如果说前一篇文章是基础，告诉大家怎么使用基本的 hooks 的话，那这篇文章则是一些踩坑和更多 hooks 的用法。&lt;/p&gt;

&lt;h1 id=&#34;不当的使用可能导致无限循环&#34;&gt;不当的使用可能导致无限循环&lt;/h1&gt;

&lt;p&gt;当你写下 &lt;code&gt;useState&lt;/code&gt; 那一行后，你可能会在某处去重设这个 state。有一个误区就是在函数式组件的函数体直接调用 set 的方法。虽然这样确实可以运行得到（它会在每次 render 的时候调用到），但是要知道 state 改变了之后组件会 re-render 的。这样就会又一次调用 set 的方法而造成无限循环:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Too many re-renders. React limits the number of renders to prevent an infinite loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置成不变的基础类型也会导致这个问题。&lt;/p&gt;

&lt;p&gt;所以如果你想重设 state，请用 &lt;code&gt;useEffect&lt;/code&gt; 或者通过事件触发。但是在使用 &lt;code&gt;useEffect&lt;/code&gt; 的时候也切记不要造成无限循环。如果你懂得怎样使用 &lt;code&gt;componentWillReceiveProps&lt;/code&gt;、&lt;code&gt;componentDidUpdate&lt;/code&gt; 或者 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 这些生命周期更钩子的话，那么也应该知道怎样在特定的时候执行特定的操作，例如某个 prop 变化时：要用条件语句来判断，否则会在不必要的情况下执行了你编写的语句。&lt;code&gt;useEffect&lt;/code&gt; 也一样。最糟糕的情况就是在 &lt;code&gt;useEffect&lt;/code&gt; 中多次地、重复地重设 state，处理不当的话也会导致 re-render 的无限循环。当然除了用条件语句来判断之外，还有 dependencies，也就是 &lt;code&gt;useEffect&lt;/code&gt; 的第二个参数可以用。&lt;/p&gt;

&lt;p&gt;另外 &lt;code&gt;useSelector&lt;/code&gt; 也可能导致这种问题，除了使用 &lt;code&gt;react-redux&lt;/code&gt; 提供的 &lt;code&gt;shallowEqual&lt;/code&gt; 之外，还可能出现各种复杂的情况。所以处理这种问题，关键是要了解 React 在什么情况下会 re-render，functional component 和 class component 在处理渲染上又有什么区别。&lt;/p&gt;

&lt;h1 id=&#34;usememo-usecallback&#34;&gt;useMemo &amp;amp; useCallback&lt;/h1&gt;

&lt;p&gt;Hooks 都只存在于 Functional Component 之中，而 Functional Component 在 re-render 时会把整个函数执行一遍，而不是像 Class Component 一样只执行生命周期钩子而不会单独执行类方法。并且由于和 React 渲染相关的函数/计算都要写在 Functional Component 的函数体中，所以这些函数不免会再执行一遍。当我们遇到比较耗性能的计算时，运算函数的重复执行会占用大量的资源。这时候就需要 useMemo 了。&lt;/p&gt;

&lt;p&gt;useMemo 会保存一个带记忆功能的值。它会在 render 的时候，根据设定的依赖来执行。&lt;/p&gt;

&lt;p&gt;从 &lt;code&gt;@types/react&lt;/code&gt; 的包中可以找到 useMemo 的函数签名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function useMemo&amp;lt;T&amp;gt;(factory: () =&amp;gt; T, deps: DependencyList | undefined): T;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的第一个参数是一个函数，也就是在 hook 被执行的时候，会执行这个函数。但需要注意的是这个函数必须要有一个返回值，因为我们的目的就是要得到一个值啊。然后第二个参数是依赖，是一个数组，它的意思是只有数组里的变量发生变化时才会执行这个 hook，这一点和&lt;a href=&#34;https://elizurhz.cn/frontend/how-hooks-helps/&#34;&gt;之前我写过的 &lt;code&gt;useEffect&lt;/code&gt;&lt;/a&gt; 是一样的。&lt;/p&gt;

&lt;p&gt;然后，&lt;i&gt;&lt;code&gt;useCallback(fn, deps)&lt;/code&gt; 实际上就相当于 &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt;&lt;/i&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function useCallback&amp;lt;T extends (...args: any[]) =&amp;gt; any&amp;gt;(callback: T, deps: DependencyList): T;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;useref&#34;&gt;useRef&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;useRef&lt;/code&gt; 其实可以把它视为 React 中 &lt;code&gt;ref&lt;/code&gt; 的 hooks 版本。它也有“记忆”的功能，但是和 useMemo 不一样的是，它会创建一个包含 &lt;code&gt;.current&lt;/code&gt; 的 JavaScript Object，并且每次 render 都会返回&lt;i&gt;相同&lt;/i&gt;的 Object。我们可以在 Functional Component 中用它替代 ref 的功能，也可以&lt;a href=&#34;https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables&#34;&gt;用于记忆其他的东西&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;函数签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function useRef&amp;lt;T&amp;gt;(initialValue: T): MutableRefObject&amp;lt;T&amp;gt;;

interface MutableRefObject&amp;lt;T&amp;gt; {
  current: T;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法参考 &lt;a href=&#34;https://reactjs.org/docs/hooks-reference.html#useref&#34;&gt;React 官方文档&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () =&amp;gt; {
    // `current` points to the mounted text input element
    inputEl.current.focus();
  };
  return (
    &amp;lt;&amp;gt;
      &amp;lt;input ref={inputEl} type=&amp;quot;text&amp;quot; /&amp;gt;
      &amp;lt;button onClick={onButtonClick}&amp;gt;Focus the input&amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;存储组件内部的私有变量&#34;&gt;存储组件内部的私有变量&lt;/h2&gt;

&lt;p&gt;官方的例子是用于获取原生 DOM 节点，而 useRef 其实并没有被限制必需用于 DOM 节点上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function TestComponent() {
  const count = useRef(0);
  useEffect(() =&amp;gt; {
    count.current = 1;
  }, []);
  return &amp;lt;div&amp;gt;{count.current}&amp;lt;/div&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上面的例子所示，我们可以将它设成一个值，他会返回这样一个对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;{ current: 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过直接给 &lt;code&gt;current&lt;/code&gt; 赋值，即可修改它。并且它不会触发 re-render。这其实就很类似 class component 中的类的私有变量了。&lt;/p&gt;

&lt;h1 id=&#34;react-forwardref&#34;&gt;React.forwardRef&lt;/h1&gt;

&lt;p&gt;这东西在业务开发里基本是用不着的，在组件设计可能会用到。我们知道 Class Component 中 ref 的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;class MyInput extends React.Component {
  render() {
    return &amp;lt;input ref={ref =&amp;gt; (this.inputElem = ref)} /&amp;gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在某些需求里，我们可能会需要在这个组件外部创建 ref，并以此来管理它的 focus 状态、动画等。&lt;/p&gt;

&lt;p&gt;使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const MyInput = React.forwardRef((props, ref) =&amp;gt; (
  &amp;lt;input ref={(ref) =&amp;gt; this.inputElem = ref} /&amp;gt;
))

const ref = React.createRef()
&amp;lt;MyInput ref={ref} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它和 &lt;code&gt;React.createRef&lt;/code&gt; 是需要一起使用的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 React 16.3 的 Context API 实现类似 ant design 的 Material Design 版 Radio Group 组件</title>
      <link>https://elizurhz.cn/frontend/how-to-use-context-in-react/</link>
      <pubDate>Fri, 09 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/how-to-use-context-in-react/</guid>
      <description>

&lt;h1 id=&#34;radio-组件是什么样的&#34;&gt;Radio 组件是什么样的&lt;/h1&gt;

&lt;p&gt;以官方文档的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;import React from &amp;quot;react&amp;quot;;
import { Radio } from &amp;quot;antd&amp;quot;;

class App extends React.Component {
  state = {
    value: 1
  };

  onChange = e =&amp;gt; {
    console.log(&amp;quot;radio checked&amp;quot;, e.target.value);
    this.setState({
      value: e.target.value
    });
  };

  render() {
    return (
      &amp;lt;Radio.Group onChange={this.onChange} value={this.state.value}&amp;gt;
        &amp;lt;Radio value={1}&amp;gt;A&amp;lt;/Radio&amp;gt;
        &amp;lt;Radio value={2}&amp;gt;B&amp;lt;/Radio&amp;gt;
        &amp;lt;Radio value={3}&amp;gt;C&amp;lt;/Radio&amp;gt;
        &amp;lt;Radio value={4}&amp;gt;D&amp;lt;/Radio&amp;gt;
      &amp;lt;/Radio.Group&amp;gt;
    );
  }
}

ReactDOM.render(&amp;lt;App /&amp;gt;, mountNode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了这种方式，还有使用 options 这个 prop 传递配置文件进行渲染的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;import React from &amp;quot;react&amp;quot;;
import { Radio } from &amp;quot;antd&amp;quot;;

const plainOptions = [&amp;quot;Apple&amp;quot;, &amp;quot;Pear&amp;quot;, &amp;quot;Orange&amp;quot;];
const options = [
  { label: &amp;quot;Apple&amp;quot;, value: &amp;quot;Apple&amp;quot; },
  { label: &amp;quot;Pear&amp;quot;, value: &amp;quot;Pear&amp;quot; },
  { label: &amp;quot;Orange&amp;quot;, value: &amp;quot;Orange&amp;quot; }
];
const optionsWithDisabled = [
  { label: &amp;quot;Apple&amp;quot;, value: &amp;quot;Apple&amp;quot; },
  { label: &amp;quot;Pear&amp;quot;, value: &amp;quot;Pear&amp;quot; },
  { label: &amp;quot;Orange&amp;quot;, value: &amp;quot;Orange&amp;quot;, disabled: false }
];

class App extends React.Component {
  state = {
    value1: &amp;quot;Apple&amp;quot;,
    value2: &amp;quot;Apple&amp;quot;,
    value3: &amp;quot;Apple&amp;quot;
  };

  onChange1 = e =&amp;gt; {
    console.log(&amp;quot;radio1 checked&amp;quot;, e.target.value);
    this.setState({
      value1: e.target.value
    });
  };

  onChange2 = e =&amp;gt; {
    console.log(&amp;quot;radio2 checked&amp;quot;, e.target.value);
    this.setState({
      value2: e.target.value
    });
  };

  onChange3 = e =&amp;gt; {
    console.log(&amp;quot;radio3 checked&amp;quot;, e.target.value);
    this.setState({
      value3: e.target.value
    });
  };

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Radio.Group
          options={plainOptions}
          onChange={this.onChange1}
          value={this.state.value1}
        /&amp;gt;
        &amp;lt;Radio.Group
          options={options}
          onChange={this.onChange2}
          value={this.state.value2}
        /&amp;gt;
        &amp;lt;Radio.Group
          options={optionsWithDisabled}
          onChange={this.onChange3}
          value={this.state.value3}
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

ReactDOM.render(&amp;lt;App /&amp;gt;, mountNode);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ant-design-怎样实现的&#34;&gt;ant design 怎样实现的&lt;/h1&gt;

&lt;p&gt;从 ant design 的 &lt;a href=&#34;https://github.com/ant-design/ant-design/tree/master/components/radio&#34;&gt;github&lt;/a&gt; 上，可以看到（这里我们只关心 radio group）这个模块里面有 radio.tsx 和 group.tsx 组件。&lt;/p&gt;

&lt;h2 id=&#34;index-tsx&#34;&gt;index.tsx&lt;/h2&gt;

&lt;p&gt;首先在 index.tsx 中，实现的是模块的 export，这里通过 Radio 的 static property 把 Group 组件引入，这样就可以实现 &lt;code&gt;&amp;lt;Radio.Group&amp;gt;&lt;/code&gt; 的写法。同时由于 TypeScript 的类型检查，我们需要再 Radio 的类里面写上 static property。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/** index.tsx */
import Radio from &#39;./radio&#39;;
import Group from &#39;./group&#39;;

Radio.Group = Group;
export { Group };
export default Radio;

/** radio.tsx */
static Group: typeof RadioGroup;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;group-tsx-与-radio-tsx&#34;&gt;group.tsx 与 radio.tsx&lt;/h2&gt;

&lt;p&gt;首先这里使用了 &lt;a href=&#34;https://github.com/ant-design/ant-design/blob/master/components/config-provider/index.tsx&#34;&gt;config-provider&lt;/a&gt;，这个组件的作用是使用 &lt;code&gt;@ant-design/create-react-context&lt;/code&gt; 注入了一些配置在 context 中。在这里我们不需要关注它的实现方式，只需要知道它使用了 React 的 context。&lt;/p&gt;

&lt;p&gt;接着我们看 group.tsx 中 &lt;a href=&#34;https://github.com/ant-design/ant-design/blob/28323b785cb8d42a4af7d2ab551c2e3141bd0545/components/radio/group.tsx#L98&#34;&gt;render&lt;/a&gt; 的部分。&lt;/p&gt;

&lt;p&gt;使用 options 的部分就不多说了，根据数组渲染 Radio 组件即可。关键是另一种渲染方式，我们知道我们需要在 Radio.Group 的 props 传入这个 radio group 的 value 和 onChange 事件，而 &lt;code&gt;&amp;lt;Radio.Group&amp;gt;&lt;/code&gt; 在这里只是一个包裹的组件，在 Radio.Group 中我们需要将 Radio 的 onChange 和 props 的 onChange 关联起来。在使用 options 的方式中，我们可以直接把 onChange 通过 props 传给 Radio，但是 Radio 作为 Radio.Group 的 children 时我们却不能这样传。&lt;/p&gt;

&lt;p&gt;ant design 的做法是在 group.tsx 中用了 &lt;a href=&#34;https://github.com/ant-design/ant-design/blob/28323b785cb8d42a4af7d2ab551c2e3141bd0545/components/radio/group.tsx#L68&#34;&gt;getChildContext&lt;/a&gt; 将父组件的 onChange 设置到 context 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;getChildContext() {
  return {
    radioGroup: {
      onChange: this.onRadioChange,
      value: this.state.value,
      disabled: this.props.disabled,
      name: this.props.name,
    },
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在 radio.tsx 中，在 Radio 的 &lt;a href=&#34;https://github.com/ant-design/ant-design/blob/28323b785cb8d42a4af7d2ab551c2e3141bd0545/components/radio/radio.tsx#L40&#34;&gt;onChange&lt;/a&gt; 中调用 context 的 onChange：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt; onChange = (e: RadioChangeEvent) =&amp;gt; {
  if (this.props.onChange) {
    this.props.onChange(e);
  }

  if (this.context.radioGroup &amp;amp;&amp;amp; this.context.radioGroup.onChange) {
    this.context.radioGroup.onChange(e);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getChildContext&lt;/code&gt; 是 legacy 的 Context API 了，React 官方也推荐使用最新的 &lt;a href=&#34;https://reactjs.org/docs/context.html&#34;&gt;Context API&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;我的实现方式&#34;&gt;我的实现方式&lt;/h1&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;首先为什么会有这种需求呢，是因为正在做的项目的设计风格是 antd + Material Design 的结合体，我们使用了 antd，但是有很多 Material Design 的动画效果无法简单地实现，所以需要一部分 Material Design 的组件。而 material-ui 的学习成本对我们团队来说有点高，恰好 Material Design 官方有提供 web 组件与封装好的 &lt;a href=&#34;https://github.com/material-components/material-components-web-react&#34;&gt;React 组件&lt;/a&gt;，引入单个组件以适应某些控件的设计需求比较不容易增加包大小。同时，这些 React 组件其实并不易用，做一层封装之后会让它能够和 ant design 的组件具有相同的用法，同样也更适合为业务组件定制样式、统一管理样式等。&lt;/p&gt;

&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;// context.ts
import React from &#39;react&#39;

export const RadioGroupContext = React.createContext({
  groupValue: &#39;&#39;,
  onChange: (value: string) =&amp;gt; {}
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了新的 Context API 创建了 context。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// radio.tsx
import React from &amp;quot;react&amp;quot;;
import Radio, { NativeRadioControl } from &amp;quot;@material/react-radio&amp;quot;;
import { RadioGroupContext } from &amp;quot;./context&amp;quot;;
import &amp;quot;@material/react-radio/dist/radio.css&amp;quot;;

export default class MyRadio extends React.Component&amp;lt;RadioProps&amp;gt; {
  public static Group: typeof RadioGroup;

  public render(): JSX.Element {
    const { disabled, nativeProps, value, children } = this.props;
    return (
      &amp;lt;RadioGroupContext.Consumer&amp;gt;
        {({
          groupValue,
          onChange
        }: {
          groupValue: string;
          onChange: (value: string) =&amp;gt; void;
        }) =&amp;gt; (
          &amp;lt;div&amp;gt;
            &amp;lt;Radio&amp;gt;
              &amp;lt;NativeRadioControl
                {...nativeProps}
                checked={value === groupValue}
                value={value}
                disabled={disabled}
                onChange={(e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
                  onChange(e.target.value);
                }}
              /&amp;gt;
            &amp;lt;/Radio&amp;gt;
            {children}
          &amp;lt;/div&amp;gt;
        )}
      &amp;lt;/RadioGroupContext.Consumer&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// group.tsx
import React from &amp;quot;react&amp;quot;;
import { RadioGroupContext } from &amp;quot;./context&amp;quot;;

export default class MyRadioGroup extends React.Component&amp;lt;
  PortalRadioGroupProps,
  PortalRadioGroupState
&amp;gt; {
  public constructor(props: PortalRadioGroupProps) {
    super(props);
    this.state = {
      value: props.value || &amp;quot;&amp;quot;
    };
  }

  private onChange = (value: string) =&amp;gt; {
    const { onChange } = this.props;
    this.setState({
      value
    });
    onChange &amp;amp;&amp;amp; onChange(value);
  };

  public render(): JSX.Element {
    const { children } = this.props;
    return (
      &amp;lt;RadioGroupContext.Provider
        value={{
          groupValue: this.state.value,
          onChange: this.onChange
        }}
      &amp;gt;
        {children}
      &amp;lt;/RadioGroupContext.Provider&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新 Context API 的使用方式很简单，在父组件用 Provider 传入 value，这样所有的子组件就可以接收到 value 了。而在使用的地方需要用到 Consumer，要注意的是这个组件是以 render callback 的方式实现的，所以我们也需要写成 render callback 的形式。callback 的参数是上述的 value，而返回值则是我们需要的组件，在这里我们就可以使用从 Provider 传入的 context 了。&lt;/p&gt;

&lt;p&gt;而它使用的方式也很简单，和 antd 基本相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;&amp;lt;Radio.Group onChange={onChange} value={value}&amp;gt;
  &amp;lt;Radio key=&amp;quot;1&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt;
    111
  &amp;lt;/Radio&amp;gt;
  &amp;lt;Radio key=&amp;quot;2&amp;quot; value=&amp;quot;2&amp;quot;&amp;gt;
    222
  &amp;lt;/Radio&amp;gt;
&amp;lt;/Radio.Group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个组件唯一的问题是无法在 antd 的表单中使用。antd Form 其实实现了双向绑定，劫持了 value（或者自定义属性）以及 onChange，但是这个组件点击的时候无法触发 onChange，可能与 Material Design 组件的&lt;a href=&#34;https://github.com/material-components/material-components-web-react/blob/master/packages/checkbox/index.tsx&#34;&gt;内部实现&lt;/a&gt;有关。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>面向前端的 Flutter 与 flutter_web 杂谈</title>
      <link>https://elizurhz.cn/mobile/flutter-tittle-tattle/</link>
      <pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/mobile/flutter-tittle-tattle/</guid>
      <description>

&lt;h1 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：本文写于 flutter_web 技术预览版（也就是 Flutter 1.5）发布后不久，由于 Preview 版本迭代很快如有后续更新，当您看到本文时，本文所提及的内容可能会 out of date。我也会持续关注 flutter 以及 flutter_web 的发展。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;flutter 与前端开发到底有什么关系呢？Flutter 其实是移动 App 的框架，它与之前的移动端开发最大的不同就是使用了声明式的 UI，并且 Flutter 的许多概念都是受了 react 的启发的，例如 stateful &amp;amp; stateless component。开发团队曾经说要支持 web 端，而终于在 2019 年 5 月的 Google I/O 上的 1.5 版本发布时，公布了 flutter_web 的第一个技术预览版。现在 Flutter 也已经更新到了 1.8.0 版了。对于前端开发而言，跨平台的技术也是我们需要关注的，毕竟现在的趋势就是这样，说不定我们可能也有被移动端开发者“抢饭碗”的可能性，因为之前的 React Native 不是戏称前端开发要“抢了移动端开发的饭碗”嘛（但是事实上还差得远呢）。对于 React Native 没做到的事，我会很期待 Google 的 Flutter 能不能做到。&lt;/p&gt;

&lt;h1 id=&#34;从-flutter-说起&#34;&gt;从 flutter 说起&lt;/h1&gt;

&lt;p&gt;可能很多前端更关注的是 flutter_web 到底是什么东西，这边可以先说，它其实和 Flutter 是同一个东西，只是运用了不同的编译和渲染方式而已。所以为了了解 flutter_web，我们需要先了解 Flutter。下面就说下基本的原理（算是从&lt;a href=&#34;https://flutter.dev/docs/resources/technical-overview&#34;&gt;官网的 Technical Overview&lt;/a&gt;上总结出来的，我个人认为是对于前端开发者来说易理解的）：&lt;/p&gt;

&lt;h2 id=&#34;everything-s-a-widget&#34;&gt;Everything&amp;rsquo;s a Widget&lt;/h2&gt;

&lt;p&gt;这里就先不说 Widget 具体是什么以及底层实现了，我们可以把它当做是和 React.Component 一样的东西，但是它所涉及的会比 React.Component 更多，例如样式、布局等等，这是与 JavaScript 的开发最大的不同（与 SwiftUI 其实是一样的）。&lt;/p&gt;

&lt;h2 id=&#34;building-widget&#34;&gt;Building Widget&lt;/h2&gt;

&lt;p&gt;我们写出来的 App 最后会被编译成一个 Widget Tree。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A widget’s build function should be free of side effects. Whenever it is asked to build, the widget should return a new tree of widgets regardless of what the widget previously returned.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个 Widget Tree，我们其实可以把它理解成是 React 的虚拟 DOM 一样的东西。如果需要 build 的时候，也就是说 Widget Tree 有变更的时候，会返回一棵新的 Widget Tree，并且无副作用。这个生成新 Tree 的算法，大致相当于 React 的 diff 算法。在构建 Widget 的时候，我们需要一个 key 的 property，这个就是用于比较 Widget Tree 的。&lt;/p&gt;

&lt;h2 id=&#34;handling-user-interaction&#34;&gt;Handling user interaction&lt;/h2&gt;

&lt;p&gt;这部分其实就是关于 Stateful Widget 的。这部分用起来其实和 React 的 state 区别不大，前端理解起来也不难。&lt;/p&gt;

&lt;h1 id=&#34;dart&#34;&gt;Dart&lt;/h1&gt;

&lt;p&gt;提到 Flutter，就不得不说到 Dart 这个语言。我们在做 JavaScript 开发时肯定会遇到很多痛点，例如静态类型检查。而我们确实有相应的解决方法，比如 flow 和 TypeScript，但是不是所有开发者都会用它们，迁移起来也有一定的难度，特别是 TypeScript，对于没有 Java/C++ 开发经验的人可能会有点棘手，并且上手一段时间后能可能能跑起来，但是写出来的代码仍然有漏洞，比如滥用 &lt;code&gt;any&lt;/code&gt;、类型约束丢失等等。
而我会把 Dart 看做和 TypeScript 类似的语言，对于 JavaScript 开发者，或是 Java 开发者，都很好上手。但是 Dart 确实有一些很强大的功能，这也是 Flutter 高性能的基础。&lt;/p&gt;

&lt;h2 id=&#34;jit-just-in-time&#34;&gt;JIT(Just-in-Time)&lt;/h2&gt;

&lt;p&gt;JIT 编译是 Flutter 在开发中能够实现 hot reload 的基础。它会使用 DartVM 来进行 JIT 编译。&lt;/p&gt;

&lt;h2 id=&#34;aot-ahead-of-time&#34;&gt;AOT(Ahead-of-Time)&lt;/h2&gt;

&lt;p&gt;AOT 编译是在生产环境编译时，直接将我们的代码编译成 ARM Code，这样用 Flutter 写的 app 就不像用其他框架写的 app 那样需要在运行时编译，可以极大提高运行的速度，这也是 Flutter 的主要亮点之一。&lt;/p&gt;

&lt;h2 id=&#34;compile-to-javascript&#34;&gt;Compile to JavaScript&lt;/h2&gt;

&lt;p&gt;Dart 可以通过 dart2js 编译成 JavaScript 代码，这是 flutter_web 的基础。&lt;/p&gt;

&lt;h2 id=&#34;异步编程&#34;&gt;异步编程&lt;/h2&gt;

&lt;p&gt;和 JavaScript 一样，Dart 中有内置一些异步编程的 library。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;async/await，和 ES7 的 async/await 是类似的，可以参考 &lt;a href=&#34;https://www.youtube.com/watch?v=SmTCmDMi4BY&#34;&gt;Flutter 官方教程视频&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Future，和 Promise 是类似的，可以参考 &lt;a href=&#34;https://www.youtube.com/watch?v=OTS-ap9_aXc&#34;&gt;Flutter 官方教程视频&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stream，提供了流的发布与订阅，是 Dart 异步编程的核心之一，可以参考 &lt;a href=&#34;https://www.youtube.com/watch?v=nQBpOIHE4eE&#34;&gt;Flutter 官方教程视频&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;从-flutter-到-flutter-web&#34;&gt;从 Flutter 到 flutter_web&lt;/h1&gt;

&lt;p&gt;上面已经简要说明了一下 Flutter，那么 flutter_web 又是什么呢，它和 Flutter 有什么关系呢？我们可以通过两张 layer cake 图来看下吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/flutter-tittle-tattle/flutter-layer-cake.png&#34; alt=&#34;Flutter&#39;s Layer Cake&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/flutter-tittle-tattle/flutter_web-layer-cake.png&#34; alt=&#34;flutter_web&#39;s Layer Cake&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上面两张图我们可以看到，Framework 层其实二者是完全一样的！不同之处仅仅在于渲染引擎。在 Flutter 中，绘图引擎使用的是 skia，而在 flutter_web 中，元素都是绘制在 canvas 上的！&lt;/p&gt;

&lt;p&gt;我们可以结合实际的例子来看看，例如 NYTIMES 做的 &lt;a href=&#34;https://www.nytimes.com/games/prototype/kenken#/&#34;&gt;KENKEN&lt;/a&gt; 小游戏。&lt;/p&gt;

&lt;p&gt;如果使用 Chrome Devtools 查看的话，我们可以看出它的 DOM 结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/flutter-tittle-tattle/kenken-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们认知的 Web App 结构完全不一样。然后我在 &lt;a href=&#34;https://www.reddit.com/r/FlutterDev/comments/blvrou/flutter_for_web_preview_goes_public/&#34;&gt;Reddit&lt;/a&gt; 上找到了一位 flutter_web 的开发者的留言：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/flutter-tittle-tattle/kenken-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大意是：&lt;code&gt;&amp;lt;flt-scene-host&amp;gt;&lt;/code&gt; 是展示层，包括 DOM 和 Canvas 等；&lt;code&gt;&amp;lt;flt-glass-pane&amp;gt;&lt;/code&gt; 是用于监听事件的层；&lt;code&gt;&amp;lt;flt-ruler-host&amp;gt;&lt;/code&gt; 是用于测量 text 的层。&lt;/p&gt;

&lt;p&gt;这种渲染方式就与 Flutter 在移动端的渲染方式完全一样了。在移动端，Flutter 靠 skia 在原生的 Canvas 上直接绘制元素/控件，这样不仅渲染速度快，而且在不同平台上可以显示出同样的样式，不会因为各平台原生控件的不同而导致样式的不同。目前 Flutter 提供了 Cupertino 和 Material 两种风格可供选择，分别代表 iOS 与 Android 的两种设计风格。&lt;/p&gt;

&lt;p&gt;换句话说，Flutter 团队是完整地将移动端的渲染方式搬运到了 web 上，以使用 canvas 为主，而不是像 React 那样还是会渲染成真实 DOM。&lt;/p&gt;

&lt;h2 id=&#34;实际体验&#34;&gt;实际体验&lt;/h2&gt;

&lt;p&gt;要把项目从 Flutter 迁移到 flutter_web 不是一件容易的事。首先 flutter_web 不使用 Cupertino 和 Material，所以 Widget 需要更改；其次它们的依赖库不一样，项目依赖也需要更改。我尝试过把 Flutter 应用迁移到 flutter_web，但是仍然没法处理好这两个问题，所以暂时放弃了。&lt;/p&gt;

&lt;p&gt;我更期待的其实是像 Taro 那样，能够在一个项目中，根据配置和命令的不同，能够编译成不同的版本。这样的好处就是，我们可以直接编译出 Native App 的 H5 版本，这对于一些分享功能是非常方便的，因为分享出来的页面是需要 H5 的。看来 flutter_web 还有很长的路要走，我也很期待它发布正式版的时候会是什么样子。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon AWS Serverless 部署 React 项目</title>
      <link>https://elizurhz.cn/backend/aws-serverless-deployment/</link>
      <pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/backend/aws-serverless-deployment/</guid>
      <description>

&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;

&lt;h2 id=&#34;为什么使用-serverless&#34;&gt;为什么使用 Serverless&lt;/h2&gt;

&lt;p&gt;因为它是按量(请求数)付费的，相比于 EC 或者容器的按时间付费会节省很多成本，并且 EC 往往会遇到带宽限制的问题，增加带宽会提高很多成本。&lt;/p&gt;

&lt;h2 id=&#34;prerequisite&#34;&gt;Prerequisite&lt;/h2&gt;

&lt;p&gt;如果要使用 Amazon AWS Serverless 来部署 React 项目，我们需要一个叫做 &lt;code&gt;serverless&lt;/code&gt; 的 npm package。同时我们还需要在项目下编写 &lt;code&gt;serverless.yml&lt;/code&gt;。具体的写法可以参考 &lt;code&gt;serverless&lt;/code&gt; 的&lt;a href=&#34;https://serverless.com/&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;csr-create-react-app&#34;&gt;CSR(create-react-app)&lt;/h1&gt;

&lt;p&gt;客户端渲染，也就是我们最常用的 create-react-app 搭出来的项目，使用 Serverless 的方式部署到 AWS 其实很简单。要让我们的部署能够运行起来，在 AWS 上我们只需要一个服务：S3。S3 有一个静态页面托管的服务，并且会自动生成一个可访问的地址。这个静态站点可以运行我们打包好的 web app。&lt;/p&gt;

&lt;h2 id=&#34;手动部署&#34;&gt;手动部署&lt;/h2&gt;

&lt;p&gt;首先只要在 AWS S3 的控制面板里创建存储桶就可以了，配置可以都用默认配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其次，我们需要进入已经建好的存储桶，把静态网站托管打开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着我们需要注意，一定要把 error.html 指向 index.html。因为我们可能在项目中使用 react-router，而在 S3 的静态文件托管中，任何子路径都会被认为是 error，因为我们使用 create-react-app 创建的项目，入口文件只有一个 index.html，而不是有其他 html 文件的多页面应用。只有把错误页面指向 index.html，才能正常使用 react-router。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里会显示该存储桶的访问地址，通过这个地址就可以访问了。接着我们在存储桶的“概述”标签页上传我们打包好的文件（index.html 需要在存储桶的根目录），这样我们的站点就可以访问了。&lt;/p&gt;

&lt;p&gt;如果需要 https，我们可以在 CloudFront 上创建一个域名，把源指向我们的 S3 bucket 就可以了。这个过程无需我们申请任何的证书。&lt;/p&gt;

&lt;h2 id=&#34;serverless-命令行部署&#34;&gt;serverless 命令行部署&lt;/h2&gt;

&lt;p&gt;首先我们需要安装 serverless：运行 &lt;code&gt;yarn add --global serverless&lt;/code&gt;(如果你安装了 yarn) 或者 &lt;code&gt;npm install -g serverless&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;serverless 这个 npm package 可以使用插件来辅助进行部署。这里推荐使用 &lt;code&gt;serverless-finch&lt;/code&gt; 进行部署。我们需要编写一个 &lt;code&gt;serverless.yml&lt;/code&gt; 文件，serverless 包会读取这个文件的配置进行部署。参考配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;service: your-app-name

frameworkVersion: &amp;quot;=1.38.0&amp;quot;

# AWS 的配置
provider:
  name: aws
  runtime: nodejs6.10
  stage: dev
  region: us-east-2
  profile: default

plugins:
  - serverless-finch

# 以下为 serverless-finch 的配置
custom:
  client:
    bucketName: your-bucket-name # 需要和 S3 上创建的 bucket 同名
    distributionFolder: build # 本地打包的输出目录
    indexDocument: index.html # 同 S3 上静态文件托管中设置的入口文档
    errorDocument: index.html # 同 S3 上静态文件托管中设置的错误文档
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们需要在 AWS Console 的 IAM 上创建一个能读写 S3 的角色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进入 IAM 的控制台，左侧菜单选择“用户”，然后添加用户。接着填写用户名，并且需要勾选“编程访问”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着要给创建的用户附加权限，这边推荐可以选择 AmazonS3FullAccess。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/aws-serverless-deployment/aws-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成创建之后，这里会出现 ID 和密钥，接着我们需要用它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;serverless config credentials --provider aws --key [YOUR_KEY] --secret [YOUR_SECRET]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 key 填写 ID，secret 填写密钥。这一步是设置我们 serverless 的当前用户权限。&lt;strong&gt;注意如果需要切换用户，需要用 AWS CLI 来切换，实测 serverless 中覆盖掉 credentials 的配置并不会生效。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样我们就完成了配置。需要部署的时候，我们只需要打包好文件，然后运行 &lt;code&gt;serverless client deploy&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h1 id=&#34;ssr-next-js&#34;&gt;SSR(Next.js)&lt;/h1&gt;

&lt;p&gt;由于篇幅限制，并且我个人踩坑踩了好几个星期，很多细节没法回忆起来或者无法详细说明。并且作为前端开发者，我们其实并不需要了解整个 AWS Serverless 的工作原理，我们只需要配合后端/运维人员把我们代码层面需要做的做好即可。所以这里只提供一个大概的方案。&lt;/p&gt;

&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;

&lt;p&gt;与 CSR App 不同的是，SSR App 部署完成后并不能直接访问静态页面，而是要通过 API Gateway 去访问（地址会在部署完之后显示在命令行，或者可以在 AWS 的 API Gateway 控制台查看）。当我们访问 API Gateway 时，API Gateway 会解析相应的请求（也就是路由），并转发至 AWS Lambda。而 AWS Lambda 则会根据我们写好的 Lambda 函数（&lt;code&gt;./server/lambda.js&lt;/code&gt;）来访问 S3 上存储的对应的静态文件。&lt;/p&gt;

&lt;p&gt;当然我们也可以设置自定义的域名，但是最好是在 Route53 申请，这样才能享受到 AWS 的一系列服务（全家桶）。&lt;/p&gt;

&lt;h2 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h2&gt;

&lt;p&gt;API Gateway 有几个基本概念/配置项。&lt;/p&gt;

&lt;p&gt;首先是 stage，它代表的是不同的阶段，例如开发环境、测试环境、生产环境等等。在 API Gateway 的访问域名中会有一个 &lt;code&gt;/{stage}&lt;/code&gt; 的路径。&lt;/p&gt;

&lt;p&gt;其次是&amp;rdquo;资源&amp;rdquo;，这里就是配置 API 访问的了。我们只需要设置一个通用的访问如 &lt;code&gt;/{proxy+}&lt;/code&gt; 即可，因为我们有许多路由，不可能每个都配置到这里来，而不可访问的路由最好使用 Next.js 中的 &lt;code&gt;_error.js&lt;/code&gt; 来做，而不是在这里限制。&lt;/p&gt;

&lt;h2 id=&#34;serverless&#34;&gt;serverless&lt;/h2&gt;

&lt;p&gt;这里会使用到一些不同的插件，原来的 serverless-finch 将不再使用，因为它是设置静态文件托管的。这里使用到了两个：&lt;code&gt;serverless-apigw-binary&lt;/code&gt; 和 &lt;code&gt;serverless-domain-manager&lt;/code&gt;。&lt;code&gt;serverless-apigw-binary&lt;/code&gt; 是用于配置 API Gateway 的，而 &lt;code&gt;serverless-domain-manager&lt;/code&gt; 可以把自定义域名到 S3 bucket 的整个流程的配置都配置好。由于涉及到机密问题，这里就不把 &lt;code&gt;serverless.yml&lt;/code&gt; 放出来了，具体可以去搜索一下这两个包的使用方式。&lt;/p&gt;

&lt;h2 id=&#34;lambda&#34;&gt;Lambda&lt;/h2&gt;

&lt;p&gt;Lambda 其实就是一个压缩文件，里面是各种函数包。它实际上有点类似于一个小型的虚拟机，所以 Next.js 中每个页面打包出来都有 5.9MB。AWS 上的 Lambda 平台会做一个从 API Gateway 到我们上传的函数包中对应的文件的映射，这样就实现了路由功能。&lt;/p&gt;

&lt;p&gt;Lambda 在 SSR(Next.js) 中其实就是那个进行渲染和路由导航的 Node.js 服务。而实际上它就是一个 Node 服务器，可以用任意的 Node 框架来写。这里我使用的是 Express。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const express = require(&amp;quot;express&amp;quot;);
const routes = require(&amp;quot;./routes&amp;quot;); // next-routes 做的自定义路由

const app = express();

// host the static files
app.use(&amp;quot;/_next/static&amp;quot;, express.static(path.join(__dirname, &amp;quot;/static&amp;quot;)));
app.use(&amp;quot;/static&amp;quot;, express.static(&amp;quot;static&amp;quot;));

app.get(&amp;quot;*&amp;quot;, (req, res) =&amp;gt; {
  const parsedUrl = parse(req.url, true);
  const { pathname, query, search } = parsedUrl;

  // Map url to page directory
  const matchRoute = routes.match(pathname);
  if (matchRoute &amp;amp;&amp;amp; matchRoute.route) {
    const page = matchRoute.route.page;
    const params = matchRoute.params;

    if (params) {
      if (search) {
        req.url += &amp;quot;&amp;amp;&amp;quot; + querystring.stringify(params);
      } else {
        req.url += &amp;quot;?&amp;quot; + querystring.stringify(params);
      }

      try {
        __non_webpack_require__(`./serverless/pages${page}`).render(
          req,
          res,
          parsedUrl,
          Object.assign(params, query)
        );
      } catch (err) {
        __non_webpack_require__(&amp;quot;./serverless/pages/_error&amp;quot;).render(
          req,
          res,
          parsedUrl,
          Object.assign(params, query)
        );
      }
    } else {
      try {
        __non_webpack_require__(`./serverless/pages${page}`).render(
          req,
          res,
          parsedUrl
        );
      } catch (err) {
        __non_webpack_require__(&amp;quot;./serverless/pages/_error&amp;quot;).render(
          req,
          res,
          parsedUrl
        );
      }
    }
  } else {
    __non_webpack_require__(&amp;quot;./serverless/pages/_error&amp;quot;).render(
      req,
      res,
      parsedUrl
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边实际上就是在做路由的映射，然后载入 Next.js 打包出来对应的页面入口，接着就可以使用 React 的能力进行渲染。关于 Next.js，可以参考我的另一篇博文：&lt;a href=&#34;https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/&#34;&gt;Next.js 实战：从 CSR 迁移到 SSR&lt;/a&gt;。但是在实际生产中，这个文件是需要被编译成 ES5 的。所以我们还需要写一个 Webpack 配置来打包它，只需要在根目录建一个 &lt;code&gt;webpack.config.js&lt;/code&gt; 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// webpack.config.js
const path = require(&amp;quot;path&amp;quot;);
const CopyWebpackPlugin = require(&amp;quot;copy-webpack-plugin&amp;quot;);

const LAMBDA_FILE_LOC = path.join(__dirname, &amp;quot;./server/lambda.js&amp;quot;);
const LAMBDA_DIR = path.join(__dirname, &amp;quot;./build&amp;quot;);
const LAMBDA_FILE_PROD = &amp;quot;./lambda_prod.js&amp;quot;;

const plugins = [
  new CopyWebpackPlugin([
    // your custom config
  ])
];

// 打包配置
module.exports = {
  entry: LAMBDA_FILE_LOC,
  externals: [&amp;quot;aws-sdk&amp;quot;], // 设置成 AWS Lambda 支持的格式
  output: {
    libraryTarget: &amp;quot;commonjs&amp;quot;,
    filename: LAMBDA_FILE_PROD,
    path: LAMBDA_DIR
  },
  target: &amp;quot;node&amp;quot;,
  node: {
    __filename: false,
    __dirname: false
  },
  mode: &amp;quot;production&amp;quot;,
  plugins
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 &lt;code&gt;npx webpack&lt;/code&gt; 即可进行打包。使用 &lt;code&gt;CopyWebpackPlugin&lt;/code&gt; 的原因主要是，我们会遇到一些文件无法被 Next.js 打包，但是它们又是 Web App 运行必需的，或者是 AWS Lambda 的函数包需要的。所以我们只能手动把它们拷贝到 Next.js 的 build 目录，因为 serverless 会根据这个目录来打包出 AWS Lambda 所需的函数包。&lt;/p&gt;

&lt;h2 id=&#34;部署流程&#34;&gt;部署流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先会先运行 &lt;code&gt;next build&lt;/code&gt;，将文件打包至 &lt;code&gt;./build&lt;/code&gt; 目录。由于在 &lt;code&gt;next.config.js&lt;/code&gt; 中设置了 &lt;code&gt;target: &#39;serverless&#39;&lt;/code&gt;，所以打包出来的文件是 serverless 的版本，会与云主机、容器部署的版本不同。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译 &lt;code&gt;./server/lambda.js&lt;/code&gt;. 并在 &lt;code&gt;./build&lt;/code&gt; 目录下生成 &lt;code&gt;lambda_prod.js&lt;/code&gt;。这一步主要是要把 ES6 写的 lambda 函数编译成 ES5，这样 AWS Lambda 才能正常访问它。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将所需文件打包成 &lt;code&gt;.zip&lt;/code&gt;。压缩文件会在 &lt;code&gt;./.serverless&lt;/code&gt; 目录下生成。 需要打包的内容可以在 &lt;code&gt;serverless.yml&lt;/code&gt; 的如下字段中设置：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package:
  exclude:
    - ./**
  include:
    - build/**
    - static/**
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;上传压缩文件至 S3，同时会自动修改 API Gateway 和 AWS Lambda 的相应设置。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>React Hooks 能给我们带来什么</title>
      <link>https://elizurhz.cn/frontend/how-hooks-helps/</link>
      <pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/how-hooks-helps/</guid>
      <description>

&lt;h1 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h1&gt;

&lt;p&gt;很多 React 的新技术，我们大多数人也只是听说而已，实际上投入生产的机会非常少。首先很多旧项目不会去升级 React 的版本，很多团队因为不精通技术而且只需要专注于做业务，所以也没有这样的成本来升级 React 的版本。而我刚好遇到了好的机会，让我有足够的技术自由度，我也趁着一个重构的机会，顺便把负责组件全部用 hooks 重构了。这次重构是在 2019 年 6 月下旬开始的，并且也要感谢 react-redux 在 6 月上旬的时候发布了 v7.1.0，Hooks API 正式投入生产了，让我能够大展身手。&lt;/p&gt;

&lt;p&gt;这篇文章不会涉及到 React 中所有 Hooks 的细节，而是就开发而言谈谈常用的一些 Hooks，特别是最近推出的、让 redux app 能够使用 functional component 替代 connect 的 Hooks。&lt;/p&gt;

&lt;h1 id=&#34;before-after-hooks&#34;&gt;Before &amp;amp; After Hooks&lt;/h1&gt;

&lt;p&gt;使用 Hooks 对代码的修改不少，但是完成重构后代码看着会非常简洁，因为少了非常多的代码，我们维护一个组件只需要看一个 function 即可。&lt;/p&gt;

&lt;h2 id=&#34;before&#34;&gt;Before&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/** container.ts */
import { connect } from &#39;react-redux&#39;
import { injectIntl } from &#39;react-intl&#39;
import ComponentA from &#39;./componentA&#39;
import * as actions from &#39;your/path/to/actions&#39;
import { bindActionCreators, Dispatch } from &#39;redux&#39;

function mapStateToProps(state: any): any {
  return {
    variableA: state.stateA.variableA
  }
}

function mapDispatchToProps(dispatch: Dispatch): any {
  return {
    actionA: bindActionCreators(actions.actionA, dispatch)
  }
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(ComponentA) as any
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;/** component.tsx */
interface Props {
  actionA: () =&amp;gt; void;
  variableA: string;
}

export default class ComponentA extends React.Component {
  public render(): JSX.Element {
    return &amp;lt;div onClick={() =&amp;gt; this.props.actionA}&amp;gt;{this.props.variableA}&amp;lt;/div&amp;gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;after&#34;&gt;After&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;/** index.tsx */
import * as React from &amp;quot;react&amp;quot;;
import { useDispatch, useSelector, shallowEqual } from &amp;quot;react-redux&amp;quot;;
import * as actions from &amp;quot;path/to/actions&amp;quot;;

interface Props {
  stateA: string;
}

export const ComponentA = (props: Props) =&amp;gt; {
  const dispatch = useDispatch();
  const variableA = useSelector(
    (state: any) =&amp;gt; state.stateA.variableA,
    shallowEqual
  );

  return &amp;lt;div onClick={() =&amp;gt; dispatch(actions.actionA())}&amp;gt;{variableA}&amp;lt;/div&amp;gt;;
};

export default injectIntl(React.memo(ComponentA));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;so&#34;&gt;So?&lt;/h2&gt;

&lt;p&gt;从改造前的代码和改造后的代码中，我们可以看出，使用 Hooks 确实节省了很多代码的行数。在 connect 的写法中，上面的例子并未指定 mapDispatchToProps 的返回值类型。而在 dumb component 中，组件的 action 类型其实是遵循于组件内定义的 props 的类型的，如果我们在组件内定义的 action 类型和 action creator 中定义的类型不同，例如传入参数不同，那么实际上 TypeScript 是检测不出这个问题的。这样就会引起不必要的 Bug。而使用 Hooks 完全可以避免这个问题，因为我们是直接把 action creator 引进来的，TypeScript 可以识别出 action creator 中定义的类型。也就是说如果你传入了错误的参数，那么此时 TypeScript 编译是不会通过的。所以可见，使用 Hooks 可以减少开发中产生 bug 的几率，也简化了代码，更易读更易维护。&lt;/p&gt;

&lt;h1 id=&#34;tech-spec&#34;&gt;Tech Spec&lt;/h1&gt;

&lt;h2 id=&#34;useeffect&#34;&gt;useEffect&lt;/h2&gt;

&lt;p&gt;Class Component 对于我们来说有足够的功能新，因为我们可以通过自定义生命周期钩子来实现很多复杂的功能，这是在 React v16.8 前 Functional Component 无法实现的。这也是之前我喜欢用 Class Component 的原因。而 useEffect 这个近乎“万能”的 hook 可以实现几乎所有的生命周期钩子，这对于 Functional Component 非常关键，也是我重构组件最依赖的一个 hook。useEffect 的类型签名如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function useEffect(effect: EffectCallback, deps?: DependencyList): void;

type EffectCallback = () =&amp;gt; (void | (() =&amp;gt; void | undefined));
type DependencyList = ReadonlyArray&amp;lt;any&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;useEffect&lt;/code&gt; 有两个参数，第一个参数是一个 callback，里面写的是我们的逻辑。而第二个参数不要小看它，虽然它是可选参数，但是如何玩转 &lt;code&gt;useEffect&lt;/code&gt; 完全就靠它了！它是“依赖”，React 官网也有不小的篇幅来描述怎样使用它。简而言之，这个“依赖”，就是&lt;strong&gt;当它改变的时候才会执行里面的 callback&lt;/strong&gt;。先说下不传这个参数的情况，那就是每次 re-render 都会调用这个 hook。而我们在实际开发中往往不会希望我们所有的 &lt;code&gt;useEffect&lt;/code&gt; 的 callback 在每次渲染都被调用一次。所以“依赖”的作用就在于此，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;useEffect(() =&amp;gt; {
  console.log(props.name)
}, [props.name])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 hook 只会在 &lt;code&gt;props.name&lt;/code&gt; 发生变化的时候把 &lt;code&gt;props.name&lt;/code&gt; 在控制台打印出来。这个相当于 Class Component 中的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;public componentDidUpdate(prevProps) {
  if (this.props.name !== prevProps.name) {
    console.log(this.props.name)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是即将被废弃的 &lt;code&gt;componentWillReceiveProps&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而如果我们修改一下这个依赖呢？这其实挺纠结的，因为如果你在你的项目中使用了 eslint，那么这里它会提示一个 &lt;code&gt;exhaustive-deps&lt;/code&gt; 的 warning。而如果你开了 Prettier 的 eslint 错误自动修复。。。那不好意思，要么你只能不写，要么会被强制改成里面所有用到的依赖，如 state、props 或者其他变量等。起初我也陷入了深思，到底是不允许这么写，还是 eslint 有毛病呢？但是实际上，我们应该先抛弃 eslint，先在这将它 disable 了，因为 &lt;code&gt;useEffect&lt;/code&gt; 能够做到的远比我们想象的多。&lt;/p&gt;

&lt;p&gt;上面既然我们实现了 &lt;code&gt;componentDidUpdate&lt;/code&gt;，那其他的钩子呢？有两个很关键的钩子 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; 我们还不知道怎么实现呢。而我之前提到它是“近乎‘万能’”的，是的，它就是可以实现这些生命周期钩子的效果。&lt;/p&gt;

&lt;p&gt;为了实现 &lt;code&gt;componentDidMount&lt;/code&gt;，我们只需要在依赖中传入一个空数组 &lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而为了实现 &lt;code&gt;componentWillUnmount&lt;/code&gt;，我们只需要在 &lt;code&gt;useEffect&lt;/code&gt; 中 return 一个 callback，那个 callback 便是在 &lt;code&gt;componentWillUnmount&lt;/code&gt; 时执行的。上面提到的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;type EffectCallback = () =&amp;gt; (void | (() =&amp;gt; void | undefined));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是有写返回值类型的，而它也不是白写的，正是用在这种场景。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;依赖很万能，但是不要乱用，因为乱写依赖会导致你的组件渲染的行为异常，甚至会导致 Infinite Loop (&lt;code&gt;useEffect&lt;/code&gt; 的 callback 触发了某个变量的变化导致了 re-render, 而 re-render 又触发了 useEffect 并运行了 callback)。因为 re-render 大概是我们在 React 开发中最经常需要处理的一件事了，所以用好 &lt;code&gt;useEffect&lt;/code&gt; 是用好 React hooks 的关键。&lt;/p&gt;

&lt;h2 id=&#34;hooks-in-react-redux&#34;&gt;Hooks in react-redux&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://react-redux.js.org/api/hooks&#34;&gt;Hooks&lt;/a&gt; 在 react-redux 中有专门的文档介绍。常用的 API 其实就两个：用于获取 state 的 &lt;code&gt;useSelector&lt;/code&gt; 和用户 dispatch action 的 &lt;code&gt;useDispatch&lt;/code&gt;。使用的方式很简单，参考官方文档就可以了。&lt;/p&gt;

&lt;h3 id=&#34;useselector&#34;&gt;useSelector&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;useSelector&lt;/code&gt; 允许我们使用 &lt;code&gt;reselect&lt;/code&gt; 的 selector 进行 memorize 的操作，也可以直接从 redux store 中获取相应的 property。但是有个“比较”的问题，就是官方文档使用了 === 的比较（&lt;a href=&#34;https://github.com/reduxjs/react-redux/blob/316467a07e29911d82ba0342364a907e05d9066c/src/hooks/useSelector.js#L17&#34;&gt;参考源码&lt;/a&gt;），而如果我们 select 出来的是 Object，那每次比较出来的 Object 都是不同的。因为 reducer 遵循了纯函数的原则，每次都会 return 一个新的 state，而 state 是一个 JavaScript Plain Object，也就是说每次 return 出来的 Object 指向的内存地址都是不同的，那么 select 出来的 Object 也是不同的。这样就会导致&lt;strong&gt;每次 redux store 有变化，这个组件就会重新渲染&lt;/strong&gt;。这时候我们就需要浅比较了。官方给我们提供了一个 &lt;code&gt;shallowEqual&lt;/code&gt; 函数，让我们可以做浅比较。这个方法其实在早前的 react-redux 版本中就有了，因为之前 react-redux 的 connect 就是用了 shallowEqual 的。当然我们也可以使用诸如 lodash 中的浅比较方法。&lt;/p&gt;

&lt;h3 id=&#34;usedispatch&#34;&gt;useDispatch&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;useDispatch&lt;/code&gt; 其实没有什么好说的，它就是一个函数，不接收任何参数，只能在组件中使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const dispatch = useDispatch()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的功能就是 redux 中的 &lt;code&gt;store.dispatch&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;react-memo&#34;&gt;React.memo&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;React.memo&lt;/code&gt; 其实并不是 Hooks 的内容，但是由于我们只能在 Functional Component 中使用 Hooks，Class Component 中能用的生命周期钩子也都不能用，所以之前的
&lt;code&gt;React.PureComponent&lt;/code&gt; 和 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 也都无法使用。那么对于应用优化，我们常用的手段在 Functional Component 中都无法使用了。&lt;code&gt;React.memo&lt;/code&gt; 的出现就很有效地解决了这个问题。它能实现与 &lt;code&gt;React.PureComponent&lt;/code&gt; 和 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 相同的功能，就是防止父组件 re-render 导致的子组件的不必要的 re-render。&lt;/p&gt;

&lt;p&gt;对于“不必要的 re-render”，举个例子来说，就是父组件使用 &lt;code&gt;useSelector&lt;/code&gt; 订阅了 redux store 的某个属性，但是它与子组件无关。如果这个属性有变化，那么按照 React 的 diff 算法，它的子组件都会 re-render 一遍。这也不能说 React 本身有问题，因为 diff 算法已经足够好，能够高效地解决 React 渲染计算的问题。那么我们其实是不希望与该属性无关的子组件去 re-render 的，因为对我们来说它其实一点变化都没有。所以 &lt;code&gt;React.memo&lt;/code&gt;、&lt;code&gt;React.PureComponent&lt;/code&gt; 和 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 就是用于解决这种问题的。&lt;/p&gt;

&lt;p&gt;它在 react-redux 中也挺重要的，因为官方说 &lt;code&gt;useSelector&lt;/code&gt; 不会阻止子组件的不必要的 re-render，而官方也推荐使用 &lt;code&gt;React.memo&lt;/code&gt; 进行优化。&lt;/p&gt;

&lt;h2 id=&#34;单元测试&#34;&gt;单元测试&lt;/h2&gt;

&lt;p&gt;其实 Hooks 并不是完美的，比如单元测试。&lt;/p&gt;

&lt;p&gt;Jest + Enzyme 是 React 中常用的单元测试库，但是 Enzyme 官方文档中提到：&lt;code&gt;With React 16 and above, instance() returns null for stateless functional components.&lt;/code&gt;。对于 Hooks 而言（使用了 Hooks 的组件必然是 functional components），虽然官方文档也说明了&lt;a href=&#34;https://github.com/airbnb/enzyme#react-hooks-support&#34;&gt;对 Hooks 的支持&lt;/a&gt;：目前只在 &lt;code&gt;shallow()&lt;/code&gt; 里提供有限的支持，但是想要照搬 class component 中用的测试套路显然是不行的。React 官方则推荐使用 &lt;a href=&#34;https://github.com/testing-library/react-testing-library&#34;&gt;react-testing-library&lt;/a&gt; 来测试。&lt;strong&gt;但是这些目前只能测试 React 官方的 Hooks，对于 react-redux 的 &lt;code&gt;useDispatch&lt;/code&gt; 和 &lt;code&gt;useSelector&lt;/code&gt;，目前我还没有找到测试的方法，也没有找到相关的教程或者文档，甚至 react-redux 官方也没有详细的教程。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相比之下，class component 可以直接把所有的 connect 以及其他高阶组件和 dumb component 剥离开来测试，因为我们测试组件仅仅关注的是 dumb component 上的逻辑，高阶组件注入的 props 完全可以通过 mock 来做（通常我会直接无视 TypeScript 的类型错误，因为很多 props 其实测试中是不必要的，例如 react-intl 的高阶组件注入的那些 props）。但是对于 Hooks，没有了 connect，也就是说 redux 和 dumb component 其实是耦合在一起了，做单元测试首先就会提示，必须用 react-redux 的 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 把组件包裹起来。这样其实无形中增加了测试的难度。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;Hooks 是个新技术，它确实给我们的开发带来了便利，但是单元测试上却并不是那么容易。这也是我们经常遇到的问题，就是只在意功能而忽视了代码质量。只有功能和质量同时有保障的代码才是好的代码。关于单元测试这部分，我会继续研究并继续关注社区上的相关动态。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Next.js 实战：从 CSR 迁移到 SSR</title>
      <link>https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/mirgation-from-csr-to-ssr/</guid>
      <description>

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CSR: 客户端渲染，Client Side Rendering&lt;/li&gt;
&lt;li&gt;SSR: 服务端渲染，Server Side Rendering&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;目前正在做一个项目，由于采用了敏捷开发，所以我们的自主权比较大，领导也让我们尝试使用 SSR，所以我们自然而然在原有的 create-react-app 创建的应用的基础上选择了 Next.js。&lt;/p&gt;

&lt;p&gt;下面大致说明一下 SSR 项目与 CSR 项目到底有什么不同。&lt;/p&gt;

&lt;h2 id=&#34;关于浏览器与-dom&#34;&gt;关于浏览器与 DOM&lt;/h2&gt;

&lt;p&gt;SSR 项目还是一个运行在浏览器的项目，所以是可以支持浏览器 API 的，但是它是由一个 Node.js 服务器来写入 html，而不是像 CSR 一样加载静态的 js 来渲染。这样会导致问题就是，如果在渲染时立即调用了浏览器/DOM 相关的 API，此时可能浏览器环境还未加载完成，那么就会出现 &lt;code&gt;document is not defined&lt;/code&gt; 的错误。&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;document is not defined&lt;/code&gt;，比较常遇到的情况有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面调用了 document、window 相关的 API&lt;/li&gt;
&lt;li&gt;使用了 ReactDOM.createPortal。由于 ReactDOM.createPortal 必须有一个挂载的 DOM 节点，所以在浏览器环境完成前是无法使用的，解决方法就是在 &lt;code&gt;componentDidMount&lt;/code&gt; 之后再加载：用变量进行条件渲染，参考&lt;a href=&#34;https://github.com/zeit/next.js/tree/canary/examples/with-portals&#34;&gt;官方例子&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;某些组件如果使用 DOM API，且在被引用时未使用 &lt;code&gt;next/dynamic&lt;/code&gt; 进行异步加载，也可能会导致这种问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;packages&#34;&gt;Packages&lt;/h2&gt;

&lt;p&gt;大部分 CSR App 中关键的 packages 都可以直接在 Next.js 中使用，例如 redux, redux-saga, react-intl 等，但是使用的方式和在 CSR App 中的有所区别。另外，Next.js 中需要使用 &lt;code&gt;@zeit&lt;/code&gt; 的一些 packages，它们与 SSR 相关。&lt;/p&gt;

&lt;h2 id=&#34;next-config-js&#34;&gt;next.config.js&lt;/h2&gt;

&lt;p&gt;这个是放在根目录的 next 的配置文件，我们在这里可以配置一些 webpack loaders 的支持，例如 CSS（如果不配置就只能支持行内和 styled-jsx）, SASS, TypeScript 等，需要安装一些 &lt;code&gt;@zeit&lt;/code&gt; 的 plugins。&lt;/p&gt;

&lt;p&gt;根据项目需求，我做了如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const withTypescript = require(&amp;quot;@zeit/next-typescript&amp;quot;);
const withCSS = require(&amp;quot;@zeit/next-css&amp;quot;);
const withSass = require(&amp;quot;@zeit/next-sass&amp;quot;);

module.exports = withSass(withCSS(withTypescript()));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;样式&#34;&gt;样式&lt;/h3&gt;

&lt;p&gt;在 Next.js 中，样式默认使用的是 React 的 inline style 或者 Next.js 的 styled-jsx，它们只能写在组件文件中。如果需要使用独立的 css 文件或者其他 css 预处理器，那么需要安装相关的&lt;a href=&#34;https://nextjs.org/docs/#importing-css--sass--less--stylus-files&#34;&gt;插件&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;就如上面代码所示，插件安装完之后需要在 &lt;code&gt;next.config.js&lt;/code&gt; 中进行配置。&lt;/p&gt;

&lt;h3 id=&#34;typescript&#34;&gt;TypeScript&lt;/h3&gt;

&lt;p&gt;Next.js 官方有 TypeScript 支持，需要安装 &lt;code&gt;@zeit/next-typescript&lt;/code&gt; 这个插件，并配置 &lt;code&gt;tsconfig.json&lt;/code&gt; 和 &lt;code&gt;next.config.js&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;server-js&#34;&gt;server.js&lt;/h2&gt;

&lt;p&gt;这是 SSR 和 CSR 最大的不同 —— 我们需要一个 Node.js 服务器。在 &lt;code&gt;package.json&lt;/code&gt; 中，默认的 &lt;code&gt;scripts&lt;/code&gt; 会运行 &lt;code&gt;next&lt;/code&gt; 这个命令，启动的是 Next.js 内置的 SSR 服务器，而如果我们写一个 Node.js 服务器，并在 &lt;code&gt;scripts&lt;/code&gt; 中运行它，同样可以实现 SSR 的功能，并且我们还可以在里面定制路由、渲染方式、缓存等等。&lt;/p&gt;

&lt;h3 id=&#34;路由&#34;&gt;路由&lt;/h3&gt;

&lt;p&gt;在 Next.js 中，我们使用 Node.js 框架（Koa）的路由，所以 &lt;code&gt;react-router&lt;/code&gt; 相关的代码都必须更改。详情可以参考&lt;a href=&#34;https://nextjs.org/docs/#routing&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;react-router&lt;/code&gt; 的 history 无法在 Next.js 中使用，我们可以使用 &lt;code&gt;next/router&lt;/code&gt; 替代之（&lt;code&gt;import Router from &#39;next/router&#39;&lt;/code&gt;）。例如 &lt;code&gt;history.push()&lt;/code&gt; 可以用 &lt;code&gt;Router.push()&lt;/code&gt; 替代；也可以 &lt;code&gt;import { withRouter } from &#39;next/router&#39;&lt;/code&gt; 来把路由参数注入到组件的 props 中。&lt;/li&gt;
&lt;li&gt;原本的 &lt;code&gt;react-router-dom&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 可以被 &lt;code&gt;next/link&lt;/code&gt; 的 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 取代，但是 props 有所不同，比如 &lt;code&gt;to&lt;/code&gt; 需要换成 &lt;code&gt;href&lt;/code&gt;，以及 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 中不能使用 text 节点等。&lt;/li&gt;
&lt;li&gt;路由与 &lt;code&gt;.js/.tsx&lt;/code&gt; 文件的绑定在 Koa 中完成，使用 &lt;code&gt;koa-router&lt;/code&gt; 的写法，当浏览器访问路由时，由服务端的中间件设置对应的 return body 并返回给前端。具体可以参考 &lt;a href=&#34;https://github.com/ZijianHe/koa-router&#34;&gt;koa-router&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;国际化&#34;&gt;国际化&lt;/h3&gt;

&lt;p&gt;国际化的方式已经在上面的 &lt;code&gt;server.js&lt;/code&gt; 的部分叙述过。在项目中我们一样需要一个存放 &lt;code&gt;.json&lt;/code&gt; 翻译文件的地方。&lt;/p&gt;

&lt;p&gt;下面是一段官方的代码示例，我在官方使用的 express 框架的基础上将其修改成了适用于 koa 的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const supportedLanguages = glob
  .sync(&amp;quot;./lang/*.json&amp;quot;)
  .map(f =&amp;gt; basename(f, &amp;quot;.json&amp;quot;));
const localeDataCache = new Map();
const getLocaleDataScript = locale =&amp;gt; {
  const lang = locale.split(&amp;quot;-&amp;quot;)[0];
  if (!localeDataCache.has(lang)) {
    const localeDataFile = require.resolve(`react-intl/locale-data/${lang}`);
    const localeDataScript = readFileSync(localeDataFile, &amp;quot;utf8&amp;quot;);
    localeDataCache.set(lang, localeDataScript);
  }
  return localeDataCache.get(lang);
};

const getMessages = locale =&amp;gt; {
  return require(`./lang/${locale}.json`);
};

const localization = ctx =&amp;gt; {
  const { req } = ctx;
  const { query } = ctx.request;
  let locale;
  if (query.lang) {
    locale = query.lang;
  } else {
    const accept = accepts(req);
    locale = accept.language(accept.languages(supportedLanguages)) || &amp;quot;en&amp;quot;;
  }
  req.locale = locale;
  req.localeDataScript = getLocaleDataScript(locale);
  req.messages = getMessages(locale);
  ctx.req = req;
  return ctx;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的目的是修改前端请求时的 context。来当浏览器访问路由时，服务端对应的 &lt;code&gt;Controller&lt;/code&gt; 可以获取到 koa 的 &lt;code&gt;context&lt;/code&gt; 对象，并通过一些方法把当前所需的国际化的文件内容加入到 &lt;code&gt;context.req&lt;/code&gt; 中，这样前端页面就可以接收到这些数据。&lt;/p&gt;

&lt;p&gt;在路由的 &lt;code&gt;Controller&lt;/code&gt; 处理 ctx 的时候，我们只需要调用 &lt;code&gt;localization&lt;/code&gt; 这个函数，对 ctx 进行一层“包装”即可。&lt;/p&gt;

&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;

&lt;p&gt;React SSR 或者说 Next.js 里，最常用的页面缓存工具就是 &lt;code&gt;lru-cache&lt;/code&gt; 了。使用 &lt;code&gt;lru-cache&lt;/code&gt; 可以减少不必要的渲染以及加快加载的速度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const getCacheKey = req =&amp;gt; `${req.url}`;

function renderAndCache(ctx, pagePath, queryParams) {
  const key = getCacheKey(ctx.req);

  // If we have a page in the cache, let&#39;s serve it
  if (ssrCache.has(key)) {
    console.log(`CACHE HIT: ${key}`);
    ctx.body = ssrCache.get(key);
    return;
  }

  // If not let&#39;s render the page into HTML
  return app
    .renderToHTML(ctx.req, ctx.res, pagePath, queryParams)
    .then(html =&amp;gt; {
      // Let&#39;s cache this page
      console.log(`CACHE MISS: ${key}`);
      ssrCache.set(key, html);
      ctx.body = html;
    })
    .catch(err =&amp;gt; {
      console.log(&amp;quot;ERRR&amp;quot;, err);
      return app.renderError(err, ctx.req, ctx.res, pagePath, queryParams);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的基本原理就是在向前端返回数据时进行判断，如果 存在 cache key，则调取缓存中相应的内容；否则服务端才会根据路由调用相应的 &lt;code&gt;Controller&lt;/code&gt; 向前端返回数据。&lt;/p&gt;

&lt;p&gt;如果需要使用它，我们可以将路由的 &lt;code&gt;Controller&lt;/code&gt; 直接设成 &lt;code&gt;renderAndCache&lt;/code&gt; 函数即可，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;router.get(&amp;quot;/your/path&amp;quot;, async ctx =&amp;gt; renderAndCache(ctx, &amp;quot;/your/path&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要结合国际化来使用，只要对 &lt;code&gt;renderAndCache&lt;/code&gt; 的第一个参数 &lt;code&gt;ctx&lt;/code&gt; 使用上面的 &lt;code&gt;localization&lt;/code&gt; 函数进行处理即可。&lt;/p&gt;

&lt;h2 id=&#34;pages&#34;&gt;pages&lt;/h2&gt;

&lt;p&gt;根目录的 &lt;code&gt;pages&lt;/code&gt; 文件夹是 Next.js 默认的路由对应的页面入口。&lt;/p&gt;

&lt;h3 id=&#34;app-tsx&#34;&gt;_app.tsx&lt;/h3&gt;

&lt;p&gt;这个文件相当于 CSR App 中的 &lt;code&gt;App.tsx&lt;/code&gt;。如果你不创建这个文件，SSR App 也可以运行，因为 Next.js 中有一个默认的 &lt;code&gt;_app.tsx&lt;/code&gt;。我们创建它是因为我们需要重写这个主入口组件，例如加入 Redux 的 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 和 &lt;code&gt;react-intl&lt;/code&gt; 的 &lt;code&gt;&amp;lt;IntlProvider&amp;gt;&lt;/code&gt; 等高阶组件。&lt;/p&gt;

&lt;h3 id=&#34;document-tsx&#34;&gt;_document.tsx&lt;/h3&gt;

&lt;p&gt;与 &lt;code&gt;_app.tsx&lt;/code&gt; 一样，这也是个 Next.js 内置的组件，而如果我们需要实现某霞功能，也需要重写它。它相当于是 CSR App 中的 &lt;code&gt;index.html&lt;/code&gt;。在 &lt;code&gt;_document.tsx&lt;/code&gt; 中，有 &lt;code&gt;&amp;lt;Head /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;Main /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;NextScript /&amp;gt;&lt;/code&gt; 等组件，&lt;code&gt;&amp;lt;Head /&amp;gt;&lt;/code&gt; 对应的就是 html 的 &lt;code&gt;&amp;lt;head /&amp;gt;&lt;/code&gt; 标签，&lt;code&gt;&amp;lt;Main /&amp;gt;&lt;/code&gt; 的位置则会注入 &lt;code&gt;_app.tsx&lt;/code&gt; 这个组件，&lt;code&gt;&amp;lt;NextScript /&amp;gt;&lt;/code&gt; 则是打包后一些 js 文件插入的位置。你可以在里面添加 style 和 script 等标签，它们将最终会渲染在页面上。&lt;code&gt;&amp;lt;NextScript /&amp;gt;&lt;/code&gt; 在 Next.js 的 production 环境中会默认启用 preload，这样可以节约加载的时间。&lt;/p&gt;

&lt;h2 id=&#34;项目结构&#34;&gt;项目结构&lt;/h2&gt;

&lt;p&gt;我们的实践方式是，把 &lt;code&gt;pages&lt;/code&gt; 作为 Container，在这里进行高阶组件的连接，包括 redux、国际化等等。其他的结构与 react + redux + redux-saga 的最佳实践无异。&lt;/p&gt;

&lt;h2 id=&#34;构建方式&#34;&gt;构建方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; 可以启动一个 dev server，它会自动构建项目到根目录下的 &lt;code&gt;.next&lt;/code&gt; 文件夹中，可以在代码保存后热更新。&lt;/li&gt;
&lt;li&gt;如果需要在 EC/Docker 之类的生产环境中运行，需要先 &lt;code&gt;build&lt;/code&gt;，以生产的环境变量构建项目，再 &lt;code&gt;start&lt;/code&gt; 启动服务。这里我们相当于是直接部署/使用了 Node.js 的 runtime，开启了一个 Node.js 进程，所以这一步可以用 pm2 等管理工具来替代。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next export&lt;/code&gt; 是可以输出静态文件的。它是根据 pages 的目录结构输出的，可以不依赖于服务端来展示静态页面，当然正常的 JavaScript 也是可以运行的。但是有一点就是，如果在后端加了一些修改渲染的操作，比如上面提到的缓存和国际化，那在这个打包方式下，它们是完全不可用的。也就是说如果你有在 Node.js 层加入一些除路由外的额外功能，那你是不能使用静态页面的方式构建并直接上传到 github pages 或者 firebase 等托管服务的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;错误提示&#34;&gt;错误提示&lt;/h2&gt;

&lt;p&gt;由于 Next.js 运行时每次都需要编译，如果编译未报错而在运行时报错，那么错误提示只会显示编译完的文件的错误位置，而不像 CSR 一样能显示原始文件的错误位置，这对调试非常不友好。最常遇到的就是 &lt;code&gt;document is not defined&lt;/code&gt;，但是大项目的迁移中很可能不记得自己那个地方用到了 DOM API 导致这样的报错。&lt;/p&gt;

&lt;h2 id=&#34;单元测试&#34;&gt;单元测试&lt;/h2&gt;

&lt;p&gt;由于 &lt;code&gt;create-react-app&lt;/code&gt; 自带 jest 并且将测试命令集成在了 react-scripts 中（inject 之前），我们不需要额外对 jest 的 match、mock、transform 等属性进行配置。在 Next.js 中，我们则需要重新对 jest 进行配置。&lt;/p&gt;

&lt;p&gt;我使用的 jest 配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  moduleFileExtensions: [&amp;quot;ts&amp;quot;, &amp;quot;tsx&amp;quot;, &amp;quot;js&amp;quot;],
  transform: {
    &amp;quot;^.+\\.tsx?$&amp;quot;: &amp;quot;ts-jest&amp;quot;,
    &amp;quot;^.+\\.js$&amp;quot;: &amp;quot;babel-jest&amp;quot;
  },
  testMatch: [&amp;quot;**/*.(test|spec).(ts|tsx)&amp;quot;, &amp;quot;**/__tests__/*&amp;quot;],
  globals: {
    &amp;quot;ts-jest&amp;quot;: {
      babelConfig: true,
      tsConfig: &amp;quot;jest.tsconfig.json&amp;quot;
    }
  },
  coveragePathIgnorePatterns: [&amp;quot;/node_modules/&amp;quot;, &amp;quot;enzyme.js&amp;quot;],
  setupFilesAfterEnv: [&amp;quot;&amp;lt;rootDir&amp;gt;/enzyme.js&amp;quot;],
  coverageReporters: [&amp;quot;json&amp;quot;, &amp;quot;lcov&amp;quot;, &amp;quot;text&amp;quot;, &amp;quot;text-summary&amp;quot;],
  moduleNameMapper: {
    &amp;quot;\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$&amp;quot;:
      &amp;quot;&amp;lt;rootDir&amp;gt;/__mocks__/fileMock.js&amp;quot;,
    &amp;quot;\\.(css|less|scss)$&amp;quot;: &amp;quot;&amp;lt;rootDir&amp;gt;/__mocks__/styleMock.js&amp;quot;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们项目使用了 TypeScript，所以需要用 ts-jest 来解析 TypeScript，同时我们需要配置一下运行单元测试是的 TypeScript 编译规则，也就是 &lt;code&gt;jest.tsconfig.json&lt;/code&gt; 这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;esnext&amp;quot;,
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;sourceMap&amp;quot;: false,
    &amp;quot;experimentalDecorators&amp;quot;: true,
    &amp;quot;noImplicitUseStrict&amp;quot;: true,
    &amp;quot;removeComments&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;lib&amp;quot;: [&amp;quot;es2017&amp;quot;, &amp;quot;dom&amp;quot;],
    &amp;quot;typeRoots&amp;quot;: [&amp;quot;node_modules/@types&amp;quot;]
  },
  &amp;quot;exclude&amp;quot;: [&amp;quot;node_modules&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;.next&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的配置仍然存在一个问题，就是：jest 中无法正常解析某些 import 语句。&lt;code&gt;&amp;quot;allowSyntheticDefaultImports&amp;quot;: true&lt;/code&gt; 这个 TypeScript 配置的目的是允许 default import。在某些包里是没有 default export 的，例如 React。在 JavaScript 中我们可以用 &lt;code&gt;import React from &#39;react&#39;&lt;/code&gt; 的原因是这个是直接从 react 包本体中引入的，而 react 包中是有 &lt;code&gt;module.exports&lt;/code&gt; 的语句的。但是在 TypeScript 中，import 实际上解析到的并不是 react 包本体，而是 &lt;code&gt;@types/react&lt;/code&gt; 这个包。而这个包的 index.d.ts 文件里是没有一个 default export 的，所以 TypeScript 中如果我们不使用 &lt;code&gt;&amp;quot;allowSyntheticDefaultImports&amp;quot;: true&lt;/code&gt; 的配置，&lt;code&gt;import React from &#39;react&#39;&lt;/code&gt; 是会报错的。而在 jest 执行的时候，我即使开启了配置，还是遇到了这样的报错。所以最后我们决定全部改成 &lt;code&gt;import * as React from &#39;react&#39;&lt;/code&gt; 的写法了。同样有这种情况的还有 &lt;code&gt;ReactDOM&lt;/code&gt; 和 &lt;code&gt;proptypes&lt;/code&gt; 这两个包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TypeScript &#43; 单元测试：从零开始的经验之谈</title>
      <link>https://elizurhz.cn/frontend/typescript-and-unit-testing-in-action/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/typescript-and-unit-testing-in-action/</guid>
      <description>

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;公司和部门内部之前有在推广 TypeScript，但是由于种种原因很难投入使用，但这次我参与了一个从零开始的项目，没有技术栈限制，领导也说希望用 TypeScript 试一试。作为开发团队中唯一认真学过 TypeScript 的人（在部门进行过内部分享，写过内部博客），我们的经验其实都是很缺乏的。&lt;/p&gt;

&lt;p&gt;另外，在这个项目中，除了 TypeScript 之外，单元测试也是我们团队首次尝试的。&lt;/p&gt;

&lt;p&gt;同时，我的性格和开发风格也比较偏向“探索者”，所以领导也布置给我一些预研、新尝试，所以自然而然便成了一个 leader 的角色。&lt;/p&gt;

&lt;h2 id=&#34;项目构架&#34;&gt;项目构架&lt;/h2&gt;

&lt;p&gt;我们使用 create-react-app 搭建项目，没有 &lt;code&gt;eject&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而对于文件的组织，我们采用了按模块划分的方式，即各个模块集成自己的 store, reducers, actions, 展示组件, 容器组件等，并设置一个入口文件将它们都暴露给外部，外部需要引用的时候直接引用这个文件即可。&lt;/p&gt;

&lt;p&gt;主目录结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── docs // 文档
├── e2e // E2E 测试
├── src
│   ├── App.tsx // 主页面
│   ├── index.tsx // 主入口
│   ├── common.d.ts // 全局通用类型
│   ├── components // 通用组件
│   ├── i18n // 国际化
│   ├── @types // 如果某个依赖包没有 TypeScript 支持，则在这里编写 d.ts 文件
│   ├── modules // 业务模块
│   │   ├── moduleA
│   │   ├── moduleB
│   │   ...
│   ├── styles // 全局 scss 样式文件
│   ├── services // 与服务端请求相关的封装
│   ├── constants // 通用常量
│   └── utils // 通用工具函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块内部结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── index.ts // 主入口，用于导出外部可能引用到的所有该模块的内容
├── [MODULE_NAME].d.ts // 该组件下的通用类型
├── actions // 该模块的 redux action
├── common // 该模块内的通用组件（一般是与模块业务比较相关的）
│   ├── commonComponentA // 组件文件夹，包含组件、样式、单元测试
│   │   ├── index.tsx
│   │   ├── index.test.tsx
│   │   └── index.module.scss
│   ├── componentB
│   ...
├── components // 模块内的展示组件
│   ├── componentA
│   │   ├── __test__ // 单元测试
│   │   │   ├── __snapshots__ // 快照测试，如果有快照测试，Jest 会自动创建它
│   │   │   ├── index.test.js
│   │   │   └── someComponent.test.js
│   │   ├── index.ts // 主入口，用于导出外部可能引用到的所有组件
│   │   ├── componentA.tsx // 展示组件
│   │   ├── componentAContainer.tsx // 容器组件
│   │   ├── someComponent.tsx // 其他组件
│   │   └── index.module.scss
│   ...
├── reducers // 该模块内的 reducer
│   ├── index.ts // 主入口
│   ├── featureA.ts // 各子功能的 reducers
│   ...
├── sagas // redux-saga
│   ├── index.ts // 主入口
│   ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;typescript&#34;&gt;TypeScript&lt;/h2&gt;

&lt;p&gt;在使用 TypeScript 时，遇到的问题也是唯一可能的问题就是类型不匹配。刚开始的时候，大家对 React 的各种类型都非常不熟悉，所以不知道设定成什么好。事实上这应该也是所有的开发者入门遇到的最大问题。解决这个问题的方法，一是去稍微读一下 react 的 &lt;code&gt;index.d.ts&lt;/code&gt;，知道它大概有什么类型；二是参考一下成熟的 TypeScript 项目。Ant Design 可能是最合适的项目参考了。怎么写类型，React 里有什么常用的类型，以及怎么去继承复用类型，这些问题都可以在 Ant Design 上找到答案。&lt;/p&gt;

&lt;p&gt;这里总结一些常用的 React 类型（特殊未注明的都需要 import）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 children 时用 &lt;code&gt;React.ReactNode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;inline CSS 使用 &lt;code&gt;React.CSSProperties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;input 的相关事件使用 &lt;code&gt;React.ChangeEvent&lt;/code&gt; (泛型为 &lt;code&gt;ChangeEvent&amp;lt;HTMLInputElement&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;鼠标相关的事件使用 &lt;code&gt;React.MouseEvent&lt;/code&gt; (泛型为 &lt;code&gt;MouseEvent&amp;lt;HTMLButtonElement&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render()&lt;/code&gt; 函数的返回值类型是 &lt;code&gt;JSX.Element&lt;/code&gt;，不需要 import。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外 &lt;code&gt;react-router&lt;/code&gt; 和 &lt;code&gt;react-intl&lt;/code&gt; 分别有各自的类型 &lt;code&gt;RouteComponentProps&lt;/code&gt; 和 &lt;code&gt;InjectedIntlProps&lt;/code&gt;，需要 import。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;使用 TypeScript 对于刚入门的新手来说绝对是很浪费时间的，因为你写同样一个组件，相比 JavaScript 来说可能会花上两倍的时间。但是我们团队差不多在开发的第二周开始就能熟练开发了，所以 TypeScript 需要的仅仅是一些前期的学习成本，到后面它并不会成为风险或者负担。&lt;/p&gt;

&lt;p&gt;但是花这些时间去学习 TypeScript，带来的好处是不言而喻的。首先我们开发下来的体验就是：极少 Bug。Bug 大部分都是在开发时被解决的，因为有了 TypeScript 的约束，我们一旦出现类型错误等等，在开发时就可以被及时发现并修复，所以部署上去之后能发现的 Bug 就少了很多了。当然对于减少 Bug 贡献更多的其实是单元测试，这个后面会说。&lt;/p&gt;

&lt;h2 id=&#34;单元测试&#34;&gt;单元测试&lt;/h2&gt;

&lt;p&gt;单元测试框架我们使用的是 jest + enzyme。React 的单元测试相关的文章很多，但是都是关于“框架怎么用”，很少有人总结“一个项目里到底该怎么组织测试”。最近看到了一篇 &lt;a href=&#34;https://juejin.im/post/5bd640abf265da0ad63c125e&#34;&gt;React 单元测试策略及落地 #一篇就够系列&lt;/a&gt; 写得非常好，我们的单元测试也基本是按照这个来组织的。&lt;/p&gt;

&lt;p&gt;参考上面的文章，我们的单元测试的组织方式是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;connect 组件不测&lt;/li&gt;
&lt;li&gt;展示组件需要测试

&lt;ul&gt;
&lt;li&gt;UI 用快照测试(Jest)&lt;/li&gt;
&lt;li&gt;分支渲染必测&lt;/li&gt;
&lt;li&gt;事件必测&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;工具函数需要测试&lt;/li&gt;
&lt;li&gt;reducers 需要测试&lt;/li&gt;
&lt;li&gt;sagas 需要测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们的单元测试全部用 JavaScript 编写，这点也参考了 Ant Design。我认为单元测试没必要去真正完整地把那些 props mock 出来，因为我们是在验证代码逻辑的正确性，应该更多关注与代码本身，而不是类型有没有正确。如果在使用时传入了错误的类型，那么编译是不会通过的，这是 TypeScript 的编译器帮我们做的，再写关于类型错误的测试用例其实是画蛇添足。另外，在项目变得复杂之后，往往会出现一些很难 mock 的类型，强行去 mock 它们只会浪费我们写测试的时间。&lt;/p&gt;

&lt;h3 id=&#34;组件&#34;&gt;组件&lt;/h3&gt;

&lt;p&gt;我们的组件分为业务组件和通用组件。通用组件的测试就比较简单了，针对各个 props 进行测试即可，目的就是覆盖所有的分支逻辑和事件，同时用快照测试测 UI。而业务组件经常涉及到一些很复杂的 props，更有可能出现各种高阶组件，所以我们团队约定，在业务组件中不进行任何的高阶组件装饰。&lt;/p&gt;

&lt;p&gt;在测试组件的时候，必然会使用到 enzyme。在 enzyme 的使用上，我们确实碰到了很多问题，最大的问题还是在没经验的时候很难把目的转化成代码。例如我需要找一个“props 中有 &lt;code&gt;type=&amp;quot;primary&amp;quot;&lt;/code&gt; 的 Button 组件”，或者“触发 Button 子组件的 onClick 方法”。当然这也和官方文档写的不够（有的可能找不到）有关，并且很多文章也不会涉及到这种深入的内容。&lt;/p&gt;

&lt;h3 id=&#34;reducers&#34;&gt;reducers&lt;/h3&gt;

&lt;p&gt;reducers 测试比较简单，首先需要模拟出我们需要的 store，然后触发不同的 actions 去调用 reducers 的不同处理逻辑。具体测试方法官方文档都有说明，这里不再赘述。&lt;/p&gt;

&lt;h3 id=&#34;sagas&#34;&gt;sagas&lt;/h3&gt;

&lt;p&gt;sagas 的测试在官方文档也有专门页面说明。首先 saga 一定是异步的，而我们单元测试并不关注异步的结果，只需要测试相应的 saga 是否被正确调用。redux-saga 中有 &lt;code&gt;runSaga()&lt;/code&gt; 的 API 可以帮助我们完成单元测试。&lt;/p&gt;

&lt;h3 id=&#34;测试规范&#34;&gt;测试规范&lt;/h3&gt;

&lt;p&gt;在项目中，单元测试的规范化也是非常重要的。首先我们需要保证用例能实现你的测试目的，其次还需要有可读性。所以我对于单元测试质量的理解大概如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试描述需写精确，以便他人阅读，也方便说明该组、某个测试在测什么

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;describe&lt;/code&gt; 的第一个参数表示这一组测试在做什么&lt;/li&gt;
&lt;li&gt;&lt;code&gt;it&lt;/code&gt; 的第一个参数表示这个测试在做什么&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试的 expect 需要符合测试目的(即 &lt;code&gt;it&lt;/code&gt; 的描述)

&lt;ul&gt;
&lt;li&gt;例如给某个 input 赋初始 value，想判断它是否显示正确的 value，此时不能简单判断某个 DOM 存在&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果需要测试是否渲染成功，请使用 Jest 的快照测试，不要去判断某个 DOM 或者某个子组件是否存在

&lt;ul&gt;
&lt;li&gt;我们无法从某个 DOM 节点存在推导出组件是正常渲染的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;单元测试其实也是很耗时间的，特别是在不熟练的时候，可能在写测试时花的时间比开发花的时间还多。但是单元测试能够直接带来的好处就是极大减少了 Bug 数量。QA 往往是以业务场景来进行黑盒测试，他们不了解我们代码的写法，很多情况就是 QA 测试能通，但是实际上蕴藏了很多能产生 bug 的地方。在编写单元测试的过程中，我们也可以和 QA 一样去构思不同的业务场景，编写不同的测试用例，在这个过程中我们也会发现代码可能对于某些场景、逻辑的处理有缺失，可以依此对代码进行修正和补充。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;TypeScript 和单元测试刚入门的时候会觉得这些东西没用而且浪费时间，但是真正会用它们了之后其实是“真香”，很推荐开发者们都投入这个时间成本，因为它们后期带来的回报是完全可以弥补这个成本，甚至还有赚的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Canvas 手写板的实现与优化</title>
      <link>https://elizurhz.cn/frontend/canvas-writing-pad/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/canvas-writing-pad/</guid>
      <description>

&lt;p&gt;最近在公司接了几个项目，都和 Canvas 手绘手写有关的，有历史遗留项目，还有要从头写的新需求。之前对 Canvas 的认知比较少，只写过一个带动画的圆环百分比小组件（&lt;a href=&#34;https://github.com/ElizurHz/vue-percentage&#34;&gt;GitHub - ElizurHz/vue-percentage: 圆环百分比小组件&lt;/a&gt;），是定好数据后再把它画到 Canvas 上，而手写板是第一次接触。&lt;/p&gt;

&lt;p&gt;本文所涉及的代码是基于 &lt;a href=&#34;https://github.com/szimek/signature_pad&#34;&gt;szimek/signature_pad&lt;/a&gt; 这个开源组件进行改造的，所以下面会对源码进行一些解析，也会讲解一些我自己对其进行改造的经验。&lt;/p&gt;

&lt;h2 id=&#34;canvas-相关基础知识&#34;&gt;Canvas 相关基础知识&lt;/h2&gt;

&lt;p&gt;本文列举一些本文涉及到的必备知识和常用的 API，API 具体内容不过多赘述，详情可以在 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API&#34;&gt;Canvas - Web API 接口参考 | MDN&lt;/a&gt; 查看。&lt;/p&gt;

&lt;h3 id=&#34;基本用法&#34;&gt;基本用法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 是 HTML5 中的一个标签，我们可以以如下方式书写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;canvas id=&amp;quot;test&amp;quot; width=&amp;quot;150&amp;quot; height=&amp;quot;150&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 width 和 height 是 canvas 的必需属性，否则无法看到绘制的内容。在初始化时我们也可以通过 &lt;code&gt;document.getElementById&lt;/code&gt; 的方式获取 DOM 节点，并设置其 width 和 height 属性。&lt;strong&gt;【注意：在已经绘制过的 canvas 上重设这两个属性会导致已绘制内容被清空】&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如需在 canvas 上绘制，我们需要获取它的“渲染上下文 (The rendering context)”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const test = document.getElementById(&#39;test&#39;)
const ctx = test.getContext(&#39;2d&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;绘制&#34;&gt;绘制&lt;/h3&gt;

&lt;p&gt;在 Canvas 中我们定位使用的是坐标系，(0, 0) 代表的是最左上的点，可视区域最右下的点为 (width, height)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;context.clearRect(x, y, width, height): 以 (x, y) 为基准（左上角的点），清空长为 width、宽为 height 的矩形中所绘制的所有内容&lt;/li&gt;
&lt;li&gt;context.eginPath(): 新建路径&lt;/li&gt;
&lt;li&gt;context.closePath(): 闭合路径&lt;/li&gt;
&lt;li&gt;context.stroke(): 绘制轮廓&lt;/li&gt;
&lt;li&gt;context.moveTo(x, y): 移动至点 (x, y)&lt;/li&gt;
&lt;li&gt;context.lineTo(x, y): 绘制一条从当前点到 (x, y) 的直线&lt;/li&gt;
&lt;li&gt;context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y): 三次贝塞尔曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与图片相关的 API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;canvas.toBlob(): 当前 canvas 转化为 blob 对象，参数是一个回调函数，回调函数的参数就是 blob 对象。&lt;strong&gt;回调函数是异步执行的！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;canvas.toDataURL(): 转化为 base64 编码的 url。参数为图片格式，如 &lt;code&gt;&#39;image/png&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;context.drawImage(): 把图片绘制到 canvas 上。它有三种使用方式，根据传参数量的不同会有不同的结果。详情见 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage&#34;&gt;CanvasRenderingContext2D.drawImage() - Web API 接口参考 | MDN&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;贝塞尔曲线&#34;&gt;贝塞尔曲线&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A&#34;&gt;贝塞尔曲线 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/canvas-writing-pad/Bezier_3_big.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲一下本文涉及到的三次贝塞尔曲线。它有起点、控制点 1、控制点 2、终点四个关键的点。&lt;/p&gt;

&lt;p&gt;三次贝塞尔曲线的公式如下（LeaveIt 主题的 Dark Mode 下会看不清，请切换到 Light Mode）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/canvas-writing-pad/bezier_3_formulation.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中 t 为参数。使 t 逐渐从 0 增大到 1，即可通过这个方程式画出贝塞尔曲线。&lt;/p&gt;

&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;

&lt;p&gt;实现手写板，我们需要监听 Canvas 上的事件。由于我们可能是用鼠标去绘画，也可能是在触屏上绘画，所以我们除了监听鼠标事件之外，还需要监听触摸事件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mousedown/touchstart: 鼠标点击/开始触摸&lt;/li&gt;
&lt;li&gt;mousemove/touchmove: 鼠标/触摸移动中&lt;/li&gt;
&lt;li&gt;mouseup/touchend: 鼠标按键抬起/触摸结束(离开屏幕)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用这些 API 能满足大多数情况下的需求，但是现在出现了如 Surface Pen, Apple Pen 这类的手写笔，W3C 也有相应的新标准：PointerEvent (&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent&#34;&gt;PointerEvent - Web API 接口 | MDN&lt;/a&gt;)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PointerEvent 接口代表了由 指针 引发的 DOM 事件的状态，包括接触点的位置，引发事件的设备类型，接触表面受到的压力等。
指针 是输入设备的硬件层抽象（比如鼠标，触摸笔，或触摸屏上的一个触摸点）。指针 能指向一个具体表面（如屏幕）上的一个（或一组）坐标。
指针的 击中检测 指浏览器用来检测 指针事件的目标元素的过程。大多数情况下，这个目标元素是由 指针的位置和元素在文章中的位置和分层共同决定的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PointerEvent 的使用方法和 MouseEvent、TouchEvent 很类似，但有新增一些有用的 Properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PointerEvent.pointerType: 这个 property 表示的是接触类型，有 3 种 string 类型的值 - mouse, pen, touch，分别代表鼠标、触控笔、触摸。&lt;/li&gt;
&lt;li&gt;PointerEvent.pressure: 这个 property 表示的是压力等级，数值范围是从 0 到 1 ，如果我们没有压感触控笔，或者使用鼠标，那么这个值默认是 0.5。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实现方案&#34;&gt;实现方案&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;历史遗留的项目中使用的是监听 move 的事件，每次都用 &lt;code&gt;lineTo()&lt;/code&gt;和&lt;code&gt;stroke()&lt;/code&gt;绘制出线条。这样做存在的问题是延迟很严重，笔画不跟笔，同时锯齿感也很严重。&lt;/li&gt;
&lt;li&gt;参考了 &lt;a href=&#34;https://github.com/szimek/signature_pad&#34;&gt;GitHub - szimek/signature_pad: HTML5 canvas based smooth signature drawing&lt;/a&gt; 的实现方案，使用的是三次贝塞尔曲线，由于三次贝塞尔曲线的绘制需要至少 4 个点，分别是起点、控制点 1、控制点 2、终点，所以不能每次 move 都 &lt;code&gt;stroke()&lt;/code&gt;进行绘制，而是需要记录点坐标并通过计算来绘制。实际效果比上面一种方法的延迟和锯齿感都好很多，&lt;strong&gt;但是唯独在 Surface Book + Surface Pen 上的延迟感还是很明显，而前一代的 iPad Pro + Apple Pen 非常流畅，不知道有没有做过 Surface Pen 适配的大神能解答这个问题&lt;/strong&gt;。于是我就想能不能用 PointerEvent 来解决，但测试用的 Surface Book 是公司的开发机，我们小组只有一台，常常被其他开发和 QA 抢去使用，所以没有机会去验证这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;接下来，我们对 &lt;a href=&#34;https://github.com/szimek/signature_pad&#34;&gt;szimek/signature_pad&lt;/a&gt; 的源码进行一番解析。需要注意的是，master 分支的源码是用 TypeScript 写的，而在 gh-pages 分支上有 ES5 的版本。为了让不懂 ts 的读者能看懂，下面会对 &lt;a href=&#34;https://github.com/szimek/signature_pad/blob/gh-pages/js/signature_pad.js&#34;&gt;ES5 版本&lt;/a&gt; 的代码进行解析。&lt;/p&gt;

&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;

&lt;p&gt;这里用了两个辅助类，Bezier 是贝塞尔曲线，而 Point 是 canvas 中需要用到的点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i &amp;lt;= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i &amp;gt; 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

Point.prototype.equals = function (other) {
  return this.x === other.x &amp;amp;&amp;amp; this.y === other.y &amp;amp;&amp;amp; this.time === other.time;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是 Point 这个类中，原作者加入了点绘制的时间，在原作者的项目中是有根据绘制速度调整笔画粗细的，但这个在我的改造中因为需求的缘故被去掉了。&lt;/p&gt;

&lt;h3 id=&#34;mousedown-touchstart&#34;&gt;mousedown/touchstart&lt;/h3&gt;

&lt;p&gt;首先源码使用构造函数创建了一个 SignaturePad 的类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === &#39;function&#39;) {
    this.onBegin(event);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里开始的代码会出现很多 this 或者 self，它们如果没有特殊说明都是指代的构造函数中的 this 本身。&lt;/p&gt;

&lt;p&gt;这部分没有什么关键的代码，直接调用 &lt;code&gt;this._strokeUpdate&lt;/code&gt; 了。&lt;code&gt;onBegin&lt;/code&gt; 是用户可以自定义的回调函数。&lt;/p&gt;

&lt;h3 id=&#34;mousemove-touchmove&#34;&gt;mousemove/touchmove&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y); // 根据 event 对象中的 clientX 和 clientY 生成该点在 canvas 坐标系中的 Point 对象
  var lastPointGroup = this._data[this._data.length - 1];
  var lastPoint = lastPointGroup &amp;amp;&amp;amp; lastPointGroup[lastPointGroup.length - 1];
  var isLastPointTooClose = lastPoint &amp;amp;&amp;amp; point.distanceTo(lastPoint) &amp;lt; this.minDistance;

  // 如果绘制的点和之前的点距离太近，则跳过该点的绘制
  // Skip this point if it&#39;s too close to the previous one
  if (!(lastPoint &amp;amp;&amp;amp; isLastPointTooClose)) {
    var _addPoint = this._addPoint(point),
        curve = _addPoint.curve,
        widths = _addPoint.widths;

    if (curve &amp;amp;&amp;amp; widths) {
      this._drawCurve(curve, widths.start, widths.end);
    }

    this._data[this._data.length - 1].push({
      x: point.x,
      y: point.y,
      time: point.time,
      color: this.penColor
    });
  }
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

/*
 * 生成 Bezier 对象和曲线的宽度值
 * curve: Bezier 对象
 * widths: 包含 start 和 end 两个 properties
*/
SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length &amp;gt; 2) {
    // Bezier 类需要 4 个点的参数，作者为了减少延迟，把第一个点复制了一次，构造成 4 个点的数组，以此计算前两个点之间的三次贝塞尔曲线的控制点
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

/*
 * 绘制贝塞尔曲线
 * 绘制方法为从 0 至 1 逐步增大贝塞尔曲线的参数 t
 * 代码实际上就是公式的计算
*/
SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length()); // 绘制步长是曲线的长度

  ctx.beginPath();

  for (var i = 0; i &amp;lt; drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

// 绘制弧线
SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

// 计算贝塞尔曲线的控制点
SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分就是绘图的核心算法了，我在项目中也是直接使用了作者编写的代码。
在 &lt;code&gt;_addPoint()&lt;/code&gt; 中有名为 &lt;code&gt;_calculateCurveWidths&lt;/code&gt; 的函数，是原作者用于根据绘制速度计算笔画粗细的算法，原代码对应的相关参数是 &lt;code&gt;constructor&lt;/code&gt; 中的 &lt;code&gt;this.maxWidth&lt;/code&gt; 和 &lt;code&gt;this.minWidth&lt;/code&gt;。
由于我做的项目不需要这个功能，所以我只需要把 &lt;code&gt;this.maxWidth&lt;/code&gt; 和 &lt;code&gt;this.minWidth&lt;/code&gt; 设置成相同的值即可。
这个功能详情可以参考前文提供的作者的 GitHub 上的源码。&lt;/p&gt;

&lt;p&gt;主要内容已经用中文备注在代码中了，总结起来就是：选取 3 个点来计算控制点，根据控制点绘制出两点之间的曲线&lt;/p&gt;

&lt;h3 id=&#34;mouseup-touchend&#34;&gt;mouseup/touchend&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length &amp;gt; 2; // 如果点的数量太少，则无法绘制曲线
  var point = this.points[0]; // Point instance

  if (!canDrawCurve &amp;amp;&amp;amp; point) {
    this._drawDot(point); // 点数量太少时改为绘制单个点
  }

  if (point) {
    var lastPointGroup = this._data[this._data.length - 1];
    var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object

    // 相同的点会被排除，不会被绘制
    // When drawing a dot, there&#39;s only one point in a group, so without this check
    // such group would end up with exactly the same 2 points.
    if (!point.equals(lastPoint)) {
      lastPointGroup.push({
        x: point.x,
        y: point.y,
        time: point.time,
        color: this.penColor
      });
    }
  }

  if (typeof this.onEnd === &#39;function&#39;) {
    this.onEnd(event);
  }
};

// 画点
SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === &#39;function&#39; ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里作者做了一个处理，就是在生成有效的点数量太少时则不会绘制曲线，改为绘制单点。如果忽略了此步，则会出现点触和小范围内移动无反应的情况，严重影响手写体验。&lt;/p&gt;

&lt;h2 id=&#34;其他功能&#34;&gt;其他功能&lt;/h2&gt;

&lt;p&gt;这部分功能都是我根据需求加进去的。&lt;/p&gt;

&lt;h3 id=&#34;单次手写保存成图片&#34;&gt;单次手写保存成图片&lt;/h3&gt;

&lt;p&gt;首先我使用的 canvas 区域很大，但是实际上可能有手写内容的范围很小，所以这边要做一步剪裁的操作。
在上面的代码中有一个 &lt;code&gt;this._data&lt;/code&gt; 的变量，这个变量记录了所有绘制过的点。
因此我们可以通过这个坐标数据来找出一个包含所有点的区域，再用 &lt;code&gt;drawImage()&lt;/code&gt; 将其绘制到一个大小和这个区域相同的、隐藏的 canvas 中。
接着使用 &lt;code&gt;toBlob()&lt;/code&gt; 或者 &lt;code&gt;toDataURL()&lt;/code&gt; 就可以导出图片了。&lt;/p&gt;

&lt;h3 id=&#34;所有的手写内容拼接并保存为一张图片&#34;&gt;所有的手写内容拼接并保存为一张图片&lt;/h3&gt;

&lt;p&gt;上面的【单次手写保存成图片】，在项目中我们是把它们排列起来，有空格、换行、退格等操作供排版，但是最后需要把这些所有的内容都导出成一张图片进行保存。
这里同样需要用到 &lt;code&gt;drawImage()&lt;/code&gt;，不过区别在于不需要裁切。&lt;/p&gt;

&lt;p&gt;我的解决方案是：首先每张图大小不同，所以我给每一行横向排列的图片定了一个固定的高度，超过这个高度的图片会被等比缩放到这个高度，未超过的则不作处理。
而绘制上去之后，每次都会移动绘制起始点，在同一行内的则直接向右侧平移（缩放后的）图片的宽度，空格就向右移动一段空白的位置，换行则向下移动一行的高度并移动到最左侧。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;仅仅是一个入门级的操作，但是用比较粗暴的方式实现的话，体验上和更优的方案的差距会比较明显。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ECS 上的 git 管理工具踩坑记</title>
      <link>https://elizurhz.cn/backend/remote-private-git-first-look/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/backend/remote-private-git-first-look/</guid>
      <description>

&lt;h1 id=&#34;ecs-上的-git-管理工具踩坑记&#34;&gt;ECS 上的 git 管理工具踩坑记&lt;/h1&gt;

&lt;h2 id=&#34;gitlab&#34;&gt;gitlab&lt;/h2&gt;

&lt;h3 id=&#34;在-centos-上安装-gitlab&#34;&gt;在 CentOS 上安装 gitlab&lt;/h3&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://blog.csdn.net/caib1109/article/details/51756246&#34;&gt;8 小时外实践系列(六) - 在阿里云服务器上搭建 GitLab(草稿) - CSDN 博客&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;gitlab 非常吃性能，在 1 核 1G 的服务器上安装后会导致机子非常卡，同时域名/IP 访问也会出现 502，查资料之后发现是配置太低的问题。官方推荐的配置是 2 核心 8G 内存，我们普通个人用户显然难以支付这么昂贵的服务器配置，更不用说海外主机了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用-docker-部署-gitlab&#34;&gt;使用 docker 部署 gitlab&lt;/h3&gt;

&lt;p&gt;只需要在 docker hub 中 &lt;code&gt;docker pull gitlab/gitlab-ce&lt;/code&gt; 就行，然后我启动容器的的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker run --detach \
  --hostname gitlab.mydomain.com \
  --publish 8443:443 --publish 80:80 --publish 2222:22 \
  --name gitlab \
  --restart always \
  --volume /srv/gitlab/config:/etc/gitlab \
  --volume /srv/gitlab/logs:/var/log/gitlab \
  --volume /srv/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如需修改 gitlab.rb 的配置，只需要 &lt;code&gt;vim /srv/gitlab/config/gitlab.rb&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;一般需要配置的有：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;external_url &#39;你的域名或者IP&#39; # 改成你的域名或者 IP，如果你的端口映射不是 80，那也不能在这里加端口
gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 2222 # 防止和本机 22 端口冲突
unicorn[&#39;port&#39;] = 8999 # 如果你的 8080 端口被占用的话
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;另外记住，如果单开某个端口，需要在 ECS 实例的安全组中允许这个端口被某个或者某些 IP 访问。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置完成之后需要在容器中 reconfigure: &lt;code&gt;docker exec -it gitlab gitlab-ctl reconfigure&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;然而我按照上面的方式完成之后，通过域名或者 IP 进入仍是 502。
后来我尝试了在不同机子上部署。例如在群辉 DS218+ 上用同样的方式配置会出现 容器意外停止 的问题；在我的 iMac 本机上用 docker 部署就可以正常访问和进行代码管理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;gogs&#34;&gt;gogs&lt;/h2&gt;

&lt;p&gt;gogs 不像 gitlab 那样吃性能，功能也很完善，不过 gogs 需要有额外的数据库依赖，如 MySQL。具体的部署方式参考以下两篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/5f5e419b5de8&#34;&gt;docker 安装 mysql - 简书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2a7acb07b352&#34;&gt;docker 安装 gogs - 简书&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;勘误：在《docker 安装 mysql - 简书》中，创建网络的命令不是 &lt;code&gt;docker create network backend&lt;/code&gt; 而是 &lt;code&gt;docker network create backend&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我的容器启动代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 启动 MySQL
docker run -d --name mysql57 \
--net=backend \ # 加入创建的 backend 网络中
-p 3306:3306 \
-e MYSQL_ROOT_PASSWORD=root \
-v /srv/mysql/data:/var/lib/mysql \
-v /srv/mysql/conf:/etc/mysql/conf.d \
# 启动 gogs
docker run -d \
-p 10022:22 -p 3000:3000 \
--name=gogs \
--net=backend \ # 加入创建的 backend 网络中
-v /srv/gogs/:/data gogs/gogs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时访问服务器的 3000 端口即可进入设置界面，记住要把 localhost 全部改成服务器 ip。&lt;/p&gt;

&lt;h3 id=&#34;关于-gogs-的数据库设置&#34;&gt;关于 gogs 的数据库设置&lt;/h3&gt;

&lt;p&gt;首先由于本例使用了 docker network，所以可以直接使用 容器名:端口 来访问，例如 mysql57:3306。&lt;/p&gt;

&lt;p&gt;另外我们需要在 mysql 容器中创建一个数据库，否则 gogs 无法完成设置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it mysql57 /bin/bash
mysql -u root -p
# 然后输入密码，如果你没更改密码，则密码是 root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在 mysql 命令行中创建数据库，gogs 默认数据库名就是 gogs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE gogs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们在网页中就可以完成 gogs 的初始化设置了。&lt;/p&gt;

&lt;p&gt;如果想要使用 gogs，首先我们要注册一个账号，注意第一个注册的账号默认是拥有最高权限的账号。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在实际使用中，我遇到了 git clone 时发现有 not a repository 的问题，可能是 IP/域名、端口等等设置的问题，仍在研究中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/caib1109/article/details/51756246&#34;&gt;8 小时外实践系列(六) - 在阿里云服务器上搭建 GitLab(草稿) - CSDN 博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/5f5e419b5de8&#34;&gt;docker 安装 mysql - 简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/2a7acb07b352&#34;&gt;docker 安装 gogs - 简书&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GitHub 上 Fork 的仓库如何与原仓库同步并提交内容</title>
      <link>https://elizurhz.cn/tips/git-upstream/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/tips/git-upstream/</guid>
      <description>

&lt;h1 id=&#34;github-上-fork-的仓库如何与原仓库同步并提交内容&#34;&gt;GitHub 上 Fork 的仓库如何与原仓库同步并提交内容&lt;/h1&gt;

&lt;p&gt;我们可能有时会遇到需要向 GitHub 上的开源的项目提交代码。在 GitHub 中，由于你不是那个开源项目中有权限提交代码的人，你只能 Fork 后再发起 Pull Request。&lt;/p&gt;

&lt;h2 id=&#34;fork-仓库&#34;&gt;Fork 仓库&lt;/h2&gt;

&lt;p&gt;你可以在 GitHub 网页上点击 Fork，之后你可以在你的个人主页的 Repository 中找到你 Fork 的仓库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/git-upstream/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后你就可以将其 clone 到本地。&lt;/p&gt;

&lt;h2 id=&#34;fork-的本地仓库与源仓库连接&#34;&gt;Fork 的本地仓库与源仓库连接&lt;/h2&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://help.github.com/articles/syncing-a-fork/&#34;&gt;Syncing a fork - User Documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先在命令行工具中输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时应该显示如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们没有将其连接到源仓库，所以需要用命令去连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的地址是&lt;strong&gt;源仓库&lt;/strong&gt;的地址。接着我们再输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时应该能看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了与与源仓库的连接。&lt;/p&gt;

&lt;h2 id=&#34;fork-的仓库与源仓库同步代码&#34;&gt;Fork 的仓库与源仓库同步代码&lt;/h2&gt;

&lt;p&gt;首先：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch upstream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取源仓库更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以将本地 master 分支更新到最新。我们就可以在此基础上创建新分支提交 PR。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React &#43; TypeScript 从云玩家到入门</title>
      <link>https://elizurhz.cn/frontend/typescript-for-jser/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/typescript-for-jser/</guid>
      <description>

&lt;h1 id=&#34;react-typescript-从云玩家到入门&#34;&gt;React + TypeScript 从云玩家到入门&lt;/h1&gt;

&lt;p&gt;TypeScript 对我们开发最大的帮助就是类型检查，所以玩转 TypeScript 其实就是在玩转类型。而 TypeScript 本身和 Java, C# 等面向对象的语言有非常多类似的地方，有相应经验的读者能够较快地入门。本文旨在于帮助无面向对象开发经验的 JavaScript 使用者能最快速地上手并使用 TypeScript 编写 React 应用。由于篇幅和定位所限，本文将不会涉及到较为复杂的组件设计模式。&lt;/p&gt;

&lt;h2 id=&#34;typescript-基础&#34;&gt;TypeScript 基础&lt;/h2&gt;

&lt;p&gt;这部分主要介绍入门 TypeScript 必须掌握的，以及 React 开发中经常会用到的一些语法规范。&lt;/p&gt;

&lt;h3 id=&#34;基础类型&#34;&gt;基础类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;number: 数字&lt;/li&gt;
&lt;li&gt;string: 字符串&lt;/li&gt;
&lt;li&gt;boolean: 布尔值&lt;/li&gt;
&lt;li&gt;Array: 数组。在使用数组类型的时候必须标记数组中的数据类型，如 &lt;code&gt;number[]&lt;/code&gt; 或者 &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tuple: 元组。&lt;code&gt;let x: [string, number];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;any: 任意类型&lt;/li&gt;
&lt;li&gt;void: 空，一般用于函数的返回值&lt;/li&gt;
&lt;li&gt;never: 永远不会出现的类型，一般用于函数的返回值，例如抛出错误或者永远不结束的死循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;可选类型&#34;&gt;可选类型&lt;/h3&gt;

&lt;p&gt;标记为可选类型的属性并非是必须的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface IObj {
  str?: string;
  num: number;
}

// tslint 不报错
let obj1: IObj = {
  num: 123
};

// tslint 报错
let obj2: IObj = {
  str: &amp;quot;asdf&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/typescript-for-jser/optional-error.png&#34; alt=&#34;optional-error&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;readonly&#34;&gt;Readonly&lt;/h3&gt;

&lt;p&gt;一般在 Interface 和 Class 中会使用。设置为 &lt;code&gt;readonly&lt;/code&gt; 的变量、属性，一旦定义后就无法直接修改。如果在代码中有修改的操作，则 tslint 会报错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://elizurhz.cn/images/typescript-for-jser/readonly-error.png&#34; alt=&#34;readonly-error&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function add(x: number, y: number): number {
  return x + y;
}

let myAdd: (x: number, y: number) =&amp;gt; number = function(
  x: number,
  y: number
): number {
  return x + y;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的类型限制主要在参数和返回值的位置需要定义。如果在等号左侧已经定义了类型，那么右侧可以不需要写类型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let myAdd: (baseValue: number, increment: number) =&amp;gt; number = function(x, y) {
  return x + y;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个在 TypeScript 中被称作 “contextual typing”。&lt;/p&gt;

&lt;h2 id=&#34;interface&#34;&gt;interface&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;One of TypeScript’s core principles is that type-checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural subtyping”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Interface 一般用于描述一个较为复杂的限制，例如在一个对象中限制某些属性的类型。有时被称为“鸭子类型”。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&amp;rdquo;
在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface ITest {
  a: number;
  b: string;
}

const test: ITest = {
  a: 1,
  b: &amp;quot;123&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Interface 和 class 的区别:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Interface 和 class 在 TypeScript 中都可以去描述一个限制，与 PHP、Java 中的 interface、class 一样，TypeScript 中的 interface 只做声明不做实现。&lt;/li&gt;
&lt;li&gt;如果把上面的 interface 声明换成 class，tslint 不会报错，代码可以正常执行，但是二者编译出来的 JavaScript 不同。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 使用 interface 编译后的代码
var test = {
  a: 1,
  b: &amp;quot;123&amp;quot;
};

// 使用 class 编译后的代码
var ITest = /** @class */ (function() {
  function ITest() {}
  return ITest;
})();
var test = {
  a: 1,
  b: &amp;quot;123&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;class 可以使用 implements 关键字来实现 interface。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类型别名&#34;&gt;类型别名&lt;/h3&gt;

&lt;p&gt;TypeScript 中允许使用 type 关键字来声明类型别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type State = {
  a: string;
  b: Array&amp;lt;number&amp;gt;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型别名和 interface 通常具有同样的功能，但是类型别名不能被 &lt;code&gt;extends&lt;/code&gt; 或者 &lt;code&gt;implements&lt;/code&gt;，也不能 &lt;code&gt;extends&lt;/code&gt; 或者 &lt;code&gt;implements&lt;/code&gt; 其他类型。并且类型别名在编译器中显示的是 Object 字面量类型，而 interface 显示是 interface。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because &lt;a href=&#34;https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle&#34;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.
【软件中的对象应该对于扩展是开放的，但是对于修改是封闭的】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;泛型&#34;&gt;泛型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function identity(arg: any): any {
  return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们在写这样一个函数的时候，参数和返回值都可以是任意类型，但实际上这样我们就丢失了参数和返回值的类型信息（实际上输入和输出应该是相同的类型）。
这时我们可以用一个类型变量 T：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function identity&amp;lt;T&amp;gt;(arg: T): T {
  return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样保证了参数和返回值的类型都是 T。
我们可以通过如下的方式使用这个泛型函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let output = identity&amp;lt;string&amp;gt;(&amp;quot;myString&amp;quot;); // type of output will be &#39;string&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;映射类型&#34;&gt;映射类型&lt;/h3&gt;

&lt;p&gt;映射类型包括 Partial 和 Readonly，它们可以在原有 interface 的基础上分别映射出所有属性都是可选类型，和所有属性都是只读的新的 type。这两种映射类型实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type Readonly&amp;lt;T&amp;gt; = { readonly [P in keyof T]: T[P] };
type Partial&amp;lt;T&amp;gt; = { [P in keyof T]?: T[P] };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在-react-中使用-typescript&#34;&gt;在 React 中使用 TypeScript&lt;/h2&gt;

&lt;h3 id=&#34;创建一个-react-typescript-的项目&#34;&gt;创建一个 React + TypeScript 的项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;create-react-app
通过 create-react-app 来搭建，我们只需要在命令中加入额外参数即可：
&lt;code&gt;create-react-app my-app --scripts-version=react-scripts-ts&lt;/code&gt;
搭建出来的项目结构与 JavaScript 版本基本相同，区别在于根目录有&lt;code&gt;tsconfig.json&lt;/code&gt;、&lt;code&gt;tslint.json&lt;/code&gt; 等 TypeScript 相关的文件。&lt;code&gt;tsconfig.json&lt;/code&gt; 用于告诉 &lt;code&gt;ts-loader&lt;/code&gt; 如何编译 .ts 文件，而 &lt;code&gt;tslint.json&lt;/code&gt; 则是 tslint (TypeScript 语法检查器) 的配置。&lt;/li&gt;
&lt;li&gt;手动安装
手动安装需要通过 npm 或者 yarn 安装 &lt;code&gt;typescript&lt;/code&gt; 和 &lt;code&gt;ts-loader&lt;/code&gt; 等 TypeScript 相关的 package，同时需要手动配置 &lt;code&gt;tsconfig.json&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;definitelytyped-d-ts&#34;&gt;DefinitelyTyped - *.d.ts&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/DefinitelyTyped/DefinitelyTyped&#34;&gt;GitHub - DefinitelyTyped/DefinitelyTyped: The repository for high quality TypeScript type definitions.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TypeScript 的模块发布的时候都是打包成 JavaScript 来发布的，但是这样会丢失定义好的数据类型。 .d.ts 可以约定 type, class, interface, function, 变量以及常量等的行为，相当于是一个 package 或者 library 的“说明书”。&lt;/p&gt;

&lt;p&gt;在 React 中，我们常常会需要安装一些如 &lt;code&gt;@types/react-router-dom&lt;/code&gt; 这种以 &lt;code&gt;@types&lt;/code&gt; 作为开头的 package。在 JS 中我们直接 &lt;code&gt;npm install react-router-dom&lt;/code&gt; 即可，但是在 TypeScript 中，如果没有 DefinitelyTyped，将会报如下的错误：
&lt;img src=&#34;https://elizurhz.cn/images/typescript-for-jser/types-error.png&#34; alt=&#34;@types-error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然并不是所有的 package 都需要一个对应的 &lt;code&gt;@types&lt;/code&gt; ，不少 package 自身已经有 .d.ts 文件了，例如 antd，所以我们不需要额外的 &lt;code&gt;@types&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&#34;无状态组件&#34;&gt;无状态组件&lt;/h3&gt;

&lt;p&gt;在 JavaScript 中，我们可以按如下的方式写一个 Stateless Functional Component ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &amp;quot;react&amp;quot;;
const Button = ({ onClick, children }) =&amp;gt; (
  &amp;lt;button onClick={handleClick}&amp;gt;{children}&amp;lt;/button&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在 TypeScript 中，我们需要加入类型，所以具体怎么加呢？我们可以通过 &lt;code&gt;@types/react&lt;/code&gt; 中的 &lt;code&gt;index.d.ts&lt;/code&gt;来进行分析：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：以下代码都去除了大段的注释，若需要查看官方的注释请至 &lt;code&gt;npm install&lt;/code&gt; 后下载的 &lt;code&gt;./node_modules/@types/react&lt;/code&gt; 中查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type SFC&amp;lt;P = {}&amp;gt; = StatelessComponent&amp;lt;P&amp;gt;;
interface StatelessComponent&amp;lt;P = {}&amp;gt; {
  (props: P &amp;amp; { children?: ReactNode }, context?: any): ReactElement&amp;lt;
    any
  &amp;gt; | null;
  propTypes?: ValidationMap&amp;lt;P&amp;gt;;
  contextTypes?: ValidationMap&amp;lt;any&amp;gt;;
  defaultProps?: Partial&amp;lt;P&amp;gt;;
  displayName?: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这段代码中可以看出，props 是 P 和 一个对象的联合类型，P 指的是我们通常传入的 props，而对象中的 children 就是 React 中的 children，是可选类型，type 是 ReactNode，是 React 中的类型。另外在 React 的 &lt;code&gt;index.d.ts&lt;/code&gt;中，对于事件有专门的类型定义 &lt;code&gt;MouseEvent&lt;/code&gt;（同时也有其他 Event 的类型定义）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface MouseEvent&amp;lt;T = Element&amp;gt; extends SyntheticEvent&amp;lt;T&amp;gt; {
  altKey: boolean;
  button: number;
  buttons: number;
  clientX: number;
  clientY: number;
  ctrlKey: boolean;
  getModifierState(key: string): boolean;
  metaKey: boolean;
  nativeEvent: NativeMouseEvent;
  pageX: number;
  pageY: number;
  relatedTarget: EventTarget;
  screenX: number;
  screenY: number;
  shiftKey: boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以针对上面的 JavaScript 代码，我们可以按如下的方式写出相应的 TypeScript 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import React, { MouseEvent, ReactNode } from &amp;quot;react&amp;quot;;
interface IProps {
  onClick(e: MouseEvent&amp;lt;HTMLElement&amp;gt;): void;
  children?: ReactNode;
}
const Button = ({ onClick: handleClick, children }: IProps) =&amp;gt; (
  &amp;lt;button onClick={handleClick}&amp;gt;{children}&amp;lt;/button&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;HTMLElement&lt;/code&gt; 被定义在&lt;code&gt;@types/react&lt;/code&gt; 中的&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Element {}
interface HTMLElement extends Element {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有状态组件&#34;&gt;有状态组件&lt;/h3&gt;

&lt;p&gt;无状态组件其实是一个函数，只需要按照函数的写法来实现即可。而对于有状态组件，这边有一个计数器的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;

import Button from &amp;quot;./Button&amp;quot;; // 这里的 Button 是上面 SFC 部分的 Button 组件

const initialState = { clicksCount: 0 };
type State = Readonly&amp;lt;typeof initialState&amp;gt;;

class ButtonCounter extends Component&amp;lt;object, State&amp;gt; {
  readonly state: State = initialState;

  public render() {
    const { clicksCount } = this.state;
    return (
      &amp;lt;&amp;gt;
        &amp;lt;Button onClick={this.handleIncrement}&amp;gt;Increment&amp;lt;/Button&amp;gt;
        &amp;lt;Button onClick={this.handleDecrement}&amp;gt;Decrement&amp;lt;/Button&amp;gt;
        You&#39;ve clicked me {clicksCount} times!
      &amp;lt;/&amp;gt;
    );
  }

  private handleIncrement = () =&amp;gt; this.setState(incrementClicksCount);
  private handleDecrement = () =&amp;gt; this.setState(decrementClicksCount);
}

const incrementClicksCount = (prevState: State) =&amp;gt; ({
  clicksCount: prevState.clicksCount + 1
});
const decrementClicksCount = (prevState: State) =&amp;gt; ({
  clicksCount: prevState.clicksCount - 1
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要读懂这段代码，可以从&lt;code&gt;@types/react&lt;/code&gt; 中的 &lt;code&gt;index.d.ts&lt;/code&gt;说起：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：以下代码都去除了大段的注释，若需要查看官方的注释请至 &lt;code&gt;npm install&lt;/code&gt; 后下载的 &lt;code&gt;./node_modules/@types/react&lt;/code&gt; 中查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Component&amp;lt;P = {}, S = {}, SS = any&amp;gt;
  extends ComponentLifecycle&amp;lt;P, S, SS&amp;gt; {}

class PureComponent&amp;lt;P = {}, S = {}, SS = any&amp;gt; extends Component&amp;lt;P, S, SS&amp;gt; {}

class Component&amp;lt;P, S&amp;gt; {
  constructor(props: Readonly&amp;lt;P&amp;gt;);
  setState&amp;lt;K extends keyof S&amp;gt;(
    state:
      | ((prevState: Readonly&amp;lt;S&amp;gt;, props: Readonly&amp;lt;P&amp;gt;) =&amp;gt; Pick&amp;lt;S, K&amp;gt; | S | null)
      | (Pick&amp;lt;S, K&amp;gt; | S | null),
    callback?: () =&amp;gt; void
  ): void;

  forceUpdate(callBack?: () =&amp;gt; void): void;
  render(): ReactNode;
  readonly props: Readonly&amp;lt;{ children?: ReactNode }&amp;gt; &amp;amp; Readonly&amp;lt;P&amp;gt;;
  state: Readonly&amp;lt;S&amp;gt;;
  context: any;
  refs: {
    [key: string]: ReactInstance;
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们常用的 Component 类就是在这里被定义的，其中 P 代表 props，S 代表 state。在这里我们可以发现，props 和 state 都使用了 readonly 或者是使用了 Mapped types 中的 Readonly。
而 Component 的 Interface 继承了 ComponentLifecycle 的 Interface，源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface &amp;lt;P, S, SS = any&amp;gt; extends NewLifecycle&amp;lt;P, S, SS&amp;gt;, DeprecatedLifecycle&amp;lt;P, S&amp;gt; {
	componentDidMount?(): void;
	shouldComponentUpdate?(nextProps: Readonly&amp;lt;P&amp;gt;, nextState: Readonly&amp;lt;S&amp;gt;, nextContext: any): boolean;
	componentWillUnmount?(): void;
	componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ComponentLifecycle 的 Interface 定义了一些常用的生命周期函数的类型如 componentDidMount、shouldComponentUpdate、componentWillUnmount 和 componentDidCatch。ComponentLifecycle 同样继承了 NewLifecycle 和 DeprecatedLifecycle 两个接口，代码分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface NewLifecycle&amp;lt;P, S, SS&amp;gt; {
  getSnapshotBeforeUpdate?(
    prevProps: Readonly&amp;lt;P&amp;gt;,
    prevState: Readonly&amp;lt;S&amp;gt;
  ): SS | null;
  componentDidUpdate?(
    prevProps: Readonly&amp;lt;P&amp;gt;,
    prevState: Readonly&amp;lt;S&amp;gt;,
    snapshot?: SS
  ): void;
}

interface DeprecatedLifecycle&amp;lt;P, S&amp;gt; {
  componentWillMount?(): void;
  UNSAFE_componentWillMount?(): void;
  componentWillReceiveProps?(nextProps: Readonly&amp;lt;P&amp;gt;, nextContext: any): void;
  UNSAFE_componentWillReceiveProps?(
    nextProps: Readonly&amp;lt;P&amp;gt;,
    nextContext: any
  ): void;
  componentWillUpdate?(
    nextProps: Readonly&amp;lt;P&amp;gt;,
    nextState: Readonly&amp;lt;S&amp;gt;,
    nextContext: any
  ): void;
  UNSAFE_componentWillUpdate?(
    nextProps: Readonly&amp;lt;P&amp;gt;,
    nextState: Readonly&amp;lt;S&amp;gt;,
    nextContext: any
  ): void;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NewLifecycle 是 React 16.3 新增的生命周期钩子，而 DeprecatedLifecycle 则是 React 16.3 之前常用的生命周期钩子，即将在未来版本被废弃。&lt;/p&gt;

&lt;p&gt;所以通过以上分析，我们可以知道，React 的 Class 继承于 &lt;code&gt;class Component&amp;lt;P, S&amp;gt;&lt;/code&gt;，而 &lt;code&gt;class Component&amp;lt;P, S&amp;gt;&lt;/code&gt; 是泛型 &lt;code&gt;interface Component&amp;lt;P = {}, S = {}, SS = any&amp;gt;&lt;/code&gt; 的实现。其中 P 是 props 的类型，S 是 state 的类型，它们都是 object 类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因此，TypeScript 的有状态组件大致可以按以下步骤来编写或者阅读：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置 initialState，并根据 initialState 来设定 State 类型或者 State 的 interface：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const initialState = { clicksCount: 0 };
type State = Readonly&amp;lt;typeof initialState&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用 type 或者 interface 设定 props 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class Example extends Component&amp;lt;P, S&amp;gt;&lt;/code&gt; 这里需要指定 props 和 state 的类型 P 和 S&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly state: State = initialState;&lt;/code&gt; 这里建议将 state 设置为 readonly 类型，防止 state 被直接修改&lt;/li&gt;
&lt;li&gt;生命周期方法可以使用 public 来修饰（tslint 要求 class 内部方法必须加入 public 或者 private 来修饰）&lt;/li&gt;
&lt;li&gt;内部方法可以使用 private 来修饰以保护其安全性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;小-tips&#34;&gt;小 Tips&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;从上面的 d.ts 文件的分析可以得知， &lt;code&gt;setState()&lt;/code&gt; 的具体逻辑是可以被提取到组件外部的，这样做的优点是可以将操作 state 的方法剥离出来维护，不需要了解渲染逻辑。&lt;/li&gt;
&lt;li&gt;在使用 mock 数据调试组件的时候，我们可以多用 any 类型来节约 React 组件调试时间成本，直至数据结构完全确定后，再编写完整的数据验证流程&lt;/li&gt;
&lt;li&gt;如果你想使用一个 package 但是遇到了找不到 @types 相关 package 的报错，可以到 Microsoft 的 &lt;a href=&#34;https://microsoft.github.io/TypeSearch/&#34;&gt;TypeScript Types Search&lt;/a&gt; 查询需要 &lt;code&gt;npm install&lt;/code&gt; 什么 package&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;h3 id=&#34;typescript-官方文档&#34;&gt;TypeScript 官方文档&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;英文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tslang.cn/&#34;&gt;中文版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ultimate-react-component-patterns-with-typescript-2-8&#34;&gt;Ultimate React Component Patterns with Typescript 2.8&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://levelup.gitconnected.com/ultimate-react-component-patterns-with-typescript-2-8-82990c516935&#34;&gt;英文原版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5b07caf16fb9a07aa83f2977&#34;&gt;蚂蚁金服技术团队翻译版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mpvue 小程序开发踩坑记</title>
      <link>https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/frontend/mpvue-wx-mini-app-first-look/</guid>
      <description>

&lt;h1 id=&#34;mpvue-小程序开发踩坑记&#34;&gt;mpvue 小程序开发踩坑记&lt;/h1&gt;

&lt;p&gt;之前公司决定开发一款小程序。&lt;/p&gt;

&lt;p&gt;我接触微信小程序也就一两个月的时间，没使用过小程序官方的开发语言，而是直接使用 mpvue 上手了，自己开发了一个因为内容的原因无法上架的 DEMO。正好也被推上了前端部门的 leader，所以也就接下了这个任务。&lt;/p&gt;

&lt;p&gt;使用 mpvue 的因为本以为由 Vue 转小程序用 mpvue 会方便，不过没想到坑挺多的，一般的 Web 开发者如果以 Vue 的思维入手会遇到很多麻烦，因为小程序的运行环境和浏览器完全不同。&lt;/p&gt;

&lt;p&gt;另外京东凹凸实验室的 Taro 也是一个非常好的框架，不过我没有去深入研究它。考虑到公司技术栈转 Vue 的要求，我们团队选择了 mpvue，然而我个人认为 mpvue 还是个不太成熟的框架，文档不完善，在开发编译时也容易出 bug，另外就是分包加载的支持比较慢，好在最近出了新版本的 mpvue-loader。但是新版本的 mpvue-loader 完全更改了 app.json/main.json 文件的写法，文档中也没有明确提到，只能通过新的 quickstart 来了解新的写法。&lt;/p&gt;

&lt;h2 id=&#34;我对小程序和-mpvue-的理解&#34;&gt;我对小程序和 mpvue 的理解&lt;/h2&gt;

&lt;h3 id=&#34;mpvue&#34;&gt;mpvue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;mpvue 是美团开发的，允许开发者使用 Vue 语法来编写小程序的框架。&lt;/li&gt;
&lt;li&gt;小程序和 Web 应用的不同之处是它依靠微信 App 内的 JavaScript 引擎和 WXML/WXSS 引擎进行渲染，所以与 Web 端相比，小程序里不存在 DOM，无法使用原生 DOM 的操作，也不存在浏览器的各种 API。&lt;/li&gt;
&lt;li&gt;在使用 mpvue 时，实际上可以看作是用 Vue 构建多页 Web App。&lt;/li&gt;
&lt;li&gt;在 Webpack 打包时，Vue Web App 是最终打包成 index.html 以及 css 和 js 文件各 1 个（如果你不开 source map 的话）。而 mpvue-loader 是将 Vue 语法转换成小程序原生语法的 Webpack loader，打包后的文件实际上就是原生小程序的语法（js 除外），这样就可以在小程序开发工具中预览和 debug。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;weui&#34;&gt;weui&lt;/h3&gt;

&lt;p&gt;weui 是腾讯开发的 css 框架，可以用于编写腾讯规范的小程序控件。&lt;/p&gt;

&lt;h3 id=&#34;小程序开发工具-微信公众平台-小程序&#34;&gt;小程序开发工具/微信公众平台 - 小程序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;小程序开发工具是用于本地 debug 的工具，使用了 Chrome Devtools，并可以进行真机调试以及发布体验版

&lt;ul&gt;
&lt;li&gt;真机调试：使用小程序上的“远程调试”按钮即可调试，在开发者的微信中的小程序列表中显示为“开发版”&lt;/li&gt;
&lt;li&gt;体验版：使用小程序上的“上传”按钮即可发布体验版，开发者和体验者扫码后可以访问，在开发者和体验者的微信中的小程序列表中显示为“体验版”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;微信公众平台 - 小程序 是小程序项目的管理后台

&lt;ul&gt;
&lt;li&gt;小程序和公众号是两个独立的账号，可以相互关联&lt;/li&gt;
&lt;li&gt;如果要团队协作开发，必须要在微信公众平台上添加开发者和体验者&lt;/li&gt;
&lt;li&gt;若需要使用网络请求，必须在微信公众平台上添加 https 的服务器&lt;/li&gt;
&lt;li&gt;https 服务器的 URL 可以是二级、三级&amp;hellip;域名，但不能带相对路径，例如可以是 api.test.example.cn 或者 api.example.cn，但不能使用 api.example.com/v1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;微信支付&#34;&gt;微信支付&lt;/h2&gt;

&lt;p&gt;微信支付需要小程序上线之后在微信公众平台中申请开通。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&#34;&gt;【微信支付】微信小程序支付开发者文档&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取 openid&lt;/li&gt;
&lt;li&gt;请求支付接口获取 &lt;code&gt;wx.requestPayment()&lt;/code&gt; 所需参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wx.requestPayment()&lt;/code&gt; 发起支付请求，参数见&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/api-pay.html#wxrequestpaymentobject&#34;&gt;微信支付 · 小程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果在手机上操作会直接弹出微信支付相关弹窗，在开发者工具中操作则会生成二维码，扫描即可；在手机上可以直接弹出微信支付的弹窗。&lt;/li&gt;
&lt;li&gt;支付完成后使用 &lt;code&gt;wx.reLaunch&lt;/code&gt; 转跳到结果页面，但是使用 &lt;code&gt;wx.reLaunch&lt;/code&gt; 时，在 Android 上会提示 reLaunch:fail can not invoke reLaunch in background，此时只需加一个 setTimeout 即可。因为调用微信支付的窗口时，实际上会先把当前的 page 隐藏，如果在体验版里打开调试模式可以看到页面先 onHide 再 onShow，而我们需要在支付成功后转跳，所以 &lt;code&gt;wx.reLaunch&lt;/code&gt; 是放在 &lt;code&gt;wx.requestPayment()&lt;/code&gt; 的回调中执行的，此时页面仍没有 onShow，而 &lt;code&gt;wx.reLaunch&lt;/code&gt; 需要在 onShow 之后才能调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;mpvue-小程序开发中需要注意的点&#34;&gt;mpvue 小程序开发中需要注意的点&lt;/h2&gt;

&lt;h3 id=&#34;mpvue-的项目结构&#34;&gt;mpvue 的项目结构&lt;/h3&gt;

&lt;p&gt;我们可以在官方的 quickstart 模板的基础上进行开发【&lt;a href=&#34;http://mpvue.com/mpvue/quickstart/&#34;&gt;Quickstart - mpvue-docs&lt;/a&gt;】。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;static - 静态文件&lt;/li&gt;
&lt;li&gt;src - pages - A - 页面 A - A.vue - .vue 页面 - main.js - Vue 的 js 文件，用于挂载页面 - main.json - 小程序的页面配置文件 - components - 公用组件 - utils - 工具 - app.json - 小程序的 app.json 主文件 - App.vue - 小程序主入口 - main.js - 类似 Vue 的 main.js，加载全局内容，挂载 Vue 实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;小程序有包大小的限制&#34;&gt;小程序有包大小的限制&lt;/h3&gt;

&lt;p&gt;主包最大为 2MB，各个分包大小最大为 8MB。在较大型的小程序开发时，最好是将各个模块独立出来，尽可能只保留入口页面和 Tab 标签页对应的页面在主包中。&lt;/p&gt;

&lt;p&gt;分包加载只有在 mpvue-loader@1.1.x 版本才支持。&lt;/p&gt;

&lt;p&gt;会打包到主包的内容（包括但不限于如下内容）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;放在 app.json 中的 pages 中的页面&lt;/li&gt;
&lt;li&gt;静态文件，如图片&lt;/li&gt;
&lt;li&gt;公用组件&lt;/li&gt;
&lt;li&gt;vuex&lt;/li&gt;
&lt;li&gt;utils&lt;/li&gt;
&lt;li&gt;安装的各种有被引用的 package&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：千万不要因为某个功能用某个 package 做很方便，就安装并引入它，因为这些 package 全部会打包到主包的 vender.js 中！这样很容易造成主包大小过大！&lt;/p&gt;

&lt;p&gt;如果一个 package 是你不得不引入的核心 package（例如 vue, vuex, node-sass, sass-loader 等），那么就将它引入。&lt;/p&gt;

&lt;p&gt;如果一个 package 你只使用到它的 1% 的功能（或者有非常多的功能用不上），请不要引入！例如安装了 qs, moment 和 lodash 之后，在我们公司的项目中，打包后的 vender.js 最大可以达到 1.6MB，而在移除它们所有的引用之后只有 462 KB。&lt;/p&gt;

&lt;p&gt;JS 的大型工具库（如 lodash）千万不要引入 mpvue，因为它们大部分都可以简单地用原生 JS 实现。&lt;/p&gt;

&lt;p&gt;占用空间的静态图片尽可能使用在线资源。导航栏图标和各种 icon，为了用户体验，建议放在本地。&lt;/p&gt;

&lt;h3 id=&#34;小程序有页面栈的限制&#34;&gt;小程序有页面栈的限制&lt;/h3&gt;

&lt;p&gt;由于性能的限制，小程序页面栈中最多只能存在 5 个页面，也就是最多只能转跳 5 层。 此时就需要善用清空页面栈的方法，例如转跳的时候使用 redirectTo / relaunch 等方法。但是在页面栈被清空之后，小程序右上角的返回按钮就会消失，所以在产品设计时处理好转跳逻辑是很关键的。详情见小程序文档：&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/ui-navigate.html&#34;&gt;导航 · 小程序 API&lt;/a&gt;，&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html&#34;&gt;导航 · 小程序组件&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;小程序页面间传值&#34;&gt;小程序页面间传值&lt;/h3&gt;

&lt;p&gt;小程序页面间的传值靠的是路由的 params，类似于 vue-router 中的 params。在新页面中，若要接收值，则需要在 onLoad 生命周期中接收，onLoad 方法的第一个参数即为传入的 params 对象。&lt;/p&gt;

&lt;p&gt;注意：params 传值默认的数据类型是 String。&lt;/p&gt;

&lt;h3 id=&#34;返回时清空数据&#34;&gt;返回时清空数据&lt;/h3&gt;

&lt;p&gt;小程序在点击左上角返回的时候不能自动清空当前页面的数据，如果需要清空数据，我们需要手动在 onUnload 的生命周期钩子里将 Vue 的 data 中的所有数据还原成初始状态。&lt;/p&gt;

&lt;h3 id=&#34;返回上一页-上-x-页-时携带参数&#34;&gt;返回上一页（上 X 页）时携带参数&lt;/h3&gt;

&lt;p&gt;我们在返回时会使用 &lt;code&gt;wx.navigateBack()&lt;/code&gt;，这个方法不可携带参数。所以我们需要用小程序内置的 Storage 或者 Vuex 进行数据存取的操作。&lt;/p&gt;

&lt;p&gt;不建议/不应该使用其他可以带参数的导航方式，因为它们会破坏现有的页面栈或者导致页面栈混乱，除非有特殊的需求。&lt;/p&gt;

&lt;h3 id=&#34;小程序的生命周期&#34;&gt;小程序的生命周期&lt;/h3&gt;

&lt;p&gt;小程序有自己一套生命周期，和 Vue 的生命周期不冲突，但是行为有所区别。&lt;/p&gt;

&lt;p&gt;举例来说，一个页面加载时，这些生命周期钩子会按如下顺序被调用：onLoad, onShow, mounted。页面存在页面栈中时，如果返回该页面，不会触发 onLoad 和 mounted，但是会触发 onShow，因为这个页面已经被挂载了。
更多小程序生命周期的详情请看小程序的官方开发文档。&lt;/p&gt;

&lt;h3 id=&#34;网络请求&#34;&gt;网络请求&lt;/h3&gt;

&lt;p&gt;小程序中发起网络请求可以使用 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject&#34;&gt;wx.request()&lt;/a&gt;，也可以使用 &lt;a href=&#34;https://www.npmjs.com/package/flyio&#34;&gt;fly.io&lt;/a&gt;，一个类似 axios 的开源库。&lt;/p&gt;

&lt;h3 id=&#34;小程序的数据存储&#34;&gt;小程序的数据存储&lt;/h3&gt;

&lt;p&gt;在 Web 中我们有 session 和 WebStorage 可以存储一些公用数据如 token。而小程序有自己的本地缓存：&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/data.html&#34;&gt;数据缓存 · 小程序&lt;/a&gt;，用法和 WebStorage 相似，但是有同步和异步方法的区别。&lt;/p&gt;

&lt;p&gt;在 mpvue 中我们同样可以使用 vuex，但是需要注意的是我们无法像 Web 开发时一样在 &lt;code&gt;new Vue()&lt;/code&gt; 的时候传入 vuex 作为参数，而是需要手动挂载到 Vue.prototype 上。&lt;/p&gt;

&lt;h3 id=&#34;登录与授权&#34;&gt;登录与授权&lt;/h3&gt;

&lt;p&gt;微信的授权弹窗在目前版本中无法主动触发，需要用 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/component/button.html&#34;&gt;button 的 open-type 属性&lt;/a&gt; 获取授权。授权弹窗只能获取微信的用户信息。授权弹窗中有 encryptedData 和 iv，这两个数据很关键，可以让服务端解码出 unionId。unionId 是用户唯一标识，在第三方登录授权中需要使用到。&lt;/p&gt;

&lt;p&gt;如果需要微信开发者平台的第三方登录，需要使用 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html&#34;&gt;wx.login()&lt;/a&gt; 的方法获取 code，并发送给服务端处理，通过 code 可以获取 sessionKey 和 openid。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wx.login()&lt;/code&gt; 一定要在授权弹窗之前调用，因为解密 encryptedData 和 iv 需要 sessionKey，sessionKey 是从 code 获得的。在 &lt;code&gt;wx.login()&lt;/code&gt; 得到的 code（以及 code 获取的 sessionKey） 之后获取的 encryptedData 和 iv 是一一对应的，若颠倒顺序，则 encryptedData 和 iv 无法和 sessionKey 对应上。&lt;/p&gt;

&lt;h3 id=&#34;标签&#34;&gt;标签&lt;/h3&gt;

&lt;p&gt;mpvue 中可以使用 Web 的标签，最后会被编译成对应的小程序标签；也可以使用小程序的原生标签。小程序的原生标签可以帮助我们做很多 Web 标签无法实现的工作，例如 swiper 和 swiper-item 可以实现左滑右滑切换 Tab 页；scroll-view 实际上是一个 &lt;code&gt;overflow-(x/y): auto;&lt;/code&gt; 的块级元素，并且本身不带滚动条，但是注意 scroll-view 并不会触发 onReachBottom 的钩子。&lt;/p&gt;

&lt;h3 id=&#34;分页加载&#34;&gt;分页加载&lt;/h3&gt;

&lt;p&gt;分页加载有两种方式: onReachBottom 和 scroll-view&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 onReachBottom 时不能使用 scroll-view，只能使用普通的 view / div。scroll-view 使用 @scrolltolower (原生小程序是 bindscrolltolower) 的 event。&lt;/li&gt;
&lt;li&gt;包裹着列表组件的容器必须保证能滚动到屏幕底部，也就是说 CSS 里对高度的设置需要注意&lt;/li&gt;
&lt;li&gt;页面&lt;em&gt;组件中需要有变量记录当前页码或者下一页的页码，在触发 onReachBottom&lt;/em&gt;@scrolltolower 时使用这个页码去获取新的分页数据&lt;/li&gt;
&lt;li&gt;分页加载完成后，数据需要加到原列表数组的最后&lt;/li&gt;
&lt;li&gt;页面&lt;em&gt;组件中需要有变量记录总页数，在 onReachBottom&lt;/em&gt;@scrolltolower 时，如果已经到最后一页则不继续加载或者弹出提示&lt;/li&gt;
&lt;li&gt;在进行一些复杂操作的时候记得清空当前页码和总页数，防止数据混乱&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;图片&#34;&gt;图片&lt;/h3&gt;

&lt;p&gt;小程序中的 image 如果不手动设置大小，会默认被设置为 320*240 (rpx)。小程序中 image 的自适应和 Web 开发并不一样，使用的是 &lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/component/image.html&#34;&gt;image 的 mode 属性&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;小程序的 image 不支持 svg 的图片，需要用 css 的 background-image。&lt;/p&gt;

&lt;p&gt;app.json 中，TabBar 的 icon 不能用 svg。&lt;/p&gt;

&lt;p&gt;在 mpvue 中可以使用 iconfont。&lt;/p&gt;

&lt;h3 id=&#34;关于边框&#34;&gt;关于边框&lt;/h3&gt;

&lt;p&gt;mpvue-weui 和微信小程序的某写原生组件如 button 会有自带的边框，它们都是写在 &lt;code&gt;::after&lt;/code&gt; 伪元素中的，如果你使用 border-radius 的话，会导致某些边框消失。此时建议将其隐藏并重新用下面的 rpx 的方式来写边框。&lt;/p&gt;

&lt;h3 id=&#34;长度单位与-1-像素边框&#34;&gt;长度单位与 1 像素边框&lt;/h3&gt;

&lt;p&gt;按照从移动 H5 转过来的思维，1 像素边框一般需要用伪元素来写。小程序中同样可以使用 ::after 伪元素写 1 像素的边框，但是实际的显示出来的位置都和 Web 有区别。可以参考 &lt;a href=&#34;http://kuangpf.com/mpvue-weui/#/README&#34;&gt;mpvue-weui&lt;/a&gt; 的 weui.css 中的方式进行开发。&lt;/p&gt;

&lt;p&gt;但事实上，微信小程序的 rpx 就是自适应单位，相当于移动 H5 做自适应常用的 rem。1rpx = 0.5px = 1 物理像素。所以我们实际上可以使用 rpx 来写 1 像素边框。当然微信小程序也支持 rem，规定屏幕宽度为 20rem，所以 1rem = (屏幕宽度 / 20)rpx。&lt;/p&gt;

&lt;p&gt;button 在有 border-radius 的时候可能边框显示不全，此时建议用 div 包裹 button 并在 div 上写 1px 的 border，隐藏 button 自带的 border。&lt;/p&gt;

&lt;h3 id=&#34;position-fixed&#34;&gt;position: fixed&lt;/h3&gt;

&lt;p&gt;小程序的 position: fixed 和 Web 上的表现有所不同。如果 mpvue 小程序的页面中有其他 Vue 组件，那么在组件中设定的 &lt;code&gt;position: fixed&lt;/code&gt; 只会相对于这个组件是 fixed，并不会在页面中 fixed。如果设定 &lt;code&gt;bottom: 0&lt;/code&gt;，那么它只会固定在 Vue 组件的底部，而不是整个页面的底部。也就是说，mpvue 小程序中的 Vue 组件实际上是一个 BFC。&lt;/p&gt;

&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;

&lt;p&gt;mpvue 中同样有事件，但是调取参数 e 的值的方式和 Web 不同，需要使用 &lt;code&gt;e.mp.detail&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;点击导航条转跳到相应位置-类似通讯录&#34;&gt;点击导航条转跳到相应位置（类似通讯录）&lt;/h3&gt;

&lt;p&gt;在项目中，服务端只会给出所有的城市列表，之后我们需要在本地对其进行分类。按字母分类使用了 &lt;a href=&#34;https://github.com/hotoo/pinyin&#34;&gt;GitHub - hotoo/pinyin: 汉字拼音 ➜ hàn zì pīn yīn&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;页面分为侧边字母导航条和城市列表。项目的需求是只需要列出满足条件的部分城市，所以导航字母也需要根据城市动态显示。&lt;/p&gt;

&lt;p&gt;点击字母滚动到对应位置的功能使用了 scroll-view 的 scroll-into-view，在 scroll-into-view 上动态绑定对应字母的唯一 id（变量在 Vue 的 data 中），同时在我们渲染城市的时候，需要在最外层加上属性 id，与 scroll-into-view 上的 id 要对应。&lt;/p&gt;

&lt;p&gt;字母导航条中，我们需要设定一个 data-i，并在 click 事件中用 &lt;code&gt;e.currentTarget.dataset.i&lt;/code&gt; 获取这个 data-i，并赋值给 data 中绑定 id 的变量，这样就可以直接转跳到相应的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;city&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;city__body&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;current-city&amp;quot;&amp;gt;当前定位城市：{{ city.city }}&amp;lt;/div&amp;gt;
      &amp;lt;scroll-view scroll-y class=&amp;quot;alphabet&amp;quot; :scroll-into-view=&amp;quot;&#39;id-&#39; + toView&amp;quot;&amp;gt;
        &amp;lt;div
          :id=&amp;quot;&#39;id-&#39; + index&amp;quot;
          v-for=&amp;quot;(item, index) in filteredCities&amp;quot;
          :key=&amp;quot;item.firstLetter + index&amp;quot;
        &amp;gt;
          &amp;lt;div class=&amp;quot;weui-cells__title&amp;quot;&amp;gt;{{ item.firstLetter }}&amp;lt;/div&amp;gt;
          &amp;lt;div class=&amp;quot;weui-cells weui-cells_after-title&amp;quot;&amp;gt;
            &amp;lt;div
              class=&amp;quot;weui-cell&amp;quot;
              v-for=&amp;quot;(_item, _index) in item.cities&amp;quot;
              :key=&amp;quot;_item.cityCode + _index&amp;quot;
              @click=&amp;quot;setCity(_item)&amp;quot;
            &amp;gt;
              &amp;lt;div class=&amp;quot;weui-cell__bd&amp;quot;&amp;gt;{{ _item.city }}&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/scroll-view&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;city__letters&amp;quot;&amp;gt;
      &amp;lt;div
        v-for=&amp;quot;(item, index) in nav&amp;quot;
        :key=&amp;quot;item&amp;quot;
        @click=&amp;quot;setAlphabet&amp;quot;
        :data-i=&amp;quot;index&amp;quot;
      &amp;gt;
        {{item}}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script&amp;gt;
export default {
	data() {
    return {
      nav: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;],
      toView: 0,
      cities: []
    }
  },
	onLoad() {
	  // 获取城市
	  getCity().then(res =&amp;gt; {
      if (/* 调用成功 */) {
        const categoriedCities = []
        const cities = []
        let nav = []
        for (const item of res.data.data) {
          // 提取城市首字母，放入导航列表
          const py = pinyin(item.city, { style: pinyin.STYLE_FIRST_LETTER })
          const firstLetter = py[0][0].toUpperCase()
          if (firstLetter.length === 1) {
            nav.push(firstLetter)
          }
          // 构造新的数据，加入首字母
          const newItem = {
            ...item,
            firstLetter,
            city: item.city.substring(0, item.city.length - 1)
          }
          cities.push(newItem)
        }
        // 导航里去除重复的字母
        nav = [...new Set(nav)]
        // 根据导航的字母，把上面构造的数据按照字母进行重新分类，得到最后需要的结果
        // 对每个字母，在上面构造的数据中筛选出相应字母的所有城市，放入一个对象中并 push 入最终数组
        for (const item of nav) {
          const sameLetterCities = cities.filter(i =&amp;gt; i.firstLetter === item)
          categoriedCities.push({
            firstLetter: item,
            cities: sameLetterCities
          })
        }
        this.nav = nav
        this.cities = categoriedCities
      }
    })
	}
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>