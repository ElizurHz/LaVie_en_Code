<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>By-talks on Variation Palladion - 撕裂时间的帕拉迪昂</title>
    <link>https://elizurhz.cn/by-talk/</link>
    <description>Recent content in By-talks on Variation Palladion - 撕裂时间的帕拉迪昂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 10 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://elizurhz.cn/by-talk/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>无后端经验的前端怎样学习 Node.js？</title>
      <link>https://elizurhz.cn/by-talk/fe-learn-node-js/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/by-talk/fe-learn-node-js/</guid>
      <description>很多前端都是只做纯粹的前端工作，虽然工作中有涉及到一些 npm、webpack 相关的内容会需要一点 Node.js 的知识，但是可能这并不是很好地掌握它的一个方法。而我的经验是，不要太局限于 Node.js 技术本身，把眼光放广一点，可能你对它的理解更深一点。
在讲怎样学之前 首先，为什么是 Node.js 很简单，就是它的语言、环境、生态都和前端基本一样。而且很重要的一点是，如果我们要做 SSR（比如已有的非 SSR 项目的首屏优化以及 SEO），那么我们可以直接在 Node.js 里使用比如 react-dom/server 这种 library，这是其他语言所做不到的。不过如果仅仅是搭一个数据的中转平台，那么其实什么语言都可以，而且不一定要前端同学来做。
其次，学来做什么 BFF（Backend for Frontend）。这是近年来兴起的一个架构模式。它让前端参与后端编程，可以针对不同的场景、不同的端，提供不同类型、不同结构的数据，完全由前端掌控业务，迭代起来也较为方便，直接解决了前后端协作最大的矛盾之一，后端在这里只需要专注于基础数据和基础设施即可。当然，架构是架构师定的，你也不可能在已有的系统内随意加 BFF，毕竟这需要考虑到系统总体性能、稳定性等等因素。但是当你接到这样一个工作，或者转入一个这种工作模式的团队，起码你可以不会显得像无头苍蝇一样。
那么，怎样学呢 让我印象最深刻的是极客时间上的那个 Node.js 的实战课程，讲师是腾讯的，也是从前端角度来讲它的，但是它的侧重点是【Node.js 在 BFF 层的这个构架模式中扮演的角色】。首先作为前端，如果我们纯粹去看 Node.js 的技术实现，很可能不知道看了有什么用，从哪里入手，这也是学技术时不能掌握的原因之一。而 BFF 层对于前端来说则是最直接的一种 Node.js 使用方式，它能做的除了 SSR，还有向其他微服务请求数据。可能有很多人可能以为前端学 Node.js 就是要转向后端。学 Node.js 是在做“后端”的工作没错，也就是你要什么数据就提供给你，但是 BFF 实际上并不涉及到“怎样找数据最快”、“怎样维护基础设施”这种问题，这些都是给后端同学做的，本质上就是数据拼接、数据转换的工作（SSR 也只是把结构化数据转换成 HTML/Virtual DOM 而已）。
那么在明白这一点之后，其实有两个“方向”需要考虑的，一就是和前端项目的交互，二就是和后端服务的交互。
首先和前端的交互这方面，其实很好理解，最主要的两个工作，一就是要接收前端发来的请求，二就是提供数据给前端项目，这也是大多数前端对与前端协作的后端的看法。当然还有一个点要注意的就是鉴权，不过这部分一般会有单独的鉴权服务来做，BFF 需要做到的就是正确地转发。而数据这部分，除了 RESTful 去手动拼接，也可以用 GraphQL。至于 SSR 方面，其实看文档就比较明白了。需要全项目 SSR 的话，有 Next.js 等框架可以使用，具体也是看文档就好。
其次是与后端服务的交互，这就会涉及到二进制协议了，也是很多前端完全不了解的领域。后端服务间为了通讯效率，一般不会 HTTP 来请求。用得比较多的是基于 TCP 的自定义的协议。那么在 BFF 层，我们需要知道的就是如何进行数据的 encode 和 decode。首先需要了解的就是怎样使用二进制数据，也就是 Node.</description>
    </item>
    
    <item>
      <title>生产力工具：我是如何挑选键盘的</title>
      <link>https://elizurhz.cn/by-talk/keyboard-for-programmers/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/by-talk/keyboard-for-programmers/</guid>
      <description>一个我认为的”好键盘“大概是什么样的 程序员对键盘的偏好可以说是各异。有的根本没需求，有的需要多端切换等功能性键盘而对手感无需求，有的则是对手感有要求且程度不一。而我是属于对键盘的需求达到极致的那种，倾向性是手感&amp;gt;配列&amp;gt;观感&amp;gt;连接&amp;gt;其他。
其他因素 首先先说“其他”方面，有比如重量、便携性等，因为我是会家里一个公司一个，有其他办公地点的话直接用笔记本内置的就好了，所以对于键盘外设我并没有这种需求。然后这一点其实也和配列有关系，等配列的部分再详谈。再还有就可能是更细节到没必要考虑的情况了，比如 RGB 灯效、板载内存什么的，可能游戏玩家考虑这个会更多。
连接 其次，连接。现在大部分键盘的连接方式分为三种：有线、2.4GHz、蓝牙（iPad Smart Cover 那种特殊触点不考虑，或者可以另外再说）。而我，一是不缺 USB 接口，二是没有线材简洁强迫症，所以对连接方面没有什么忧虑，有双模最好，有线也能用。另外有线的方面我可能是比较不挑的那种，键线分离、接口类型都没什么要求，因为我的键盘线都是专用的，不需要什么便捷性。
观感 然后观感这方面，这里指的是纯粹的键盘外观，这一点当然就因人而异了，起码说我还是觉得，好看的键盘对于工作打字的心态和氛围是 positive 的。
配列 104/980 首先我不倾向于带小键盘的配列，因为程序员的小键盘的使用率其实非常低，一般程序员不会考虑手的大范围移动，因为会降低打字效率。而且小键盘非常占地方，对我来说桌面都挺满的，能节约一点是一点。带小键盘的配列主要是 104 键和 980。980 我倒还是挺满意，因为这个配列的方向键离主键区比较近，而且 980 的代表产品就是 Leopold，L 的做工和设计都非常棒，大键稍肉但是稍微加点润滑就可以做到非常优秀的手感。
80% 然后 80% 配列（也就是常说的 87 键），我觉得也一般，主要是方向键远这个问题，而且 F 区对我来说其实完全没用。
60% - 65% 那么小配列的话我最喜欢的是 60% - 65%，其中 60% 我是只用 HHKB 配列。60% 配列其实有一种是空格右边有四个按键的（就是 104 键的缩小版），这种配列的方向键需要通过 Fn 去 map，但是我一直不习惯这个 map。如果是 HHKB，就是问号右边是 2U shift + Fn，需要小指按住 Fn 然后键盘右侧部分就可以按出各种功能键，包括方向键，我会比较习惯这个。然后就是 Delete 怎么按这个问题，我更习惯 macOS 上 Control + D 这个组合键，而 HHKB 刚好这个键位非常舒服。所以其实我也是很喜欢用 Control 把 CapsLock 替掉的设计。65% 的话没什么好说的，多了方向键，和正常键盘用起来没什么区别，优点在占地面积小，键位紧凑而且功能足够用。</description>
    </item>
    
    <item>
      <title>生产力硬件：Apple M1 对前端开发者有什么影响</title>
      <link>https://elizurhz.cn/by-talk/apple-m1-for-fe/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/by-talk/apple-m1-for-fe/</guid>
      <description>这篇文章主要是从我最近微博动态等提取的观点整合成的一份总结，也发在 B 站专栏了，详情可以点击这里查看
 最近入手了 M1 Mac mini，低配加到 16G 内存，就迫不及待拿来尝试。目前从前端的角度来说，基本是正面的。
优势 硬件上就不多说了，评测很多。M1 有计算能力、内存带宽、SSD 速度、功耗、发热等方面的优势，总体是好于 Intel 不少的。
软件上可能有很多人担心兼容性问题。就前端来说，其实完全是可解决的问题。首先前端依赖的工具主要是 Node.js、文本编辑器（非 IDE，如 VSCode）以及 npm 生态。Node.js 是可以通过 Rosetta 2 安装及运行的，ARM 版正在研发中。VSCode 同样，不过 Insider 版本已经有 ARM 的支持了。
至于 npm 这个就很不好说了，大部分包其实都是可以直接 import/require 的 js 文件，并没有环境依赖，然而还是有少部分怪异的包，比如我们非常常用的 node-sass，它在安装的时候需要根据你本机环境来编译，因为开发者尚未适配，所以无法识别当前 environment，这时你只能手动编译，需要利用 unix 的 arch 指令，加上前缀 arch -x86_64 运行 npm rebuild node-sass。
另外说到 arch -x86_64，它在 ARM 的 macOS 上其实可以起到一种“欺骗”的作用，让你的命令完全通过 Rosetta 2 以 Intel 的兼容模式运行。Homebrew 就是很好的例子，开发者尚未兼容时可以使用它来安装。不过其实没必要滥用，只需要在遇到不适配的时候使用即可。
那么 M1 在实际开发中有什么优势呢？前端在开发中需要高性能计算的场景其实不多，除非是有特殊功能需求。比较常见的情况是跑单元测试，由于 Jest 是会占满所有 CPU 物理核心的，所以性能还是可以一定程度上从这里来评价的。实际结果大概是，接近 800 个 case，M1 比两三年前的 Intel 的 Mac 要快上 10 秒左右，而且还能同时做别的事（Intel 机子会变卡甚至可能就卡得做不了别的事了）。其他场景不好明说，但是就是“各种方面都很快”，平常对电脑的运行速度敏感的话，你应该能明显体会到。</description>
    </item>
    
  </channel>
</rss>
