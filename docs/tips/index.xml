<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tips on Variation Palladion - 撕裂时间的帕拉迪昂</title>
    <link>https://elizurhz.cn/tips/</link>
    <description>Recent content in Tips on Variation Palladion - 撕裂时间的帕拉迪昂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 10 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://elizurhz.cn/tips/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Apple M1 对开发者有什么影响</title>
      <link>https://elizurhz.cn/tips/apple-m1-for-fe/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/tips/apple-m1-for-fe/</guid>
      <description>最近入手了 M1 Mac mini，低配加到 16G 内存，就迫不及待拿来尝试。 目前从前端的角度来说，基本是正面的。 硬件上就不多说了，M1 有计算能力、内存带宽、SSD 速度、功耗、发热等方面的优势，总体体验是好于 Intel 不少的。 软件上可能有很多人担心兼容性问题。就前端来说，其实完全是可解决的问题。首先前端依赖的工具主要是 Node.js、文本编辑器（非 IDE，如 VSCode）以及 npm 生态。Node.js 是可以通过 Rosetta 2 安装及运行的，ARM 版正在研发中。VSCode 同样，不过 Insider 版本已经有 ARM 的支持了。至于 npm 这个就很不好说了，大部分包其实都是可以直接 import/require 的 js 文件，并没有环境依赖，然而还是有少部分怪异的包，比如我们非常常用的 node-sass，它在安装的时候需要根据你本机环境来编译，因为开发者尚未适配，所以无法识别当前 environment，这时你只能手动编译，需要利用 unix 的 arch 指令，加上前缀 arch -x86_64 运行 npm rebuild node-sass。 说到 arch -x86_64，它在 ARM 的 macOS 上其实可以起到一种“欺骗”的作用，让你的命令完全通过 Rosetta 2 以 Intel 的兼容模式运行。homebrew 就是很好的例子，开发者尚未兼容时可以使用它来安装。不过其实没必要滥用，只需要在遇到不适配的时候使用即可。 那么 M1 在实际开发中有什么优势呢。前端在开发中需要高性能计算的场景其实不多，除非是有特殊功能需求。比较常见的情况是跑单元测试，由于 Jest 是会占满所有 CPU 物理核心的，所以这还是可以一定程度上从前端角度来评价的。实际结果大概是，接近 800 个 case，M1 比近两年内的 Intel 的 Mac 要快上 10 秒左右，而且还能同时做别的事（Intel 机型会变卡甚至可能就卡得做不了别的事了）。 那么缺点还是有的，一是雷电口都只有两个，二是 GPU 性能。GPU 要打目前的中高端独显是不可能的，但是其实前端开发中用不到这些。比较大的影响就是视频输出能力，Intel 的机型特别是带独显的，输出三四个非 4K 分辨率是没什么问题，但是 M1 最多只能支持 2 个屏幕（包括内建的），也就是 MacBook 只能外接一个，Mac mini 可以两个但是必须 HDMI + USB-C（双 C 还真的不行[流汗 2]）。众所周知显示器数量和生产力成正比关系，所以这可能是个问题。不过如果有 iPad Pro 或者 iPad Air 4 的话还可以用随航接一个。 尽管有影响生产力的小问题，总体来说我对它的评价还是正面的，可以立即入手作为生产力，外接显示器的问题甚至你想为它改变你的工作流我觉得也是值的。 所以我已经下单准备把我以前的主力工作机 18 款 15 寸低配 MacBook Pro 拿去回收折抵换一台新的低配版 M1 MacBook Air 了，当然还是加到 16G 内存。8G 我觉得是不够用的，因为我在使用 16G 的 Mac mini 进行开发的时候经常会遇到剩余 5G 左右的情况，Chrome 和 Node 都非常吃内存，所以 8G 内存应该会非常卡。</description>
    </item>
    
    <item>
      <title>GitHub 上 Fork 的仓库如何与原仓库同步并提交内容</title>
      <link>https://elizurhz.cn/tips/git-upstream/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/tips/git-upstream/</guid>
      <description>GitHub 上 Fork 的仓库如何与原仓库同步并提交内容 我们可能有时会遇到需要向 GitHub 上的开源的项目提交代码。在 GitHub 中，由于你不是那个开源项目中有权限提交代码的人，你只能 Fork 后再发起 Pull Request。
Fork 仓库 你可以在 GitHub 网页上点击 Fork，之后你可以在你的个人主页的 Repository 中找到你 Fork 的仓库。
然后你就可以将其 clone 到本地。
Fork 的本地仓库与源仓库连接 参考：Syncing a fork - User Documentation
首先在命令行工具中输入
$ git remote -v  此时应该显示如下：
origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)  因为我们没有将其连接到源仓库，所以需要用命令去连接。
$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git  这里的地址是源仓库的地址。接着我们再输入
$ git remote -v  这时应该能看到：
origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) upstream https://github.</description>
    </item>
    
    <item>
      <title>掘金翻译计划存档</title>
      <link>https://elizurhz.cn/tips/translation/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://elizurhz.cn/tips/translation/</guid>
      <description>掘金翻译计划译者 from 2018.12.20
 【译】 用 React 和 Node.js 实现受保护的路由和权限验证 - 掘金 【译】 2019 年你应该要知道的 11 个 React UI 组件库 【译】 2019 年值得学习的顶级 JavaScript 框架与主题  </description>
    </item>
    
  </channel>
</rss>